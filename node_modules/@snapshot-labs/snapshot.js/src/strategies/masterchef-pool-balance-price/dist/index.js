"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.strategy = exports.about = exports.examples = exports.version = exports.author = void 0;
var units_1 = require("@ethersproject/units");
var utils_1 = require("../../utils");
var bignumber_1 = require("@ethersproject/bignumber");
var cross_fetch_1 = require("cross-fetch");
var examples_json_1 = require("./examples.json");
var README_md_1 = require("./README.md");
exports.author = 'joaomajesus';
exports.version = '0.1.0';
exports.examples = examples_json_1["default"];
exports.about = README_md_1["default"];
/*
 * Generic masterchef pool balance or price strategy. Accepted options:
 * - chefAddress: Masterchef contract address
 * - pid: Mastechef pool id (starting with zero)
 *
 * - uniPairAddress: Address of a uniswap pair (or a sushi pair or any other with the same interface)
 *    - If the uniPairAddress option is provided, converts staked LP token balance to base token balance
 *      (based on the pair total supply and base token reserve)
 *    - If uniPairAddress is null or undefined, returns staked token balance of the pool
 *
 * - weight: Integer multiplier of the result (for combining strategies with different weights, totally optional)
 * - weightDecimals: Integer value of number of decimal places to apply to the final result
 *
 * - token0.address: Address of the uniPair token 0. If defined, the strategy will return the result for the token0.
 *                   can be used in conjunction with token1Address to get the sum of tokens or the UniPair token price
 *                   when used with usePrice and token1Address.
 *                   Can be used with usePrice to get the price value of the staked amount of token0
 * - token0.weight: Integer multiplier of the result for token0
 * - token0.weightDecimals: Integer value of number of decimal places to apply to the result of token0
 *
 * - token1.address: Address of the uniPair token 1. If defined, the strategy will return the result for the token1.
 *                   can be used in conjunction with token0Address to get the sum of tokens or the UniPair token price
 *                   when used with usePrice and token0Address.
 *                   can be used with usePrice to get the price value of the staked amount of token1
 * - token1,weight: Integer multiplier of the result for token1
 * - token1.weightDecimal: Integer value of number of decimal places to apply to the result of token1
 *
 * - usePrice: Boolean flag return the result in usd instead of token count
 *
 * - currency: currency for the price. (defaulted to 'usd').
 *
 * - log: Boolean flag to enable or disable logging to the console (used for debugging purposes during development)
 *
 * - antiWhale.enable: Boolean flag to apply an anti-whale measure reducing the effect on the voting power as the token amount increases.
 *    - if enabled will apply the the following to the result:
 *
 *      If result > antiWhale.threshold
 *        result = antiWhale.inflectionPoint * ( result / antiWhale.inflectionPoint ) ^ antiWhale.exponent
 *
 *      If result <= antiWhale.threshold
 *        thresholdMultiplier = ( antiWhale.inflectionPoint * ( antiWhale.threshold / antiWhale.inflectionPoint )^antiWhale.exponent ) / antiWhale.threshold
 *        result = result * thresholdMultiplier
 *
 *      - thresholdMultiplier: The multiplier at which all results below threshold are multiplied. This is ratio of antiWhale/result at the threshold point.
 * - antiWhale.threshold: Point at which antiWhale effect no longer applies. Results less than this will be treated with a static multiplier.
 *                        This is to reduce infinite incentive for multiple wallet exploits.
 *    - default: 1625.
 *    - lower cap: > 0 - set to default if <= 0.
 * - antiWhale.inflectionPoint: Point at which output matches result. Results less than this increase output. Results greater than this decrease output.
 *    - default: 6500.
 *    - lower cap: > 0 - set to default if <= 0.
 *    - must be >= antiWhale.threshold. Otherwise will be same as antiWhale.threshold.
 * - antiWhale.exponent: The exponent is responsible for the antiWhale effect. Must be less than one, or else it will have a pro-whale effect.
 *                       Must be greater than zero, or else it will cause total voting power to trend to zero.
 *    - default: 0.5.
 *    - upper cap: 1.
 *    - lower cap: > 0 - set to default if <= 0.
 *
 * Check the examples.json file for how to use the options.
 */
var abi = [
    'function userInfo(uint256, address) view returns (uint256 amount, uint256 rewardDebt)',
    'function totalSupply() view returns (uint256)',
    'function getReserves() view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast)',
    'function token0() view returns (address)',
    'function token1() view returns (address)',
    'function decimals() view returns (uint8)'
];
var networksWithPlatforms = {
    1: 'ethereum',
    56: 'binance-smart-chain',
    66: 'okex-chain',
    88: 'tomochain',
    100: 'xdai',
    128: 'huobi-token',
    137: 'polygon-pos',
    250: 'fantom',
    42220: 'celo',
    43114: 'avalanche',
    1666600000: 'harmony-shard-0'
};
var priceCache = new Map();
var blockCache = new Map();
var log = [];
var _options;
var getUserInfoCalls = function (addresses) {
    var result = [];
    for (var _i = 0, addresses_1 = addresses; _i < addresses_1.length; _i++) {
        var address = addresses_1[_i];
        result.push([_options.chefAddress, 'userInfo', [_options.pid, address]]);
    }
    return result;
};
var getTokenCalls = function () {
    var _a, _b;
    var result = [];
    if (_options.uniPairAddress != null) {
        result.push([_options.uniPairAddress, 'totalSupply', []]);
        result.push([_options.uniPairAddress, 'getReserves', []]);
        result.push([_options.uniPairAddress, 'token0', []]);
        result.push([_options.uniPairAddress, 'token1', []]);
        result.push([_options.uniPairAddress, 'decimals', []]);
        if (((_a = _options.token0) === null || _a === void 0 ? void 0 : _a.address) != null) {
            result.push([_options.token0.address, 'decimals', []]);
        }
        if (((_b = _options.token1) === null || _b === void 0 ? void 0 : _b.address) != null) {
            result.push([_options.token1.address, 'decimals', []]);
        }
    }
    return result;
};
function arrayChunk(arr, chunkSize) {
    var result = [];
    for (var i = 0, j = arr.length; i < j; i += chunkSize) {
        result.push(arr.slice(i, i + chunkSize));
    }
    return result;
}
function processValues(values, tokenValues, network, provider, blockTag) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter(this, void 0, void 0, function () {
        var poolStaked, weight, weightDecimals, result, uniTotalSupply, uniReserve0, uniReserve1, uniPairDecimalsIndex, uniPairDecimalsCount, uniPairDecimals, token0Address, useToken0, token0DecimalsIndex, _h, token1Address, useToken1, token1DecimalsIndex, _j, tokenCount;
        return __generator(this, function (_k) {
            switch (_k.label) {
                case 0:
                    log.push("values = " + JSON.stringify(values, undefined, 2));
                    log.push("tokenValues = " + JSON.stringify(tokenValues, undefined, 2));
                    printLog();
                    poolStaked = values[0][0];
                    weight = bignumber_1.BigNumber.from(_options.weight || 1);
                    weightDecimals = bignumber_1.BigNumber.from(10).pow(bignumber_1.BigNumber.from(_options.weightDecimals || 0));
                    result = 0;
                    if (!(_options.uniPairAddress == null)) return [3 /*break*/, 1];
                    log.push("poolStaked = " + poolStaked);
                    printLog();
                    result = toFloat(poolStaked, _options.decimals);
                    return [3 /*break*/, 6];
                case 1:
                    uniTotalSupply = tokenValues[0][0];
                    uniReserve0 = tokenValues[1][0];
                    uniReserve1 = tokenValues[1][1];
                    uniPairDecimalsIndex = _options.uniPairAddress != null ? 4 : null;
                    uniPairDecimalsCount = tokenValues[uniPairDecimalsIndex][0];
                    uniPairDecimals = uniPairDecimalsIndex != null
                        ? bignumber_1.BigNumber.from(10).pow(bignumber_1.BigNumber.from(uniPairDecimalsCount || 0))
                        : bignumber_1.BigNumber.from(1);
                    token0Address = tokenValues[2][0];
                    useToken0 = ((_a = _options.token0) === null || _a === void 0 ? void 0 : _a.address) != null &&
                        _options.token0.address.toString().toLowerCase() == (token0Address === null || token0Address === void 0 ? void 0 : token0Address.toString().toLowerCase());
                    log.push("useToken0 = " + useToken0);
                    if (!useToken0) return [3 /*break*/, 3];
                    token0DecimalsIndex = 5;
                    log.push("token0DecimalsIndex = " + token0DecimalsIndex);
                    log.push("tokenValues = " + JSON.stringify(tokenValues, undefined, 2));
                    printLog();
                    _h = result;
                    return [4 /*yield*/, GetTokenValue(network, provider, blockTag, uniTotalSupply, uniReserve0, uniPairDecimals, poolStaked, tokenValues, token0Address, token0DecimalsIndex, (_b = _options.token0) === null || _b === void 0 ? void 0 : _b.weight, (_c = _options.token0) === null || _c === void 0 ? void 0 : _c.weightDecimals)];
                case 2:
                    result = _h + _k.sent();
                    _k.label = 3;
                case 3:
                    token1Address = tokenValues[3][0];
                    useToken1 = ((_d = _options.token1) === null || _d === void 0 ? void 0 : _d.address) != null &&
                        _options.token1.address.toString().toLowerCase() == (token1Address === null || token1Address === void 0 ? void 0 : token1Address.toString().toLowerCase());
                    log.push("useToken1 = " + useToken1);
                    if (!useToken1) return [3 /*break*/, 5];
                    token1DecimalsIndex = ((_e = _options.token0) === null || _e === void 0 ? void 0 : _e.address) != null ? 6 : 5;
                    log.push("token1DecimalsIndex = " + token1DecimalsIndex);
                    log.push("tokenValues = " + JSON.stringify(tokenValues, undefined, 2));
                    printLog();
                    _j = result;
                    return [4 /*yield*/, GetTokenValue(network, provider, blockTag, uniTotalSupply, uniReserve1, uniPairDecimals, poolStaked, tokenValues, token1Address, token1DecimalsIndex, (_f = _options.token1) === null || _f === void 0 ? void 0 : _f.weight, (_g = _options.token1) === null || _g === void 0 ? void 0 : _g.WeightDecimals)];
                case 4:
                    result = _j + _k.sent();
                    _k.label = 5;
                case 5:
                    if (!useToken0 && !useToken1) {
                        log.push("poolStaked = " + poolStaked);
                        log.push("uniPairDecimals = " + uniPairDecimals);
                        printLog();
                        tokenCount = poolStaked.toNumber() / Math.pow(10, uniPairDecimalsCount);
                        log.push("tokenCount = " + tokenCount);
                        result = tokenCount / Math.pow(10, (_options.decimals || 0));
                    }
                    _k.label = 6;
                case 6:
                    log.push("result = " + result);
                    printLog();
                    result *= weight.toNumber() / weightDecimals.toNumber();
                    log.push("weight = " + weight);
                    log.push("weightDecimals = " + weightDecimals);
                    log.push("result = " + result);
                    printLog();
                    return [2 /*return*/, applyAntiWhaleMeasures(result)];
            }
        });
    });
}
function applyAntiWhaleMeasures(result) {
    var _a, _b;
    log.push("antiWhale = " + ((_a = _options.antiWhale) === null || _a === void 0 ? void 0 : _a.enable));
    if (((_b = _options.antiWhale) === null || _b === void 0 ? void 0 : _b.enable) != true) {
        printLog();
        return result;
    }
    var threshold = _options.antiWhale.threshold == null || _options.antiWhale.threshold <= 0
        ? 1625
        : _options.antiWhale.threshold;
    var inflectionPoint = _options.antiWhale.inflectionPoint == null ||
        _options.antiWhale.inflectionPoint <= 0
        ? 6500
        : _options.antiWhale.inflectionPoint;
    inflectionPoint = inflectionPoint < threshold ? threshold : inflectionPoint;
    var exponent = _options.antiWhale.exponent == null || _options.antiWhale.exponent <= 0
        ? 0.5
        : _options.antiWhale.exponent > 1
            ? 1
            : _options.antiWhale.exponent;
    log.push("inflectionPoint = " + inflectionPoint);
    log.push("exponent = " + exponent);
    log.push("threshold = " + threshold);
    printLog();
    if (result > threshold) {
        result = inflectionPoint * Math.pow((result / inflectionPoint), exponent);
    }
    else {
        var thresholdMultiplier = (inflectionPoint * Math.pow((threshold / inflectionPoint), exponent)) / threshold;
        log.push("thresholdMultiplier = " + thresholdMultiplier);
        result = result * thresholdMultiplier;
    }
    log.push("result = " + result);
    printLog();
    return result;
}
function toFloat(tokenCount, decimals) {
    return parseFloat(units_1.formatUnits(tokenCount.toString(), decimals || 18));
}
function GetTokenValue(network, provider, blockTag, uniTotalSupply, uniReserve, uniPairDecimals, poolStaked, tokenValues, tokenAddress, tokenDecimalsIndex, tokenWeight, tokenWeightDecimals) {
    return __awaiter(this, void 0, void 0, function () {
        var weightDecimals, weight, tokensPerLp, tokenDecimals, price, tokenCount;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    weightDecimals = bignumber_1.BigNumber.from(10).pow(bignumber_1.BigNumber.from(tokenWeightDecimals || 0));
                    weight = bignumber_1.BigNumber.from(tokenWeight || 1);
                    tokensPerLp = uniReserve.mul(uniPairDecimals).div(uniTotalSupply);
                    tokenDecimals = tokenDecimalsIndex != null
                        ? bignumber_1.BigNumber.from(10).pow(bignumber_1.BigNumber.from(tokenValues[tokenDecimalsIndex][0] || 0))
                        : bignumber_1.BigNumber.from(1);
                    return [4 /*yield*/, getTokenPrice(tokenAddress, network, provider, blockTag)];
                case 1:
                    price = _a.sent();
                    log.push("tokenAddress = " + tokenAddress);
                    log.push("tokenDecimals = " + tokenDecimals);
                    log.push("poolStaked = " + poolStaked);
                    log.push("uniReserve = " + uniReserve);
                    log.push("uniPairDecimals = " + uniPairDecimals);
                    log.push("uniTotalSupply = " + uniTotalSupply);
                    log.push("tokensPerLp = " + tokensPerLp);
                    log.push("tokenWeight = " + weight);
                    log.push("tokenWeightDecimals = " + weightDecimals);
                    log.push("price = " + price);
                    printLog();
                    tokenCount = poolStaked
                        .mul(tokensPerLp)
                        .div(tokenDecimals)
                        .mul(weight)
                        .div(weightDecimals);
                    log.push("tokenCount = " + tokenCount);
                    return [2 /*return*/, toFloat(tokenCount, _options.decimals) * price];
            }
        });
    });
}
function printLog() {
    if (_options.log || false) {
        console.debug(log);
        log = [];
    }
}
function getTokenPrice(tokenAddress, network, provider, blockTag) {
    return __awaiter(this, void 0, void 0, function () {
        var price, cacheKey, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    price = 1;
                    cacheKey = tokenAddress + blockTag;
                    if (!(_options.usePrice === true && !priceCache.has(cacheKey))) return [3 /*break*/, 2];
                    log.push("calling getPrice for token address: " + tokenAddress + " and blockTag: " + blockTag);
                    _b = (_a = priceCache).set;
                    _c = [cacheKey];
                    return [4 /*yield*/, getPrice(network, provider, tokenAddress, blockTag)];
                case 1:
                    _b.apply(_a, _c.concat([(_d.sent()) || 1]));
                    _d.label = 2;
                case 2:
                    price = priceCache.get(cacheKey) || 1;
                    return [2 /*return*/, price];
            }
        });
    });
}
function getPrice(network, provider, address, blockTag) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function () {
        var _c, _d, _e, block, platform, currency, from, to, coingeckoApiURL, coingeckoData;
        var _this = this;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    if (!!blockCache.has(blockTag)) return [3 /*break*/, 2];
                    _d = (_c = blockCache).set;
                    _e = [blockTag];
                    return [4 /*yield*/, provider.getBlock(blockTag)];
                case 1:
                    _d.apply(_c, _e.concat([_f.sent()]));
                    _f.label = 2;
                case 2:
                    block = blockCache.get(blockTag);
                    platform = networksWithPlatforms[network];
                    currency = _options.currency || 'usd';
                    from = block.timestamp - 100000;
                    to = block.timestamp;
                    coingeckoApiURL = "https://api.coingecko.com/api/v3/coins/" + platform + "/contract/" + new String(address).toLowerCase() + "/market_chart/range?vs_currency=" + currency + "&from=" + from + "&to=" + to;
                    log.push("platform = " + platform);
                    log.push("from = " + from);
                    log.push("to = " + from);
                    log.push("coingeckoApiURL = " + coingeckoApiURL);
                    return [4 /*yield*/, cross_fetch_1["default"](coingeckoApiURL)
                            .then(function (r) { return __awaiter(_this, void 0, void 0, function () {
                            var json;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        log.push("coingeco response = " + JSON.stringify(r, undefined, 2));
                                        return [4 /*yield*/, r.json()];
                                    case 1:
                                        json = _a.sent();
                                        log.push("coingecko json = " + JSON.stringify(json, undefined, 2));
                                        return [2 /*return*/, json];
                                }
                            });
                        }); })["catch"](function (e) {
                            console.error(e);
                            throw new Error('Strategy masterchef-pool-balance-of-token: coingecko api failed');
                        })];
                case 3:
                    coingeckoData = _f.sent();
                    return [2 /*return*/, (((_b = (_a = coingeckoData.prices) === null || _a === void 0 ? void 0 : _a.pop()) === null || _b === void 0 ? void 0 : _b.pop()) || 0)];
            }
        });
    });
}
function strategy(space, network, provider, addresses, options, snapshot) {
    return __awaiter(this, void 0, void 0, function () {
        var blockTag, userInfoCalls, tokenCalls, entries, userInfoResponse, userInfoChunks, tokenResponse, i, value, score;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _options = options;
                    blockTag = typeof snapshot === 'number' ? snapshot : 'latest';
                    userInfoCalls = getUserInfoCalls(addresses);
                    tokenCalls = getTokenCalls();
                    entries = new Map();
                    return [4 /*yield*/, utils_1.multicall(network, provider, abi, userInfoCalls, { blockTag: blockTag })];
                case 1:
                    userInfoResponse = _a.sent();
                    userInfoChunks = arrayChunk(userInfoResponse, 1);
                    return [4 /*yield*/, utils_1.multicall(network, provider, abi, tokenCalls, {
                            blockTag: blockTag
                        })];
                case 2:
                    tokenResponse = _a.sent();
                    i = 0;
                    _a.label = 3;
                case 3:
                    if (!(i < userInfoChunks.length)) return [3 /*break*/, 6];
                    value = userInfoChunks[i];
                    return [4 /*yield*/, processValues(value, tokenResponse, network, provider, blockTag)];
                case 4:
                    score = _a.sent();
                    entries.set(addresses[i], score);
                    _a.label = 5;
                case 5:
                    i++;
                    return [3 /*break*/, 3];
                case 6: return [2 /*return*/, Object.fromEntries(entries)];
            }
        });
    });
}
exports.strategy = strategy;

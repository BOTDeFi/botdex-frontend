"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
var address_1 = require("@ethersproject/address");
var bignumber_1 = require("@ethersproject/bignumber/lib/bignumber");
var bytes_1 = require("@ethersproject/bytes");
var constants_1 = require("@ethersproject/constants");
var solidity_1 = require("@ethersproject/solidity");
var utils_1 = require("../../utils");
var provider_1 = require("../../utils/provider");
var hash_1 = require("@ethersproject/hash");
var contracts_1 = require("@ethersproject/contracts");
var EIP712_TYPES = {
    Transaction: [
        {
            name: 'to',
            type: 'address'
        },
        {
            name: 'value',
            type: 'uint256'
        },
        {
            name: 'data',
            type: 'bytes'
        },
        {
            name: 'operation',
            type: 'uint8'
        },
        {
            name: 'nonce',
            type: 'uint256'
        }
    ]
};
var ModuleAbi = [
    // Events
    'event ProposalQuestionCreated(bytes32 indexed questionId, string indexed proposalId)',
    // Read functions
    'function owner() view returns (address)',
    'function oracle() view returns (address)',
    'function questionCooldown() view returns (uint32)',
    'function buildQuestion(string proposalId, bytes32[] txHashes) view returns (string)',
    'function executedProposalTransactions(bytes32 questionHash, bytes32 txHash) view returns (bool)',
    'function questionIds(bytes32 questionHash) view returns (bytes32)',
    'function minimumBond() view returns (uint256)',
    // Write functions
    'function addProposal(string proposalId, bytes32[] txHashes)',
    'function executeProposalWithIndex(string proposalId, bytes32[] txHashes, address to, uint256 value, bytes data, uint8 operation, uint256 txIndex)'
];
var OracleAbi = [
    // Events
    "event LogNewAnswer(\n    bytes32 answer,\n    bytes32 indexed question_id,\n    bytes32 history_hash,\n    address indexed user,\n    uint256 bond,\n    uint256 ts,\n    bool is_commitment\n  )",
    // Read functions
    'function resultFor(bytes32 question_id) view returns (bytes32)',
    'function getFinalizeTS(bytes32 question_id) view returns (uint32)',
    'function getBond(bytes32 question_id) view returns (uint256)',
    'function getBestAnswer(bytes32 question_id) view returns (uint32)',
    'function balanceOf(address) view returns (uint256)',
    'function getHistoryHash(bytes32 question_id) view returns (bytes32)',
    'function isFinalized(bytes32 question_id) view returns (bool)',
    'function token() view returns (address)',
    // Write functions
    'function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) external payable',
    'function submitAnswerERC20(bytes32 question_id, bytes32 answer, uint256 max_previous, uint256 tokens) external',
    "function claimMultipleAndWithdrawBalance(\n    bytes32[] question_ids,\n    uint256[] lengths,\n    bytes32[] hist_hashes,\n    address[] addrs,\n    uint256[] bonds,\n    bytes32[] answers\n  ) public",
    'function withdraw() public'
];
var TokenAbi = [
    //Read functions
    'function balanceOf(address account) view returns (uint256)',
    'function decimals() view returns (uint32)',
    'function symbol() view returns (string)',
    'function allowance(address owner, address spender) external view returns (uint256)',
    // Write functions
    'function approve(address spender, uint256 value) external returns (bool)'
];
var START_BLOCKS = {
    1: 6531147,
    4: 3175028
};
var buildQuestion = function (proposalId, txHashes) { return __awaiter(void 0, void 0, void 0, function () {
    var hashesHash;
    return __generator(this, function (_a) {
        hashesHash = solidity_1.keccak256(['bytes32[]'], [txHashes]).slice(2);
        return [2 /*return*/, proposalId + "\u241F" + hashesHash];
    });
}); };
var getProposalDetails = function (provider, network, moduleAddress, questionHash, txHashes) { return __awaiter(void 0, void 0, Promise, function () {
    var proposalInfo, questionId, nextIndexToExecute;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.multicall(network, provider, ModuleAbi, [[moduleAddress, 'questionIds', [questionHash]]].concat(txHashes.map(function (txHash) { return [
                    moduleAddress,
                    'executedProposalTransactions',
                    [questionHash, txHash]
                ]; })))];
            case 1:
                proposalInfo = (_a.sent()).map(function (res) { return res[0]; });
                questionId = proposalInfo[0];
                nextIndexToExecute = proposalInfo.indexOf(false, 1) - 1;
                return [2 /*return*/, {
                        questionId: questionId !== constants_1.HashZero ? questionId : undefined,
                        nextTxIndex: nextIndexToExecute < 0 || nextIndexToExecute >= txHashes.length
                            ? undefined
                            : nextIndexToExecute
                    }];
        }
    });
}); };
var getModuleDetails = function (provider, network, moduleAddress) { return __awaiter(void 0, void 0, Promise, function () {
    var moduleDetails;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.multicall(network, provider, ModuleAbi, [
                    [moduleAddress, 'owner'],
                    [moduleAddress, 'oracle'],
                    [moduleAddress, 'questionCooldown'],
                    [moduleAddress, 'minimumBond']
                ])];
            case 1:
                moduleDetails = _a.sent();
                return [2 /*return*/, {
                        dao: moduleDetails[0][0],
                        oracle: moduleDetails[1][0],
                        cooldown: moduleDetails[2][0],
                        minimumBond: moduleDetails[3][0]
                    }];
        }
    });
}); };
var checkPossibleExecution = function (provider, network, oracleAddress, questionId) { return __awaiter(void 0, void 0, Promise, function () {
    var result, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!questionId) return [3 /*break*/, 4];
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, utils_1.multicall(network, provider, OracleAbi, [
                        [oracleAddress, 'resultFor', [questionId]],
                        [oracleAddress, 'getFinalizeTS', [questionId]]
                    ])];
            case 2:
                result = _a.sent();
                return [2 /*return*/, {
                        executionApproved: bignumber_1.BigNumber.from(result[0][0]).eq(bignumber_1.BigNumber.from(1)),
                        finalizedAt: bignumber_1.BigNumber.from(result[1][0]).toNumber()
                    }];
            case 3:
                e_1 = _a.sent();
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/, {
                    executionApproved: false,
                    finalizedAt: undefined
                }];
        }
    });
}); };
var retrieveInfoFromOracle = function (provider, network, oracleAddress, questionId) { return __awaiter(void 0, void 0, Promise, function () {
    var result, currentBond, answer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!questionId) return [3 /*break*/, 2];
                return [4 /*yield*/, utils_1.multicall(network, provider, OracleAbi, [
                        [oracleAddress, 'getFinalizeTS', [questionId]],
                        [oracleAddress, 'getBond', [questionId]],
                        [oracleAddress, 'getBestAnswer', [questionId]]
                    ])];
            case 1:
                result = _a.sent();
                currentBond = bignumber_1.BigNumber.from(result[1][0]);
                answer = bignumber_1.BigNumber.from(result[2][0]);
                return [2 /*return*/, {
                        currentBond: currentBond,
                        isApproved: answer.eq(bignumber_1.BigNumber.from(1)),
                        endTime: bignumber_1.BigNumber.from(result[0][0]).toNumber()
                    }];
            case 2: return [2 /*return*/, {
                    currentBond: undefined,
                    isApproved: false,
                    endTime: undefined
                }];
        }
    });
}); };
var Plugin = /** @class */ (function () {
    function Plugin() {
        this.author = 'Gnosis';
        this.version = '1.0.0';
        this.name = 'SafeSnap';
        this.website = 'https://safe.gnosis.io';
    }
    Plugin.prototype.validateTransaction = function (transaction) {
        var addressEmptyOrValidate = transaction.to === '' || address_1.isAddress(transaction.to);
        return (bignumber_1.isBigNumberish(transaction.value) &&
            addressEmptyOrValidate &&
            (!transaction.data || bytes_1.isHexString(transaction.data)) &&
            transaction.operation in ['0', '1'] &&
            bignumber_1.isBigNumberish(transaction.nonce));
    };
    Plugin.prototype.calcTransactionHash = function (network, moduleAddress, transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, domain;
            return __generator(this, function (_a) {
                chainId = parseInt(network);
                domain = {
                    chainId: chainId,
                    verifyingContract: moduleAddress
                };
                return [2 /*return*/, hash_1._TypedDataEncoder.hash(domain, EIP712_TYPES, transaction)];
            });
        });
    };
    Plugin.prototype.calcTransactionHashes = function (chainId, moduleAddress, transactions) {
        return __awaiter(this, void 0, void 0, function () {
            var domain;
            return __generator(this, function (_a) {
                domain = {
                    chainId: chainId,
                    verifyingContract: moduleAddress
                };
                return [2 /*return*/, transactions.map(function (tx) {
                        var txHash = hash_1._TypedDataEncoder.hash(domain, EIP712_TYPES, __assign({ 
                            // @ts-ignore
                            nonce: '0', 
                            // @ts-ignore
                            data: '0x' }, tx));
                        return txHash;
                    })];
            });
        });
    };
    Plugin.prototype.getExecutionDetails = function (network, moduleAddress, proposalId, transactions) {
        return __awaiter(this, void 0, Promise, function () {
            var provider, chainId, txHashes, question, questionHash, proposalDetails, moduleDetails, questionState, infoFromOracle;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = provider_1["default"](network);
                        chainId = parseInt(network);
                        return [4 /*yield*/, this.calcTransactionHashes(chainId, moduleAddress, transactions)];
                    case 1:
                        txHashes = _a.sent();
                        return [4 /*yield*/, buildQuestion(proposalId, txHashes)];
                    case 2:
                        question = _a.sent();
                        questionHash = solidity_1.keccak256(['string'], [question]);
                        return [4 /*yield*/, getProposalDetails(provider, network, moduleAddress, questionHash, txHashes)];
                    case 3:
                        proposalDetails = _a.sent();
                        return [4 /*yield*/, getModuleDetails(provider, network, moduleAddress)];
                    case 4:
                        moduleDetails = _a.sent();
                        return [4 /*yield*/, checkPossibleExecution(provider, network, moduleDetails.oracle, proposalDetails.questionId)];
                    case 5:
                        questionState = _a.sent();
                        return [4 /*yield*/, retrieveInfoFromOracle(provider, network, moduleDetails.oracle, proposalDetails.questionId)];
                    case 6:
                        infoFromOracle = _a.sent();
                        try {
                            return [2 /*return*/, __assign(__assign(__assign(__assign(__assign(__assign({}, moduleDetails), { proposalId: proposalId }), questionState), proposalDetails), { transactions: transactions,
                                    txHashes: txHashes }), infoFromOracle)];
                        }
                        catch (e) {
                            throw new Error(e);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Plugin.prototype.getModuleDetails = function (network, moduleAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var provider;
            return __generator(this, function (_a) {
                provider = provider_1["default"](network);
                return [2 /*return*/, getModuleDetails(provider, network, moduleAddress)];
            });
        });
    };
    Plugin.prototype.submitProposal = function (web3, moduleAddress, proposalId, transactions) {
        return __awaiter(this, void 0, void 0, function () {
            var txHashes, tx, receipt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.calcTransactionHashes(web3.network.chainId, moduleAddress, transactions)];
                    case 1:
                        txHashes = _a.sent();
                        return [4 /*yield*/, utils_1.sendTransaction(web3, moduleAddress, ModuleAbi, 'addProposal', [proposalId, txHashes])];
                    case 2:
                        tx = _a.sent();
                        return [4 /*yield*/, tx.wait()];
                    case 3:
                        receipt = _a.sent();
                        console.log('[DAO module] submitted proposal:', receipt);
                        return [2 /*return*/];
                }
            });
        });
    };
    Plugin.prototype.loadClaimBondData = function (web3, network, questionId, oracleAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var contract, provider, _a, userBalance, bestAnswer, historyHash, isFinalized, tokenSymbol, tokenDecimals, token, _b, symbol, decimals, e_2, answersFilter, events, users, historyHashes, bonds, answers, alreadyClaimed, address, currentUserAnswers, votedForCorrectQuestion, hasBalance, firstHash;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        contract = new contracts_1.Contract(oracleAddress, OracleAbi, web3);
                        provider = provider_1["default"](network);
                        return [4 /*yield*/, utils_1.multicall(network, provider, OracleAbi, [
                                [oracleAddress, 'balanceOf', [web3.provider.selectedAddress]],
                                [oracleAddress, 'getBestAnswer', [questionId]],
                                [oracleAddress, 'getHistoryHash', [questionId]],
                                [oracleAddress, 'isFinalized', [questionId]]
                            ])];
                    case 1:
                        _a = _c.sent(), userBalance = _a[0][0], bestAnswer = _a[1][0], historyHash = _a[2][0], isFinalized = _a[3][0];
                        tokenSymbol = 'ETH';
                        tokenDecimals = 18;
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, utils_1.call(provider, OracleAbi, [
                                oracleAddress,
                                'token',
                                []
                            ])];
                    case 3:
                        token = _c.sent();
                        return [4 /*yield*/, utils_1.multicall(network, provider, TokenAbi, [
                                [token, 'symbol', []],
                                [token, 'decimals', []]
                            ])];
                    case 4:
                        _b = _c.sent(), symbol = _b[0][0], decimals = _b[1][0];
                        tokenSymbol = symbol;
                        tokenDecimals = decimals;
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _c.sent();
                        return [3 /*break*/, 6];
                    case 6:
                        answersFilter = contract.filters.LogNewAnswer(null, questionId);
                        return [4 /*yield*/, contract.queryFilter(answersFilter, START_BLOCKS[network])];
                    case 7:
                        events = _c.sent();
                        users = [];
                        historyHashes = [];
                        bonds = [];
                        answers = [];
                        // We need to send the information from last to first
                        events.reverse().forEach(function (_a) {
                            var args = _a.args;
                            users.push(args === null || args === void 0 ? void 0 : args.user.toLowerCase());
                            historyHashes.push(args === null || args === void 0 ? void 0 : args.history_hash);
                            bonds.push(args === null || args === void 0 ? void 0 : args.bond);
                            answers.push(args === null || args === void 0 ? void 0 : args.answer);
                        });
                        alreadyClaimed = bignumber_1.BigNumber.from(historyHash).eq(0);
                        address = web3.provider.selectedAddress.toLowerCase();
                        currentUserAnswers = users.map(function (user, i) {
                            if (user === address)
                                return answers[i];
                        });
                        votedForCorrectQuestion = currentUserAnswers.some(function (answer) {
                            if (answer) {
                                return bignumber_1.BigNumber.from(answer).eq(bestAnswer);
                            }
                        }) && isFinalized;
                        hasBalance = !userBalance.eq(0) && isFinalized;
                        // Remove the first history and add an empty one
                        // More info: https://github.com/realitio/realitio-contracts/blob/master/truffle/contracts/Realitio.sol#L502
                        historyHashes.shift();
                        firstHash = '0x0000000000000000000000000000000000000000000000000000000000000000';
                        historyHashes.push(firstHash);
                        return [2 /*return*/, {
                                tokenSymbol: tokenSymbol,
                                tokenDecimals: tokenDecimals,
                                canClaim: (!alreadyClaimed && votedForCorrectQuestion) || hasBalance,
                                data: {
                                    length: [bonds.length.toString()],
                                    historyHashes: historyHashes,
                                    users: users,
                                    bonds: bonds,
                                    answers: answers
                                }
                            }];
                }
            });
        });
    };
    Plugin.prototype.claimBond = function (web3, oracleAddress, questionId, claimParams) {
        return __awaiter(this, void 0, void 0, function () {
            var currentHistoryHash, tx_1, receipt_1, tx, receipt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, utils_1.call(web3, OracleAbi, [
                            oracleAddress,
                            'getHistoryHash',
                            [questionId]
                        ])];
                    case 1:
                        currentHistoryHash = _a.sent();
                        if (!bignumber_1.BigNumber.from(currentHistoryHash).eq(0)) return [3 /*break*/, 4];
                        return [4 /*yield*/, utils_1.sendTransaction(web3, oracleAddress, OracleAbi, 'withdraw', [])];
                    case 2:
                        tx_1 = _a.sent();
                        return [4 /*yield*/, tx_1.wait()];
                    case 3:
                        receipt_1 = _a.sent();
                        console.log('[Realitio] executed withdraw:', receipt_1);
                        return [2 /*return*/];
                    case 4: return [4 /*yield*/, utils_1.sendTransaction(web3, oracleAddress, OracleAbi, 'claimMultipleAndWithdrawBalance', __spreadArrays([[questionId]], claimParams))];
                    case 5:
                        tx = _a.sent();
                        return [4 /*yield*/, tx.wait()];
                    case 6:
                        receipt = _a.sent();
                        console.log('[Realitio] executed claimMultipleAndWithdrawBalance:', receipt);
                        return [2 /*return*/];
                }
            });
        });
    };
    Plugin.prototype.executeProposal = function (web3, moduleAddress, proposalId, transactions, transactionIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var txHashes, moduleTx, tx, receipt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.calcTransactionHashes(web3.network.chainId, moduleAddress, transactions)];
                    case 1:
                        txHashes = _a.sent();
                        moduleTx = transactions[transactionIndex];
                        return [4 /*yield*/, utils_1.sendTransaction(web3, moduleAddress, ModuleAbi, 'executeProposalWithIndex', [
                                proposalId,
                                txHashes,
                                moduleTx.to,
                                moduleTx.value,
                                moduleTx.data || '0x',
                                moduleTx.operation,
                                transactionIndex
                            ])];
                    case 2:
                        tx = _a.sent();
                        return [4 /*yield*/, tx.wait()];
                    case 3:
                        receipt = _a.sent();
                        console.log('[DAO module] executed proposal:', receipt);
                        return [2 /*return*/];
                }
            });
        });
    };
    Plugin.prototype.voteForQuestion = function (network, web3, oracleAddress, questionId, minimumBondInDaoModule, answer) {
        return __awaiter(this, void 0, void 0, function () {
            var currentBond, bond, methodName, txOverrides, parameters, currentBondIsZero, daoBondIsZero, token, _a, tokenDecimals, allowance, approveTx, e_3, tx, receipt;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, utils_1.call(web3, OracleAbi, [
                            oracleAddress,
                            'getBond',
                            [questionId]
                        ])];
                    case 1:
                        currentBond = _b.sent();
                        txOverrides = {};
                        parameters = [
                            questionId,
                            "0x000000000000000000000000000000000000000000000000000000000000000" + answer
                        ];
                        currentBondIsZero = currentBond.eq(bignumber_1.BigNumber.from(0));
                        if (currentBondIsZero) {
                            daoBondIsZero = bignumber_1.BigNumber.from(minimumBondInDaoModule).eq(0);
                            bond = daoBondIsZero ? bignumber_1.BigNumber.from(10) : minimumBondInDaoModule;
                        }
                        else {
                            bond = currentBond.mul(2);
                        }
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 8, , 9]);
                        return [4 /*yield*/, utils_1.call(web3, OracleAbi, [oracleAddress, 'token', []])];
                    case 3:
                        token = _b.sent();
                        return [4 /*yield*/, utils_1.multicall(network, web3, TokenAbi, [
                                [token, 'decimals', []],
                                [token, 'allowance', [web3.provider.selectedAddress, oracleAddress]]
                            ])];
                    case 4:
                        _a = _b.sent(), tokenDecimals = _a[0][0], allowance = _a[1][0];
                        if (bond.eq(10)) {
                            bond = bond.pow(tokenDecimals);
                        }
                        if (!allowance.lt(bond)) return [3 /*break*/, 7];
                        return [4 /*yield*/, utils_1.sendTransaction(web3, token, TokenAbi, 'approve', [oracleAddress, bond], {})];
                    case 5:
                        approveTx = _b.sent();
                        return [4 /*yield*/, approveTx.wait()];
                    case 6:
                        _b.sent();
                        _b.label = 7;
                    case 7:
                        parameters = __spreadArrays(parameters, [bond, bond]);
                        methodName = 'submitAnswerERC20';
                        return [3 /*break*/, 9];
                    case 8:
                        e_3 = _b.sent();
                        if (bond.eq(10)) {
                            bond = bond.pow(18);
                        }
                        parameters = __spreadArrays(parameters, [bond]);
                        txOverrides['value'] = bond.toString();
                        methodName = 'submitAnswer';
                        return [3 /*break*/, 9];
                    case 9: return [4 /*yield*/, utils_1.sendTransaction(web3, oracleAddress, OracleAbi, methodName, parameters, txOverrides)];
                    case 10:
                        tx = _b.sent();
                        return [4 /*yield*/, tx.wait()];
                    case 11:
                        receipt = _b.sent();
                        console.log('[DAO module] executed vote on oracle:', receipt);
                        return [2 /*return*/];
                }
            });
        });
    };
    return Plugin;
}());
exports["default"] = Plugin;

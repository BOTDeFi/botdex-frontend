{"ast":null,"code":"/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Join} Join\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @returns {string}\n */\nexport function containerFlow(parent, context) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  /** @type {Array.<string>} */\n\n  const results = [];\n  let index = -1;\n  indexStack.push(-1);\n\n  while (++index < children.length) {\n    const child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(context.handle(child, parent, context, {\n      before: '\\n',\n      after: '\\n'\n    }));\n\n    if (child.type !== 'list') {\n      context.bulletLastUsed = undefined;\n    }\n\n    if (index < children.length - 1) {\n      results.push(between(child, children[index + 1]));\n    }\n  }\n\n  indexStack.pop();\n  return results.join('');\n  /**\n   * @param {Node} left\n   * @param {Node} right\n   * @returns {string}\n   */\n\n  function between(left, right) {\n    let index = context.join.length;\n\n    while (index--) {\n      const result = context.join[index](left, right, parent, context);\n\n      if (result === true || result === 1) {\n        break;\n      }\n\n      if (typeof result === 'number') {\n        return '\\n'.repeat(1 + result);\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n';\n      }\n    }\n\n    return '\\n\\n';\n  }\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/mdast-util-to-markdown/lib/util/container-flow.js"],"names":["containerFlow","parent","context","indexStack","children","results","index","push","length","child","handle","before","after","type","bulletLastUsed","undefined","between","pop","join","left","right","result","repeat"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,aAAT,CAAuBC,MAAvB,EAA+BC,OAA/B,EAAwC;AAC7C,QAAMC,UAAU,GAAGD,OAAO,CAACC,UAA3B;AACA,QAAMC,QAAQ,GAAGH,MAAM,CAACG,QAAP,IAAmB,EAApC;AACA;;AACA,QAAMC,OAAO,GAAG,EAAhB;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;AAEAH,EAAAA,UAAU,CAACI,IAAX,CAAgB,CAAC,CAAjB;;AAEA,SAAO,EAAED,KAAF,GAAUF,QAAQ,CAACI,MAA1B,EAAkC;AAChC,UAAMC,KAAK,GAAGL,QAAQ,CAACE,KAAD,CAAtB;AAEAH,IAAAA,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,GAAoCF,KAApC;AAEAD,IAAAA,OAAO,CAACE,IAAR,CACEL,OAAO,CAACQ,MAAR,CAAeD,KAAf,EAAsBR,MAAtB,EAA8BC,OAA9B,EAAuC;AAACS,MAAAA,MAAM,EAAE,IAAT;AAAeC,MAAAA,KAAK,EAAE;AAAtB,KAAvC,CADF;;AAIA,QAAIH,KAAK,CAACI,IAAN,KAAe,MAAnB,EAA2B;AACzBX,MAAAA,OAAO,CAACY,cAAR,GAAyBC,SAAzB;AACD;;AAED,QAAIT,KAAK,GAAGF,QAAQ,CAACI,MAAT,GAAkB,CAA9B,EAAiC;AAC/BH,MAAAA,OAAO,CAACE,IAAR,CAAaS,OAAO,CAACP,KAAD,EAAQL,QAAQ,CAACE,KAAK,GAAG,CAAT,CAAhB,CAApB;AACD;AACF;;AAEDH,EAAAA,UAAU,CAACc,GAAX;AAEA,SAAOZ,OAAO,CAACa,IAAR,CAAa,EAAb,CAAP;AAEA;AACF;AACA;AACA;AACA;;AACE,WAASF,OAAT,CAAiBG,IAAjB,EAAuBC,KAAvB,EAA8B;AAC5B,QAAId,KAAK,GAAGJ,OAAO,CAACgB,IAAR,CAAaV,MAAzB;;AAEA,WAAOF,KAAK,EAAZ,EAAgB;AACd,YAAMe,MAAM,GAAGnB,OAAO,CAACgB,IAAR,CAAaZ,KAAb,EAAoBa,IAApB,EAA0BC,KAA1B,EAAiCnB,MAAjC,EAAyCC,OAAzC,CAAf;;AAEA,UAAImB,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,CAAlC,EAAqC;AACnC;AACD;;AAED,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,eAAO,KAAKC,MAAL,CAAY,IAAID,MAAhB,CAAP;AACD;;AAED,UAAIA,MAAM,KAAK,KAAf,EAAsB;AACpB,eAAO,iBAAP;AACD;AACF;;AAED,WAAO,MAAP;AACD;AACF","sourcesContent":["/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Join} Join\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @returns {string}\n */\nexport function containerFlow(parent, context) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  /** @type {Array.<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      context.handle(child, parent, context, {before: '\\n', after: '\\n'})\n    )\n\n    if (child.type !== 'list') {\n      context.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(between(child, children[index + 1]))\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n\n  /**\n   * @param {Node} left\n   * @param {Node} right\n   * @returns {string}\n   */\n  function between(left, right) {\n    let index = context.join.length\n\n    while (index--) {\n      const result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return '\\n'.repeat(1 + result)\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
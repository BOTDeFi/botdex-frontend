{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useEffect, useState } from 'react';\nimport EthDater from 'ethereum-block-by-date';\nimport { fetchUserBalancesByBlock, selectTotalUserBalancesByBlock } from '@/services/api/refinery-finance-pairs';\nimport { useGetProposalVotes } from '@/services/api/snapshot.org/hooks';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport { clogError } from '@/utils/logger';\n\nconst selectVotersAddresses = data => {\n  return data.votes.map(item => item.voter);\n};\n\nexport const useProposalVotes = proposalId => {\n  _s();\n\n  const {\n    getProposalVotes,\n    options: [, {\n      loading: proposalVotesLoading,\n      data: proposalVotesData\n    }]\n  } = useGetProposalVotes({\n    fetchPolicy: 'network-only'\n  });\n  const updateProposalVotes = useCallback(() => {\n    if (proposalId) {\n      getProposalVotes(proposalId);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [proposalId, getProposalVotes]);\n  useEffect(() => {\n    updateProposalVotes();\n  }, [updateProposalVotes]);\n  const [votes, setVotes] = useState([]);\n  const [votingPowersLoading, setVotingPowersLoading] = useState(false);\n  useEffect(() => {\n    let isMounted = true; // is just to prevent error executing requests\n    // and setting new state on unloaded component\n\n    if (!proposalVotesLoading && proposalVotesData) {\n      setVotingPowersLoading(true);\n      const mapAddressToVoteData = proposalVotesData.votes.reduce((acc, currentItem) => {\n        const voter = currentItem.voter.toLowerCase();\n        acc[voter] = { ...currentItem,\n          voter\n        };\n        return acc;\n      }, {});\n      const addresses = selectVotersAddresses(proposalVotesData);\n\n      const doAsyncWork = async () => {\n        const ethBlockByDate = new EthDater(metamaskService.web3Provider.eth);\n        const blocksWhereWereVotesRaw = await Promise.allSettled(proposalVotesData.votes.map(({\n          created\n        }) => {\n          return ethBlockByDate.getDate(created * 1e3);\n        }));\n        const blockWhereWereVotes = blocksWhereWereVotesRaw.map(item => {\n          switch (item.status) {\n            case 'rejected':\n              {\n                clogError('useProposalVotes | Get Block By Date Retrieval', item.reason);\n                return null;\n              }\n\n            case 'fulfilled':\n            default:\n              {\n                return item.value.block;\n              }\n          }\n        });\n        const usersBalancesRaw = await fetchUserBalancesByBlock(addresses, blockWhereWereVotes);\n        const totalUserBalancesByBlock = selectTotalUserBalancesByBlock(usersBalancesRaw);\n\n        if (isMounted) {\n          setVotes(totalUserBalancesByBlock.map(item => {\n            const voteData = mapAddressToVoteData[item.id];\n            return { ...voteData,\n              votingPower: item.TotalBalance\n            };\n          }));\n        }\n      };\n\n      doAsyncWork().finally(() => {\n        if (isMounted) {\n          setVotingPowersLoading(false);\n        }\n      });\n    }\n\n    return () => {\n      isMounted = false;\n    };\n  }, [proposalVotesData, proposalVotesLoading]);\n  return {\n    votes,\n    proposalVotesLoading,\n    votingPowersLoading,\n    updateProposalVotes\n  };\n};\n\n_s(useProposalVotes, \"QFqfl41XM0qCOgYPdEFqwLBTUaI=\", false, function () {\n  return [useGetProposalVotes];\n});","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/hooks/dao/useProposalVotes.ts"],"names":["useCallback","useEffect","useState","EthDater","fetchUserBalancesByBlock","selectTotalUserBalancesByBlock","useGetProposalVotes","metamaskService","clogError","selectVotersAddresses","data","votes","map","item","voter","useProposalVotes","proposalId","getProposalVotes","options","loading","proposalVotesLoading","proposalVotesData","fetchPolicy","updateProposalVotes","setVotes","votingPowersLoading","setVotingPowersLoading","isMounted","mapAddressToVoteData","reduce","acc","currentItem","toLowerCase","addresses","doAsyncWork","ethBlockByDate","web3Provider","eth","blocksWhereWereVotesRaw","Promise","allSettled","created","getDate","blockWhereWereVotes","status","reason","value","block","usersBalancesRaw","totalUserBalancesByBlock","voteData","id","votingPower","TotalBalance","finally"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport EthDater from 'ethereum-block-by-date';\n\nimport {\n  fetchUserBalancesByBlock,\n  selectTotalUserBalancesByBlock,\n} from '@/services/api/refinery-finance-pairs';\nimport {\n  IGetProposalVotesResponse,\n  IProposalVote,\n  IProposalVoteWithVotingPower,\n  useGetProposalVotes,\n} from '@/services/api/snapshot.org/hooks';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport { clogError } from '@/utils/logger';\n\nconst selectVotersAddresses = (data: IGetProposalVotesResponse) => {\n  return data.votes.map((item) => item.voter);\n};\n\nexport const useProposalVotes = (\n  proposalId?: string,\n): {\n  votes: IProposalVoteWithVotingPower[];\n  proposalVotesLoading: boolean;\n  votingPowersLoading: boolean;\n  updateProposalVotes: () => void;\n} => {\n  const {\n    getProposalVotes,\n    options: [, { loading: proposalVotesLoading, data: proposalVotesData }],\n  } = useGetProposalVotes({\n    fetchPolicy: 'network-only',\n  });\n\n  const updateProposalVotes = useCallback(() => {\n    if (proposalId) {\n      getProposalVotes(proposalId);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [proposalId, getProposalVotes]);\n\n  useEffect(() => {\n    updateProposalVotes();\n  }, [updateProposalVotes]);\n\n  const [votes, setVotes] = useState<IProposalVoteWithVotingPower[]>([]);\n  const [votingPowersLoading, setVotingPowersLoading] = useState(false);\n\n  useEffect(() => {\n    let isMounted = true; // is just to prevent error executing requests\n    // and setting new state on unloaded component\n    if (!proposalVotesLoading && proposalVotesData) {\n      setVotingPowersLoading(true);\n      const mapAddressToVoteData = proposalVotesData.votes.reduce(\n        (acc: Record<string, IProposalVote>, currentItem) => {\n          const voter = currentItem.voter.toLowerCase();\n          acc[voter] = {\n            ...currentItem,\n            voter,\n          };\n          return acc;\n        },\n        {},\n      );\n      const addresses = selectVotersAddresses(proposalVotesData);\n\n      const doAsyncWork = async () => {\n        const ethBlockByDate = new EthDater(metamaskService.web3Provider.eth);\n        const blocksWhereWereVotesRaw = await Promise.allSettled(\n          proposalVotesData.votes.map(({ created }) => {\n            return ethBlockByDate.getDate(created * 1e3);\n          }),\n        );\n        const blockWhereWereVotes = blocksWhereWereVotesRaw.map((item) => {\n          switch (item.status) {\n            case 'rejected': {\n              clogError('useProposalVotes | Get Block By Date Retrieval', item.reason);\n              return null;\n            }\n            case 'fulfilled':\n            default: {\n              return item.value.block;\n            }\n          }\n        });\n        const usersBalancesRaw = await fetchUserBalancesByBlock(addresses, blockWhereWereVotes);\n        const totalUserBalancesByBlock = selectTotalUserBalancesByBlock(usersBalancesRaw);\n\n        if (isMounted) {\n          setVotes(\n            totalUserBalancesByBlock.map((item) => {\n              const voteData = mapAddressToVoteData[item.id];\n              return {\n                ...voteData,\n                votingPower: item.TotalBalance,\n              };\n            }),\n          );\n        }\n      };\n\n      doAsyncWork().finally(() => {\n        if (isMounted) {\n          setVotingPowersLoading(false);\n        }\n      });\n    }\n\n    return () => {\n      isMounted = false;\n    };\n  }, [proposalVotesData, proposalVotesLoading]);\n\n  return { votes, proposalVotesLoading, votingPowersLoading, updateProposalVotes };\n};\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n */\n\n/**\n * An opening or closing tag, followed by a case-insensitive specific tag name,\n * followed by HTML whitespace, a greater than, or a slash.\n */\nconst reFlow = /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi;\n/**\n * As HTML (text) parses tags separately (and v. strictly), we don’t need to be\n * global.\n */\n\nconst reText = new RegExp('^' + reFlow.source, 'i');\n/** @type {HtmlExtension} */\n\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow);\n    },\n\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText);\n    }\n\n  }\n};\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\n\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token);\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2');\n  }\n\n  this.raw(this.encode(value));\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-extension-gfm-tagfilter/index.js"],"names":["reFlow","reText","RegExp","source","gfmTagfilterHtml","exit","htmlFlowData","token","exitHtmlData","call","htmlTextData","filter","value","sliceSerialize","options","allowDangerousHtml","replace","raw","encode"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMA,MAAM,GACV,8FADF;AAGA;AACA;AACA;AACA;;AACA,MAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAW,MAAMF,MAAM,CAACG,MAAxB,EAAgC,GAAhC,CAAf;AAEA;;AACA,OAAO,MAAMC,gBAAgB,GAAG;AAC9BC,EAAAA,IAAI,EAAE;AACJC,IAAAA,YAAY,CAACC,KAAD,EAAQ;AAClBC,MAAAA,YAAY,CAACC,IAAb,CAAkB,IAAlB,EAAwBF,KAAxB,EAA+BP,MAA/B;AACD,KAHG;;AAIJU,IAAAA,YAAY,CAACH,KAAD,EAAQ;AAClBC,MAAAA,YAAY,CAACC,IAAb,CAAkB,IAAlB,EAAwBF,KAAxB,EAA+BN,MAA/B;AACD;;AANG;AADwB,CAAzB;AAWP;AACA;AACA;AACA;AACA;;AACA,SAASO,YAAT,CAAsBD,KAAtB,EAA6BI,MAA7B,EAAqC;AACnC,MAAIC,KAAK,GAAG,KAAKC,cAAL,CAAoBN,KAApB,CAAZ;;AAEA,MAAI,KAAKO,OAAL,CAAaC,kBAAjB,EAAqC;AACnCH,IAAAA,KAAK,GAAGA,KAAK,CAACI,OAAN,CAAcL,MAAd,EAAsB,UAAtB,CAAR;AACD;;AAED,OAAKM,GAAL,CAAS,KAAKC,MAAL,CAAYN,KAAZ,CAAT;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n */\n\n/**\n * An opening or closing tag, followed by a case-insensitive specific tag name,\n * followed by HTML whitespace, a greater than, or a slash.\n */\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n/**\n * As HTML (text) parses tags separately (and v. strictly), we don’t need to be\n * global.\n */\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/** @type {HtmlExtension} */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow)\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText)\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n"]},"metadata":{},"sourceType":"module"}
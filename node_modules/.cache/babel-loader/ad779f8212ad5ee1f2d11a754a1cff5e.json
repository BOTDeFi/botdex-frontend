{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace, markdownLineEndingOrSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n};\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n  /** @type {State} */\n\n  function open(code) {\n    if ( // Exit if there’s stuff before.\n    self.previous !== null || // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if (markdownSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, after, 'whitespace');\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'whitespace' && code !== null && !markdownLineEndingOrSpace(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"names":["factorySpace","markdownSpace","markdownLineEndingOrSpace","tasklistCheck","tokenize","tokenizeTasklistCheck","gfmTaskListItem","text","effects","ok","nok","self","open","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","close","check","spaceThenNonSpace","after","tail","events","length","type"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownSpace,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n  /** @type {State} */\n\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (markdownSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this\n  return factorySpace(effects, after, 'whitespace')\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'whitespace' &&\n      code !== null &&\n      !markdownLineEndingOrSpace(code)\n      ? ok(code)\n      : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
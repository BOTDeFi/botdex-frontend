{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|null} Align\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n/** @type {Extension} */\n\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst setextUnderlineMini = {\n  tokenize: tokenizeSetextUnderlineMini,\n  partial: true\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {Token} */\n\n  let token;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {Token} */\n\n  let cell;\n  /** @type {Token} */\n\n  let content;\n  /** @type {Token} */\n\n  let text;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        content = {\n          type: 'tableContent',\n          // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        };\n        events.splice( // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n        contentStart, // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n        contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]); // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart && cellStart + 1 < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Align[]} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, atDelimiterLineStart, nok)(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterLineStart(code) {\n    // To do: is the lazy setext thing still needed?\n    return effects.check(setextUnderlineMini, nok, // Support an indent before the delimiter row.\n    factorySpace(effects, rowStartDelimiter, 'linePrefix', 4))(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n\n    effects.enter('tableDelimiterRow');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push(null);\n      return inFillerDelimiter;\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n} // Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\n\n/** @type {Tokenizer} */\n\n\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 45) {\n      return nok(code);\n    }\n\n    effects.enter('setextUnderline');\n    return sequence(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    return whitespace(code);\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return whitespace;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","setextUnderlineMini","tokenizeSetextUnderlineMini","partial","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","events","context","index","token","inHead","inDelimiterRow","inRow","cell","content","text","contentStart","contentEnd","cellStart","length","type","start","end","contentType","splice","undefined","effects","ok","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","attempt","tokenizeRowEnd","atDelimiterLineStart","check","rowStartDelimiter","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","lineStart","parser","lazy","now","line","sequence","whitespace","size"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|null} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst setextUnderlineMini = {\n  tokenize: tokenizeSetextUnderlineMini,\n  partial: true\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {Token} */\n\n  let cell\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n          contentStart, // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        ) // @ts-expect-error `contentStart` is defined if `contentEnd` is too.\n\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Align[]} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      atDelimiterLineStart,\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterLineStart(code) {\n    // To do: is the lazy setext thing still needed?\n    return effects.check(\n      setextUnderlineMini,\n      nok, // Support an indent before the delimiter row.\n      factorySpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )(code)\n  }\n  /** @type {State} */\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n} // Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\n\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
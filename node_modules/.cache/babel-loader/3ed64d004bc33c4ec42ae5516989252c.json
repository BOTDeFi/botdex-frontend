{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { Observable } from '../Observable';\nimport { innerFrom } from './from';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\nexport function zip() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var resultSelector = popResultSelector(args);\n  var sources = argsOrArgArray(args);\n  return sources.length ? new Observable(function (subscriber) {\n    var buffers = sources.map(function () {\n      return [];\n    });\n    var completed = sources.map(function () {\n      return false;\n    });\n    subscriber.add(function () {\n      buffers = completed = null;\n    });\n\n    var _loop_1 = function (sourceIndex) {\n      innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {\n        buffers[sourceIndex].push(value);\n\n        if (buffers.every(function (buffer) {\n          return buffer.length;\n        })) {\n          var result = buffers.map(function (buffer) {\n            return buffer.shift();\n          });\n          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);\n\n          if (buffers.some(function (buffer, i) {\n            return !buffer.length && completed[i];\n          })) {\n            subscriber.complete();\n          }\n        }\n      }, function () {\n        completed[sourceIndex] = true;\n        !buffers[sourceIndex].length && subscriber.complete();\n      }));\n    };\n\n    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n      _loop_1(sourceIndex);\n    }\n\n    return function () {\n      buffers = completed = null;\n    };\n  }) : EMPTY;\n}","map":{"version":3,"sources":["../../../../src/internal/observable/zip.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,QAA2B,eAA3B;AAEA,SAAS,SAAT,QAA0B,QAA1B;AACA,SAAS,cAAT,QAA+B,wBAA/B;AACA,SAAS,KAAT,QAAsB,SAAtB;AACA,SAAS,kBAAT,QAAmC,iCAAnC;AACA,SAAS,iBAAT,QAAkC,cAAlC;AA4CA,OAAM,SAAU,GAAV,GAAa;AAAC,MAAA,IAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkB;AAAlB,IAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAClB,MAAM,cAAc,GAAG,iBAAiB,CAAC,IAAD,CAAxC;AAEA,MAAM,OAAO,GAAG,cAAc,CAAC,IAAD,CAA9B;AAEA,SAAO,OAAO,CAAC,MAAR,GACH,IAAI,UAAJ,CAA0B,UAAC,UAAD,EAAW;AAGnC,QAAI,OAAO,GAAgB,OAAO,CAAC,GAAR,CAAY,YAAA;AAAM,aAAA,EAAA;AAAE,KAApB,CAA3B;AAKA,QAAI,SAAS,GAAG,OAAO,CAAC,GAAR,CAAY,YAAA;AAAM,aAAA,KAAA;AAAK,KAAvB,CAAhB;AAGA,IAAA,UAAU,CAAC,GAAX,CAAe,YAAA;AACb,MAAA,OAAO,GAAG,SAAS,GAAG,IAAtB;AACD,KAFD;;4BAOS,W,EAAW;AAClB,MAAA,SAAS,CAAC,OAAO,CAAC,WAAD,CAAR,CAAT,CAAgC,SAAhC,CACE,IAAI,kBAAJ,CACE,UADF,EAEE,UAAC,KAAD,EAAM;AACJ,QAAA,OAAO,CAAC,WAAD,CAAP,CAAqB,IAArB,CAA0B,KAA1B;;AAIA,YAAI,OAAO,CAAC,KAAR,CAAc,UAAC,MAAD,EAAO;AAAK,iBAAA,MAAM,CAAN,MAAA;AAAa,SAAvC,CAAJ,EAA8C;AAC5C,cAAM,MAAM,GAAQ,OAAO,CAAC,GAAR,CAAY,UAAC,MAAD,EAAO;AAAK,mBAAA,MAAM,CAAN,KAAA,EAAA;AAAe,WAAvC,CAApB;AAEA,UAAA,UAAU,CAAC,IAAX,CAAgB,cAAc,GAAG,cAAc,CAAA,KAAd,CAAc,KAAA,CAAd,EAAc,aAAA,CAAA,EAAA,EAAA,MAAA,CAAI,MAAJ,CAAA,CAAd,CAAH,GAA+B,MAA7D;;AAIA,cAAI,OAAO,CAAC,IAAR,CAAa,UAAC,MAAD,EAAS,CAAT,EAAU;AAAK,mBAAA,CAAC,MAAM,CAAC,MAAR,IAAkB,SAAS,CAA3B,CAA2B,CAA3B;AAA8B,WAA1D,CAAJ,EAAiE;AAC/D,YAAA,UAAU,CAAC,QAAX;AACD;AACF;AACF,OAlBH,EAmBE,YAAA;AAGE,QAAA,SAAS,CAAC,WAAD,CAAT,GAAyB,IAAzB;AAIA,SAAC,OAAO,CAAC,WAAD,CAAP,CAAqB,MAAtB,IAAgC,UAAU,CAAC,QAAX,EAAhC;AACD,OA3BH,CADF;;;AADF,SAAK,IAAI,WAAW,GAAG,CAAvB,EAA0B,CAAC,UAAU,CAAC,MAAZ,IAAsB,WAAW,GAAG,OAAO,CAAC,MAAtE,EAA8E,WAAW,EAAzF,EAA2F;cAAlF,W;AAgCR;;AAGD,WAAO,YAAA;AACL,MAAA,OAAO,GAAG,SAAS,GAAG,IAAtB;AACD,KAFD;AAGD,GAxDD,CADG,GA0DH,KA1DJ;AA2DD","sourceRoot":"","sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nimport { Observable } from '../Observable';\nimport { innerFrom } from './from';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\nexport function zip() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var resultSelector = popResultSelector(args);\n    var sources = argsOrArgArray(args);\n    return sources.length\n        ? new Observable(function (subscriber) {\n            var buffers = sources.map(function () { return []; });\n            var completed = sources.map(function () { return false; });\n            subscriber.add(function () {\n                buffers = completed = null;\n            });\n            var _loop_1 = function (sourceIndex) {\n                innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {\n                    buffers[sourceIndex].push(value);\n                    if (buffers.every(function (buffer) { return buffer.length; })) {\n                        var result = buffers.map(function (buffer) { return buffer.shift(); });\n                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);\n                        if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {\n                            subscriber.complete();\n                        }\n                    }\n                }, function () {\n                    completed[sourceIndex] = true;\n                    !buffers[sourceIndex].length && subscriber.complete();\n                }));\n            };\n            for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n                _loop_1(sourceIndex);\n            }\n            return function () {\n                buffers = completed = null;\n            };\n        })\n        : EMPTY;\n}\n//# sourceMappingURL=zip.js.map"]},"metadata":{},"sourceType":"module"}
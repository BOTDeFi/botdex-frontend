{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  null: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n};\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      this.lineEndingIfNeeded();\n      this.tag('<table>'); // @ts-expect-error Custom.\n\n      this.setData('tableAlign', token._align);\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding');\n      this.tag('<tbody>');\n    },\n\n    tableData() {\n      /** @type {string|undefined} */\n      const align = // @ts-expect-error Custom.\n      alignment[this.getData('tableAlign')[this.getData('tableColumn')]];\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer();\n      } else {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + align + '>');\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('<thead>');\n    },\n\n    tableHeader() {\n      this.lineEndingIfNeeded();\n      this.tag('<th' + // @ts-expect-error Custom.\n      alignment[this.getData('tableAlign')[this.getData('tableColumn')]] + '>');\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0);\n      this.lineEndingIfNeeded();\n      this.tag('<tr>');\n    }\n\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token);\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n      }\n\n      this.raw(this.encode(value));\n    },\n\n    table() {\n      this.setData('tableAlign'); // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings');\n      this.lineEndingIfNeeded();\n      this.tag('</table>');\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded();\n      this.tag('</tbody>');\n    },\n\n    tableData() {\n      /** @type {number} */\n      // @ts-expect-error Custom.\n      const column = this.getData('tableColumn'); // @ts-expect-error Custom.\n\n      if (column in this.getData('tableAlign')) {\n        this.tag('</td>');\n        this.setData('tableColumn', column + 1);\n      } else {\n        // Stop capturing.\n        this.resume();\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('</thead>');\n      this.setData('slurpOneLineEnding', true); // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      this.tag('</th>'); // @ts-expect-error Custom.\n\n      this.setData('tableColumn', this.getData('tableColumn') + 1);\n    },\n\n    tableRow() {\n      /** @type {Align[]} */\n      // @ts-expect-error Custom.\n      const align = this.getData('tableAlign');\n      /** @type {number} */\n      // @ts-expect-error Custom.\n\n      let column = this.getData('tableColumn');\n\n      while (column < align.length) {\n        this.lineEndingIfNeeded(); // @ts-expect-error `null` is fine as an index.\n\n        this.tag('<td' + alignment[align[column]] + '></td>');\n        column++;\n      }\n\n      this.setData('tableColumn', column);\n      this.lineEndingIfNeeded();\n      this.tag('</tr>');\n    }\n\n  }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-extension-gfm-table/lib/html.js"],"names":["alignment","null","left","right","center","gfmTableHtml","enter","table","token","lineEndingIfNeeded","tag","setData","_align","tableBody","tableData","align","getData","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","column","resume","length","$0","$1"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMA,SAAS,GAAG;AAChBC,EAAAA,IAAI,EAAE,EADU;AAEhBC,EAAAA,IAAI,EAAE,eAFU;AAGhBC,EAAAA,KAAK,EAAE,gBAHS;AAIhBC,EAAAA,MAAM,EAAE;AAJQ,CAAlB;AAMA;;AAEA,OAAO,MAAMC,YAAY,GAAG;AAC1BC,EAAAA,KAAK,EAAE;AACLC,IAAAA,KAAK,CAACC,KAAD,EAAQ;AACX,WAAKC,kBAAL;AACA,WAAKC,GAAL,CAAS,SAAT,EAFW,CAES;;AAEpB,WAAKC,OAAL,CAAa,YAAb,EAA2BH,KAAK,CAACI,MAAjC;AACD,KANI;;AAQLC,IAAAA,SAAS,GAAG;AACV;AACA,WAAKF,OAAL,CAAa,oBAAb;AACA,WAAKD,GAAL,CAAS,SAAT;AACD,KAZI;;AAcLI,IAAAA,SAAS,GAAG;AACV;AACA,YAAMC,KAAK,GAAG;AACZf,MAAAA,SAAS,CAAC,KAAKgB,OAAL,CAAa,YAAb,EAA2B,KAAKA,OAAL,CAAa,aAAb,CAA3B,CAAD,CADX;;AAGA,UAAID,KAAK,KAAKE,SAAd,EAAyB;AACvB;AACA,aAAKC,MAAL;AACD,OAHD,MAGO;AACL,aAAKT,kBAAL;AACA,aAAKC,GAAL,CAAS,QAAQK,KAAR,GAAgB,GAAzB;AACD;AACF,KA1BI;;AA4BLI,IAAAA,SAAS,GAAG;AACV,WAAKV,kBAAL;AACA,WAAKC,GAAL,CAAS,SAAT;AACD,KA/BI;;AAiCLU,IAAAA,WAAW,GAAG;AACZ,WAAKX,kBAAL;AACA,WAAKC,GAAL,CACE,QAAQ;AACNV,MAAAA,SAAS,CAAC,KAAKgB,OAAL,CAAa,YAAb,EAA2B,KAAKA,OAAL,CAAa,aAAb,CAA3B,CAAD,CADX,GAEE,GAHJ;AAKD,KAxCI;;AA0CLK,IAAAA,QAAQ,GAAG;AACT,WAAKV,OAAL,CAAa,aAAb,EAA4B,CAA5B;AACA,WAAKF,kBAAL;AACA,WAAKC,GAAL,CAAS,MAAT;AACD;;AA9CI,GADmB;AAiD1BY,EAAAA,IAAI,EAAE;AACJ;AACA;AACAC,IAAAA,YAAY,CAACf,KAAD,EAAQ;AAClB,UAAIgB,KAAK,GAAG,KAAKC,cAAL,CAAoBjB,KAApB,CAAZ;;AAEA,UAAI,KAAKQ,OAAL,CAAa,YAAb,CAAJ,EAAgC;AAC9BQ,QAAAA,KAAK,GAAGA,KAAK,CAACE,OAAN,CAAc,YAAd,EAA4BA,OAA5B,CAAR;AACD;;AAED,WAAKC,GAAL,CAAS,KAAKC,MAAL,CAAYJ,KAAZ,CAAT;AACD,KAXG;;AAaJjB,IAAAA,KAAK,GAAG;AACN,WAAKI,OAAL,CAAa,YAAb,EADM,CACqB;AAC3B;;AAEA,WAAKA,OAAL,CAAa,qBAAb;AACA,WAAKF,kBAAL;AACA,WAAKC,GAAL,CAAS,UAAT;AACD,KApBG;;AAsBJG,IAAAA,SAAS,GAAG;AACV,WAAKJ,kBAAL;AACA,WAAKC,GAAL,CAAS,UAAT;AACD,KAzBG;;AA2BJI,IAAAA,SAAS,GAAG;AACV;AACA;AACA,YAAMe,MAAM,GAAG,KAAKb,OAAL,CAAa,aAAb,CAAf,CAHU,CAGiC;;AAE3C,UAAIa,MAAM,IAAI,KAAKb,OAAL,CAAa,YAAb,CAAd,EAA0C;AACxC,aAAKN,GAAL,CAAS,OAAT;AACA,aAAKC,OAAL,CAAa,aAAb,EAA4BkB,MAAM,GAAG,CAArC;AACD,OAHD,MAGO;AACL;AACA,aAAKC,MAAL;AACD;AACF,KAvCG;;AAyCJX,IAAAA,SAAS,GAAG;AACV,WAAKV,kBAAL;AACA,WAAKC,GAAL,CAAS,UAAT;AACA,WAAKC,OAAL,CAAa,oBAAb,EAAmC,IAAnC,EAHU,CAG+B;AAC1C,KA7CG;;AA+CJS,IAAAA,WAAW,GAAG;AACZ,WAAKV,GAAL,CAAS,OAAT,EADY,CACM;;AAElB,WAAKC,OAAL,CAAa,aAAb,EAA4B,KAAKK,OAAL,CAAa,aAAb,IAA8B,CAA1D;AACD,KAnDG;;AAqDJK,IAAAA,QAAQ,GAAG;AACT;AACA;AACA,YAAMN,KAAK,GAAG,KAAKC,OAAL,CAAa,YAAb,CAAd;AACA;AACA;;AAEA,UAAIa,MAAM,GAAG,KAAKb,OAAL,CAAa,aAAb,CAAb;;AAEA,aAAOa,MAAM,GAAGd,KAAK,CAACgB,MAAtB,EAA8B;AAC5B,aAAKtB,kBAAL,GAD4B,CACF;;AAE1B,aAAKC,GAAL,CAAS,QAAQV,SAAS,CAACe,KAAK,CAACc,MAAD,CAAN,CAAjB,GAAmC,QAA5C;AACAA,QAAAA,MAAM;AACP;;AAED,WAAKlB,OAAL,CAAa,aAAb,EAA4BkB,MAA5B;AACA,WAAKpB,kBAAL;AACA,WAAKC,GAAL,CAAS,OAAT;AACD;;AAxEG;AAjDoB,CAArB;AA4HP;AACA;AACA;AACA;AACA;;AAEA,SAASgB,OAAT,CAAiBM,EAAjB,EAAqBC,EAArB,EAAyB;AACvB;AACA,SAAOA,EAAE,KAAK,GAAP,GAAaA,EAAb,GAAkBD,EAAzB;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  null: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      this.lineEndingIfNeeded()\n      this.tag('<table>') // @ts-expect-error Custom.\n\n      this.setData('tableAlign', token._align)\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding')\n      this.tag('<tbody>')\n    },\n\n    tableData() {\n      /** @type {string|undefined} */\n      const align = // @ts-expect-error Custom.\n        alignment[this.getData('tableAlign')[this.getData('tableColumn')]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n\n    tableHeader() {\n      this.lineEndingIfNeeded()\n      this.tag(\n        '<th' + // @ts-expect-error Custom.\n          alignment[this.getData('tableAlign')[this.getData('tableColumn')]] +\n          '>'\n      )\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n\n    table() {\n      this.setData('tableAlign') // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n\n    tableData() {\n      /** @type {number} */\n      // @ts-expect-error Custom.\n      const column = this.getData('tableColumn') // @ts-expect-error Custom.\n\n      if (column in this.getData('tableAlign')) {\n        this.tag('</td>')\n        this.setData('tableColumn', column + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n      this.setData('slurpOneLineEnding', true) // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      this.tag('</th>') // @ts-expect-error Custom.\n\n      this.setData('tableColumn', this.getData('tableColumn') + 1)\n    },\n\n    tableRow() {\n      /** @type {Align[]} */\n      // @ts-expect-error Custom.\n      const align = this.getData('tableAlign')\n      /** @type {number} */\n      // @ts-expect-error Custom.\n\n      let column = this.getData('tableColumn')\n\n      while (column < align.length) {\n        this.lineEndingIfNeeded() // @ts-expect-error `null` is fine as an index.\n\n        this.tag('<td' + alignment[align[column]] + '></td>')\n        column++\n      }\n\n      this.setData('tableColumn', column)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"]},"metadata":{},"sourceType":"module"}
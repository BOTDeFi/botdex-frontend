{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber';\nimport { types } from 'mobx-state-tree';\nimport { pools as poolsConfig } from '@/config';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport { getAddress, getContract, getContractAddress, getContractData } from '@/services/web3/contractHelpers';\nimport { getTokenPricesFromFarms } from '@/store/farms';\nimport { fetchPoolsAllowance // fetch block limits (ends in)\n, fetchPoolsBlockLimits, fetchPoolsStakingLimits, fetchPoolsTotalStaking, fetchUserBalances, fetchUserPendingRewards, fetchUserStakeBalances } from '@/store/pools';\nimport { convertSharesToRefinery } from '@/store/pools/helpers';\nimport { toBigNumber } from '@/utils';\nimport { getPoolApr } from '@/utils/apr';\nimport { BIG_ZERO, DEFAULT_TOKEN_DECIMAL } from '@/utils/constants';\nimport { getBalanceAmount } from '@/utils/formatters';\nimport { clog, clogError } from '@/utils/logger';\nimport { multicall } from '@/utils/multicall';\nimport AddressModel from './Address';\nimport FeesModel from './Fees';\nimport TokenModel from './Token';\nconst UserDataModel = types.model({\n  allowance: types.string,\n  stakingTokenBalance: types.string,\n  stakedBalance: types.string,\n  pendingReward: types.string\n});\nconst PoolModel = types.model({\n  id: types.number,\n  earningToken: TokenModel,\n  stakingToken: TokenModel,\n  contractAddress: AddressModel,\n  tokenPerBlock: types.string,\n  isFinished: types.optional(types.boolean, false),\n  enableEmergencyWithdraw: types.optional(types.boolean, false),\n  totalStaked: types.optional(types.string, '0'),\n  stakingLimit: types.optional(types.string, '0'),\n  startBlock: types.optional(types.number, 0),\n  endBlock: types.optional(types.number, 0),\n  apr: types.optional(types.number, 0),\n  stakingTokenPrice: types.optional(types.number, 0),\n  earningTokenPrice: types.optional(types.number, 0),\n  isAutoVault: types.optional(types.boolean, false),\n  userData: types.optional(UserDataModel, {\n    allowance: '',\n    stakingTokenBalance: '',\n    stakedBalance: '',\n    pendingReward: ''\n  })\n});\nconst PoolsModel = types.model({\n  data: types.optional(types.array(PoolModel), poolsConfig),\n  totalShares: types.optional(types.maybeNull(types.string), null),\n  pricePerFullShare: types.optional(types.maybeNull(types.string), null),\n  totalRefineryInVault: types.optional(types.maybeNull(types.string), null),\n  estimatedRefineryBountyReward: types.optional(types.maybeNull(types.string), null),\n  availableRefineryAmountToCompound: types.optional(types.string, '0'),\n  fuelTokensAmount: types.optional(types.string, '0'),\n  fees: FeesModel,\n  userData: types.model({\n    isLoading: types.boolean,\n    userShares: types.maybeNull(types.string),\n    lastDepositedTime: types.maybeNull(types.string),\n    lastUserActionTime: types.maybeNull(types.string),\n    refineryAtLastUserAction: types.maybeNull(types.string)\n  })\n}).actions(_c = self => ({\n  setEstimated(value) {\n    self.estimatedRefineryBountyReward = new BigNumber(value).multipliedBy(DEFAULT_TOKEN_DECIMAL).toJSON();\n  },\n\n  fetchVaultFeesSuccess(aggregatedCallsResponse) {\n    // if (!aggregatedCallsResponse) throw new Error('MultiCallResponse is null');\n    const callsResult = aggregatedCallsResponse === null || aggregatedCallsResponse === void 0 ? void 0 : aggregatedCallsResponse.flat();\n    const [performanceFee, callFee, withdrawalFee, withdrawalFeePeriod] = callsResult === null || callsResult === void 0 ? void 0 : callsResult.map(result => Number(result)); // console.log(performanceFee, callFee, withdrawalFee, withdrawalFeePeriod);\n\n    self.fees = {\n      performanceFee,\n      callFee,\n      withdrawalFee,\n      withdrawalFeePeriod\n    };\n  },\n\n  fetchVaultFeesError(error) {\n    clogError(error);\n    self.fees = {\n      performanceFee: null,\n      callFee: null,\n      withdrawalFee: null,\n      withdrawalFeePeriod: null\n    };\n  },\n\n  fetchVaultFees() {\n    const [address, abi] = getContractData('REFINERY_VAULT');\n    const calls = ['performanceFee', 'callFee', 'withdrawFee', 'withdrawFeePeriod'].map(method => ({\n      address,\n      name: method\n    }));\n    multicall(abi, calls).then(this.fetchVaultFeesSuccess, this.fetchVaultFeesError);\n  },\n\n  fetchVaultPublicDataSuccess(aggregatedCallsResponse) {\n    // if (!aggregatedCallsResponse) throw new Error('MultiCallResponse is null');\n    const callsResult = aggregatedCallsResponse.flat();\n    const [sharePrice, shares, estimatedRefineryBountyReward, availableRefineryAmountToCompound // totalPendingRefineryHarvest,\n    ] = callsResult;\n    const totalSharesAsBigNumber = toBigNumber(shares);\n    const sharePriceAsBigNumber = toBigNumber(sharePrice);\n    const totalRefineryInVaultEstimate = convertSharesToRefinery(totalSharesAsBigNumber, sharePriceAsBigNumber);\n    self.totalShares = totalSharesAsBigNumber.toJSON();\n    self.pricePerFullShare = sharePriceAsBigNumber.toJSON();\n    self.totalRefineryInVault = totalRefineryInVaultEstimate.refineryAsBigNumber.toJSON();\n    self.estimatedRefineryBountyReward = new BigNumber(estimatedRefineryBountyReward.toString()).toJSON();\n    self.availableRefineryAmountToCompound = toBigNumber(availableRefineryAmountToCompound).toJSON();\n  },\n\n  fetchVaultPublicDataError(error) {\n    clogError(error);\n    self.totalShares = null;\n    self.pricePerFullShare = null;\n    self.totalRefineryInVault = null;\n    self.estimatedRefineryBountyReward = null; // totalPendingRefineryHarvest: new BigNumber(totalPendingRefineryHarvest.toString()).toJSON(),\n  },\n\n  fetchVaultPublicData() {\n    const [address, abi] = getContractData('REFINERY_VAULT');\n    const calls = ['getPricePerFullShare', 'totalShares', 'calculateHarvestRefineryRewards', 'available' // to retrieve available amount of RP1 which is needed to compound // is used to correct totalStaked amount of MASTER Contract (Manual Pool)\n    // 'calculateTotalPendingRefineryRewards',\n    ].map(method => ({\n      address,\n      name: method\n    }));\n    multicall(abi, calls).then(this.fetchVaultPublicDataSuccess, this.fetchVaultPublicDataError);\n    this.fetchVaultFuelTokensAmount();\n  },\n\n  fetchVaultFuelTokensAmountSuccess(response) {\n    const {\n      amount\n    } = response;\n    self.fuelTokensAmount = amount;\n  },\n\n  fetchVaultFuelTokensAmountError() {\n    self.fuelTokensAmount = '0';\n  },\n\n  fetchVaultFuelTokensAmount() {\n    const masterRefinerContract = getContract('MASTER_REFINER');\n    const refineryVaultAddress = getContractAddress('REFINERY_VAULT');\n    masterRefinerContract.methods.userInfo('0', refineryVaultAddress).call().then(this.fetchVaultFuelTokensAmountSuccess, this.fetchVaultFuelTokensAmountError);\n  },\n\n  fetchVaultUserDataError(error) {\n    clogError(error);\n    self.userData = {\n      isLoading: true,\n      userShares: null,\n      lastDepositedTime: null,\n      lastUserActionTime: null,\n      refineryAtLastUserAction: null\n    };\n  },\n\n  fetchVaultUserDataSuccess(response) {\n    const {\n      shares,\n      lastDepositedTime,\n      lastUserActionTime,\n      refineryAtLastUserAction: refineryAtLastUserActionAsString\n    } = response;\n    self.userData = {\n      isLoading: false,\n      userShares: new BigNumber(shares).toFixed(),\n      lastDepositedTime,\n      lastUserActionTime,\n      refineryAtLastUserAction: new BigNumber(refineryAtLastUserActionAsString).toFixed()\n    };\n  },\n\n  fetchVaultUserData(address) {\n    const contract = getContract('REFINERY_VAULT');\n    contract.methods.userInfo(address).call().then(this.fetchVaultUserDataSuccess, this.fetchVaultUserDataError);\n  },\n\n  fetchPoolsPublicData() {\n    this.fetchPoolsPublicDataAsync();\n    this.fetchPoolsStakingLimitsAsync();\n  },\n\n  async fetchPoolsPublicDataAsync() {\n    const currentBlock = await metamaskService.web3Provider.eth.getBlockNumber();\n    const blockLimits = await fetchPoolsBlockLimits();\n    const totalStakings = await fetchPoolsTotalStaking();\n    const prices = getTokenPricesFromFarms();\n    clog(Object.freeze(prices));\n    const livePoolsData = poolsConfig.map(pool => {\n      const blockLimit = blockLimits.find(entry => entry.id === pool.id);\n      const totalStaking = totalStakings.find(entry => entry.id === pool.id);\n      const isPoolEndBlockExceeded = currentBlock > 0 && blockLimit ? currentBlock > Number(blockLimit.endBlock) : false;\n      const isPoolFinished = pool.isFinished || isPoolEndBlockExceeded;\n      const stakingTokenAddress = pool.stakingToken.address ? getAddress(pool.stakingToken.address).toLowerCase() : null;\n      const stakingTokenPrice = stakingTokenAddress ? prices[stakingTokenAddress] : 0;\n      const earningTokenAddress = pool.earningToken.address ? getAddress(pool.earningToken.address).toLowerCase() : null;\n      const earningTokenPrice = earningTokenAddress ? prices[earningTokenAddress] : 0;\n      const calculatedApr = getPoolApr(stakingTokenPrice, earningTokenPrice, getBalanceAmount(new BigNumber(totalStaking ? totalStaking.totalStaked : 0), pool.stakingToken.decimals), parseFloat(pool.tokenPerBlock));\n      const apr = !isPoolFinished && calculatedApr !== null ? calculatedApr : 0;\n      return { ...blockLimit,\n        ...totalStaking,\n        stakingTokenPrice,\n        earningTokenPrice,\n        apr,\n        isFinished: isPoolFinished\n      };\n    });\n    this.setPoolsPublicData(livePoolsData);\n  },\n\n  // @note livePoolsData type just copied from type derivation\n  setPoolsPublicData(livePoolsData) {\n    self.data.forEach(pool => {\n      const livePoolData = livePoolsData.find(({\n        id\n      }) => id === pool.id);\n\n      if (livePoolData) {\n        pool.stakingTokenPrice = livePoolData.stakingTokenPrice;\n        pool.earningTokenPrice = livePoolData.earningTokenPrice;\n        pool.apr = livePoolData.apr;\n\n        if (livePoolData.isFinished !== undefined) {\n          pool.isFinished = livePoolData.isFinished;\n        }\n\n        if (livePoolData.totalStaked !== undefined) {\n          pool.totalStaked = livePoolData.totalStaked;\n        }\n\n        if (livePoolData.startBlock !== undefined) {\n          pool.startBlock = livePoolData.startBlock;\n        }\n\n        if (livePoolData.endBlock !== undefined) {\n          pool.endBlock = livePoolData.endBlock;\n        }\n      }\n    });\n  },\n\n  async fetchPoolsStakingLimitsAsync() {\n    const poolsWithStakingLimit = self.data.filter(({\n      stakingLimit\n    }) => stakingLimit !== null && stakingLimit !== undefined).map(pool => pool.id);\n    const stakingLimits = await fetchPoolsStakingLimits(poolsWithStakingLimit);\n    const stakingLimitData = poolsConfig.map(pool => {\n      if (poolsWithStakingLimit.includes(pool.id)) {\n        return {\n          id: pool.id\n        };\n      }\n\n      const stakingLimit = stakingLimits[pool.id] || BIG_ZERO;\n      return {\n        id: pool.id,\n        stakingLimit: stakingLimit.toJSON()\n      };\n    });\n    this.setPoolsPublicData(stakingLimitData);\n  },\n\n  async updateUserAllowance(poolId, accountAddress) {\n    const allowances = await fetchPoolsAllowance(accountAddress);\n    this.updatePoolsUserData({\n      poolId,\n      field: 'allowance',\n      value: allowances[poolId]\n    });\n  },\n\n  async updateUserBalance(poolId, accountAddress) {\n    const tokenBalances = await fetchUserBalances(accountAddress);\n    this.updatePoolsUserData({\n      poolId,\n      field: 'stakingTokenBalance',\n      value: tokenBalances[poolId]\n    });\n  },\n\n  async updateUserStakedBalance(poolId, accountAddress) {\n    const stakedBalances = await fetchUserStakeBalances(accountAddress);\n    this.updatePoolsUserData({\n      poolId,\n      field: 'stakedBalance',\n      value: stakedBalances[poolId]\n    });\n  },\n\n  async updateUserPendingReward(poolId, accountAddress) {\n    const pendingRewards = await fetchUserPendingRewards(accountAddress);\n    this.updatePoolsUserData({\n      poolId,\n      field: 'pendingReward',\n      value: pendingRewards[poolId]\n    });\n  },\n\n  updatePoolsUserData({\n    field,\n    value,\n    poolId\n  }) {\n    const foundPool = self.data.find(p => p.id === poolId);\n    if (!foundPool) return;\n    foundPool.userData[field] = value;\n  },\n\n  // FETCH ALLOWANCES ETC. FOR POOLS\n  async fetchPoolsUserDataAsync(accountAddress) {\n    const allowances = await fetchPoolsAllowance(accountAddress);\n    const stakingTokenBalances = await fetchUserBalances(accountAddress);\n    const stakedBalances = await fetchUserStakeBalances(accountAddress);\n    const pendingRewards = await fetchUserPendingRewards(accountAddress);\n    const userData = poolsConfig.map(pool => ({\n      id: pool.id,\n      allowance: allowances[pool.id],\n      stakingTokenBalance: stakingTokenBalances[pool.id],\n      stakedBalance: stakedBalances[pool.id],\n      pendingReward: pendingRewards[pool.id]\n    }));\n    this.setPoolsUserData(userData);\n  },\n\n  setPoolsUserData(userData) {\n    userData.forEach(newUserData => {\n      const foundPool = self.data.find(pool => newUserData.id === pool.id);\n\n      if (foundPool) {\n        foundPool.userData = newUserData;\n      }\n    }); // self.data.forEach((pool) => {\n    //   const userPoolData = userData.find((entry) => entry.id === pool.id);\n    //   if (userPoolData) {\n    //     userPoolData\n    //   }\n    //   return { ...pool, userData: userPoolData }\n    // })\n    // state.userDataLoaded = true\n  }\n\n}));\n_c2 = PoolsModel;\nexport default PoolsModel;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"PoolsModel$types\\n  .model({\\n    data: types.optional(types.array(PoolModel), poolsConfig),\\n    totalShares: types.optional(types.maybeNull(types.string), null),\\n    pricePerFullShare: types.optional(types.maybeNull(types.string), null),\\n    totalRefineryInVault: types.optional(types.maybeNull(types.string), null),\\n    estimatedRefineryBountyReward: types.optional(types.maybeNull(types.string), null),\\n    availableRefineryAmountToCompound: types.optional(types.string, '0'),\\n    fuelTokensAmount: types.optional(types.string, '0'),\\n    fees: FeesModel,\\n    userData: types.model({\\n      isLoading: types.boolean,\\n      userShares: types.maybeNull(types.string),\\n      lastDepositedTime: types.maybeNull(types.string),\\n      lastUserActionTime: types.maybeNull(types.string),\\n      refineryAtLastUserAction: types.maybeNull(types.string),\\n    }),\\n  })\\n  .actions\");\n$RefreshReg$(_c2, \"PoolsModel\");","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/store/Models/Pools.ts"],"names":["BigNumber","types","pools","poolsConfig","metamaskService","getAddress","getContract","getContractAddress","getContractData","getTokenPricesFromFarms","fetchPoolsAllowance","fetchPoolsBlockLimits","fetchPoolsStakingLimits","fetchPoolsTotalStaking","fetchUserBalances","fetchUserPendingRewards","fetchUserStakeBalances","convertSharesToRefinery","toBigNumber","getPoolApr","BIG_ZERO","DEFAULT_TOKEN_DECIMAL","getBalanceAmount","clog","clogError","multicall","AddressModel","FeesModel","TokenModel","UserDataModel","model","allowance","string","stakingTokenBalance","stakedBalance","pendingReward","PoolModel","id","number","earningToken","stakingToken","contractAddress","tokenPerBlock","isFinished","optional","boolean","enableEmergencyWithdraw","totalStaked","stakingLimit","startBlock","endBlock","apr","stakingTokenPrice","earningTokenPrice","isAutoVault","userData","PoolsModel","data","array","totalShares","maybeNull","pricePerFullShare","totalRefineryInVault","estimatedRefineryBountyReward","availableRefineryAmountToCompound","fuelTokensAmount","fees","isLoading","userShares","lastDepositedTime","lastUserActionTime","refineryAtLastUserAction","actions","self","setEstimated","value","multipliedBy","toJSON","fetchVaultFeesSuccess","aggregatedCallsResponse","callsResult","flat","performanceFee","callFee","withdrawalFee","withdrawalFeePeriod","map","result","Number","fetchVaultFeesError","error","fetchVaultFees","address","abi","calls","method","name","then","fetchVaultPublicDataSuccess","sharePrice","shares","totalSharesAsBigNumber","sharePriceAsBigNumber","totalRefineryInVaultEstimate","refineryAsBigNumber","toString","fetchVaultPublicDataError","fetchVaultPublicData","fetchVaultFuelTokensAmount","fetchVaultFuelTokensAmountSuccess","response","amount","fetchVaultFuelTokensAmountError","masterRefinerContract","refineryVaultAddress","methods","userInfo","call","fetchVaultUserDataError","fetchVaultUserDataSuccess","refineryAtLastUserActionAsString","toFixed","fetchVaultUserData","contract","fetchPoolsPublicData","fetchPoolsPublicDataAsync","fetchPoolsStakingLimitsAsync","currentBlock","web3Provider","eth","getBlockNumber","blockLimits","totalStakings","prices","Object","freeze","livePoolsData","pool","blockLimit","find","entry","totalStaking","isPoolEndBlockExceeded","isPoolFinished","stakingTokenAddress","toLowerCase","earningTokenAddress","calculatedApr","decimals","parseFloat","setPoolsPublicData","forEach","livePoolData","undefined","poolsWithStakingLimit","filter","stakingLimits","stakingLimitData","includes","updateUserAllowance","poolId","accountAddress","allowances","updatePoolsUserData","field","updateUserBalance","tokenBalances","updateUserStakedBalance","stakedBalances","updateUserPendingReward","pendingRewards","foundPool","p","fetchPoolsUserDataAsync","stakingTokenBalances","setPoolsUserData","newUserData"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js/bignumber';\nimport { types } from 'mobx-state-tree';\n\nimport { pools as poolsConfig } from '@/config';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport {\n  getAddress,\n  getContract,\n  getContractAddress,\n  getContractData,\n} from '@/services/web3/contractHelpers';\nimport { getTokenPricesFromFarms } from '@/store/farms';\nimport {\n  fetchPoolsAllowance,\n  // fetch block limits (ends in)\n  fetchPoolsBlockLimits,\n  fetchPoolsStakingLimits,\n  fetchPoolsTotalStaking,\n  fetchUserBalances,\n  fetchUserPendingRewards,\n  fetchUserStakeBalances,\n} from '@/store/pools';\nimport { convertSharesToRefinery } from '@/store/pools/helpers';\nimport { toBigNumber } from '@/utils';\nimport { getPoolApr } from '@/utils/apr';\nimport { BIG_ZERO, DEFAULT_TOKEN_DECIMAL } from '@/utils/constants';\nimport { getBalanceAmount } from '@/utils/formatters';\nimport { clog, clogError } from '@/utils/logger';\nimport { multicall } from '@/utils/multicall';\n\nimport AddressModel from './Address';\nimport FeesModel from './Fees';\nimport TokenModel from './Token';\n\nconst UserDataModel = types.model({\n  allowance: types.string,\n  stakingTokenBalance: types.string,\n  stakedBalance: types.string,\n  pendingReward: types.string,\n});\n\nconst PoolModel = types.model({\n  id: types.number,\n  earningToken: TokenModel,\n  stakingToken: TokenModel,\n  contractAddress: AddressModel,\n  tokenPerBlock: types.string,\n\n  isFinished: types.optional(types.boolean, false),\n  enableEmergencyWithdraw: types.optional(types.boolean, false),\n\n  totalStaked: types.optional(types.string, '0'),\n  stakingLimit: types.optional(types.string, '0'),\n  startBlock: types.optional(types.number, 0),\n  endBlock: types.optional(types.number, 0),\n  apr: types.optional(types.number, 0),\n  stakingTokenPrice: types.optional(types.number, 0),\n  earningTokenPrice: types.optional(types.number, 0),\n  isAutoVault: types.optional(types.boolean, false),\n  userData: types.optional(UserDataModel, {\n    allowance: '',\n    stakingTokenBalance: '',\n    stakedBalance: '',\n    pendingReward: '',\n  }),\n});\n\nconst PoolsModel = types\n  .model({\n    data: types.optional(types.array(PoolModel), poolsConfig),\n    totalShares: types.optional(types.maybeNull(types.string), null),\n    pricePerFullShare: types.optional(types.maybeNull(types.string), null),\n    totalRefineryInVault: types.optional(types.maybeNull(types.string), null),\n    estimatedRefineryBountyReward: types.optional(types.maybeNull(types.string), null),\n    availableRefineryAmountToCompound: types.optional(types.string, '0'),\n    fuelTokensAmount: types.optional(types.string, '0'),\n    fees: FeesModel,\n    userData: types.model({\n      isLoading: types.boolean,\n      userShares: types.maybeNull(types.string),\n      lastDepositedTime: types.maybeNull(types.string),\n      lastUserActionTime: types.maybeNull(types.string),\n      refineryAtLastUserAction: types.maybeNull(types.string),\n    }),\n  })\n  .actions((self) => ({\n    setEstimated(value: number) {\n      self.estimatedRefineryBountyReward = new BigNumber(value)\n        .multipliedBy(DEFAULT_TOKEN_DECIMAL)\n        .toJSON();\n    },\n\n    fetchVaultFeesSuccess(aggregatedCallsResponse: any) {\n      // if (!aggregatedCallsResponse) throw new Error('MultiCallResponse is null');\n      const callsResult = aggregatedCallsResponse?.flat();\n      const [\n        performanceFee,\n        callFee,\n        withdrawalFee,\n        withdrawalFeePeriod,\n      ] = callsResult?.map((result: any) => Number(result));\n\n      // console.log(performanceFee, callFee, withdrawalFee, withdrawalFeePeriod);\n      self.fees = {\n        performanceFee,\n        callFee,\n        withdrawalFee,\n        withdrawalFeePeriod,\n      };\n    },\n    fetchVaultFeesError(error: any) {\n      clogError(error);\n      self.fees = {\n        performanceFee: null,\n        callFee: null,\n        withdrawalFee: null,\n        withdrawalFeePeriod: null,\n      };\n    },\n    fetchVaultFees() {\n      const [address, abi] = getContractData('REFINERY_VAULT') as [string, []];\n      const calls = ['performanceFee', 'callFee', 'withdrawFee', 'withdrawFeePeriod'].map(\n        (method) => ({\n          address,\n          name: method,\n        }),\n      );\n      multicall(abi, calls).then(this.fetchVaultFeesSuccess, this.fetchVaultFeesError);\n    },\n\n    fetchVaultPublicDataSuccess(aggregatedCallsResponse: Array<string[]>) {\n      // if (!aggregatedCallsResponse) throw new Error('MultiCallResponse is null');\n      const callsResult = aggregatedCallsResponse.flat();\n      const [\n        sharePrice,\n        shares,\n        estimatedRefineryBountyReward,\n        availableRefineryAmountToCompound,\n        // totalPendingRefineryHarvest,\n      ] = callsResult;\n\n      const totalSharesAsBigNumber = toBigNumber(shares);\n      const sharePriceAsBigNumber = toBigNumber(sharePrice);\n      const totalRefineryInVaultEstimate = convertSharesToRefinery(\n        totalSharesAsBigNumber,\n        sharePriceAsBigNumber,\n      );\n\n      self.totalShares = totalSharesAsBigNumber.toJSON();\n      self.pricePerFullShare = sharePriceAsBigNumber.toJSON();\n      self.totalRefineryInVault = totalRefineryInVaultEstimate.refineryAsBigNumber.toJSON();\n      self.estimatedRefineryBountyReward = new BigNumber(\n        estimatedRefineryBountyReward.toString(),\n      ).toJSON();\n      self.availableRefineryAmountToCompound = toBigNumber(\n        availableRefineryAmountToCompound,\n      ).toJSON();\n    },\n    fetchVaultPublicDataError(error: any) {\n      clogError(error);\n      self.totalShares = null;\n      self.pricePerFullShare = null;\n      self.totalRefineryInVault = null;\n      self.estimatedRefineryBountyReward = null;\n      // totalPendingRefineryHarvest: new BigNumber(totalPendingRefineryHarvest.toString()).toJSON(),\n    },\n    fetchVaultPublicData() {\n      const [address, abi] = getContractData('REFINERY_VAULT') as [string, []];\n      const calls = [\n        'getPricePerFullShare',\n        'totalShares',\n        'calculateHarvestRefineryRewards',\n        'available', // to retrieve available amount of RP1 which is needed to compound // is used to correct totalStaked amount of MASTER Contract (Manual Pool)\n        // 'calculateTotalPendingRefineryRewards',\n      ].map((method) => ({\n        address,\n        name: method,\n      }));\n      multicall(abi, calls).then(this.fetchVaultPublicDataSuccess, this.fetchVaultPublicDataError);\n\n      this.fetchVaultFuelTokensAmount();\n    },\n\n    fetchVaultFuelTokensAmountSuccess(response: { amount: string; rewardDebt: string }) {\n      const { amount } = response;\n      self.fuelTokensAmount = amount;\n    },\n    fetchVaultFuelTokensAmountError() {\n      self.fuelTokensAmount = '0';\n    },\n    fetchVaultFuelTokensAmount() {\n      const masterRefinerContract = getContract('MASTER_REFINER');\n      const refineryVaultAddress = getContractAddress('REFINERY_VAULT');\n      masterRefinerContract.methods\n        .userInfo('0', refineryVaultAddress)\n        .call()\n        .then(this.fetchVaultFuelTokensAmountSuccess, this.fetchVaultFuelTokensAmountError);\n    },\n\n    fetchVaultUserDataError(error: any) {\n      clogError(error);\n      self.userData = {\n        isLoading: true,\n        userShares: null,\n        lastDepositedTime: null,\n        lastUserActionTime: null,\n        refineryAtLastUserAction: null,\n      };\n    },\n    fetchVaultUserDataSuccess(response: any) {\n      const {\n        shares,\n        lastDepositedTime,\n        lastUserActionTime,\n        refineryAtLastUserAction: refineryAtLastUserActionAsString,\n      } = response;\n      self.userData = {\n        isLoading: false,\n        userShares: new BigNumber(shares).toFixed(),\n        lastDepositedTime,\n        lastUserActionTime,\n        refineryAtLastUserAction: new BigNumber(refineryAtLastUserActionAsString).toFixed(),\n      };\n    },\n    fetchVaultUserData(address: string) {\n      const contract = getContract('REFINERY_VAULT');\n      contract.methods\n        .userInfo(address)\n        .call()\n        .then(this.fetchVaultUserDataSuccess, this.fetchVaultUserDataError);\n    },\n\n    fetchPoolsPublicData() {\n      this.fetchPoolsPublicDataAsync();\n      this.fetchPoolsStakingLimitsAsync();\n    },\n\n    async fetchPoolsPublicDataAsync() {\n      const currentBlock = await metamaskService.web3Provider.eth.getBlockNumber();\n\n      const blockLimits = await fetchPoolsBlockLimits();\n      const totalStakings = await fetchPoolsTotalStaking();\n\n      const prices = getTokenPricesFromFarms();\n\n      clog(Object.freeze(prices));\n\n      const livePoolsData = poolsConfig.map((pool) => {\n        const blockLimit = blockLimits.find((entry) => entry.id === pool.id);\n        const totalStaking = totalStakings.find((entry) => entry.id === pool.id);\n        const isPoolEndBlockExceeded =\n          currentBlock > 0 && blockLimit ? currentBlock > Number(blockLimit.endBlock) : false;\n        const isPoolFinished = pool.isFinished || isPoolEndBlockExceeded;\n\n        const stakingTokenAddress = pool.stakingToken.address\n          ? getAddress(pool.stakingToken.address).toLowerCase()\n          : null;\n        const stakingTokenPrice = stakingTokenAddress ? prices[stakingTokenAddress] : 0;\n\n        const earningTokenAddress = pool.earningToken.address\n          ? getAddress(pool.earningToken.address).toLowerCase()\n          : null;\n        const earningTokenPrice = earningTokenAddress ? prices[earningTokenAddress] : 0;\n        const calculatedApr = getPoolApr(\n          stakingTokenPrice,\n          earningTokenPrice,\n          getBalanceAmount(\n            new BigNumber(totalStaking ? totalStaking.totalStaked : 0),\n            pool.stakingToken.decimals,\n          ),\n          parseFloat(pool.tokenPerBlock),\n        );\n        const apr = !isPoolFinished && calculatedApr !== null ? calculatedApr : 0;\n\n        return {\n          ...blockLimit,\n          ...totalStaking,\n          stakingTokenPrice,\n          earningTokenPrice,\n          apr,\n          isFinished: isPoolFinished,\n        };\n      });\n\n      this.setPoolsPublicData(livePoolsData);\n    },\n    // @note livePoolsData type just copied from type derivation\n    setPoolsPublicData(\n      livePoolsData: Array<{\n        stakingTokenPrice: number;\n        earningTokenPrice: number;\n        apr: number;\n        isFinished: boolean;\n        id?: number;\n        totalStaked?: string;\n        startBlock?: number;\n        endBlock?: number;\n      }>,\n    ) {\n      self.data.forEach((pool) => {\n        const livePoolData = livePoolsData.find(({ id }) => id === pool.id);\n        if (livePoolData) {\n          pool.stakingTokenPrice = livePoolData.stakingTokenPrice;\n          pool.earningTokenPrice = livePoolData.earningTokenPrice;\n          pool.apr = livePoolData.apr;\n\n          if (livePoolData.isFinished !== undefined) {\n            pool.isFinished = livePoolData.isFinished;\n          }\n\n          if (livePoolData.totalStaked !== undefined) {\n            pool.totalStaked = livePoolData.totalStaked;\n          }\n          if (livePoolData.startBlock !== undefined) {\n            pool.startBlock = livePoolData.startBlock;\n          }\n          if (livePoolData.endBlock !== undefined) {\n            pool.endBlock = livePoolData.endBlock;\n          }\n        }\n      });\n    },\n\n    async fetchPoolsStakingLimitsAsync() {\n      const poolsWithStakingLimit = self.data\n        .filter(({ stakingLimit }) => stakingLimit !== null && stakingLimit !== undefined)\n        .map((pool) => pool.id);\n\n      const stakingLimits = await fetchPoolsStakingLimits(poolsWithStakingLimit);\n\n      const stakingLimitData = poolsConfig.map((pool) => {\n        if (poolsWithStakingLimit.includes(pool.id)) {\n          return { id: pool.id };\n        }\n        const stakingLimit = stakingLimits[pool.id] || BIG_ZERO;\n        return {\n          id: pool.id,\n          stakingLimit: stakingLimit.toJSON(),\n        };\n      });\n\n      this.setPoolsPublicData(stakingLimitData);\n    },\n\n    async updateUserAllowance(poolId: number, accountAddress: string) {\n      const allowances = await fetchPoolsAllowance(accountAddress);\n      this.updatePoolsUserData({ poolId, field: 'allowance', value: allowances[poolId] });\n    },\n\n    async updateUserBalance(poolId: number, accountAddress: string) {\n      const tokenBalances = await fetchUserBalances(accountAddress);\n      this.updatePoolsUserData({\n        poolId,\n        field: 'stakingTokenBalance',\n        value: tokenBalances[poolId],\n      });\n    },\n\n    async updateUserStakedBalance(poolId: number, accountAddress: string) {\n      const stakedBalances = await fetchUserStakeBalances(accountAddress);\n      this.updatePoolsUserData({ poolId, field: 'stakedBalance', value: stakedBalances[poolId] });\n    },\n\n    async updateUserPendingReward(poolId: number, accountAddress: string) {\n      const pendingRewards = await fetchUserPendingRewards(accountAddress);\n      this.updatePoolsUserData({ poolId, field: 'pendingReward', value: pendingRewards[poolId] });\n    },\n\n    updatePoolsUserData({\n      field,\n      value,\n      poolId,\n    }: {\n      poolId: number;\n      field: string;\n      value: string;\n    }) {\n      const foundPool = self.data.find((p) => p.id === poolId);\n      if (!foundPool) return;\n      (foundPool.userData as any)[field] = value;\n    },\n\n    // FETCH ALLOWANCES ETC. FOR POOLS\n    async fetchPoolsUserDataAsync(accountAddress: string) {\n      const allowances = await fetchPoolsAllowance(accountAddress);\n      const stakingTokenBalances = await fetchUserBalances(accountAddress);\n      const stakedBalances = await fetchUserStakeBalances(accountAddress);\n      const pendingRewards = await fetchUserPendingRewards(accountAddress);\n\n      const userData = poolsConfig.map((pool) => ({\n        id: pool.id,\n        allowance: allowances[pool.id],\n        stakingTokenBalance: stakingTokenBalances[pool.id],\n        stakedBalance: stakedBalances[pool.id],\n        pendingReward: pendingRewards[pool.id],\n      }));\n\n      this.setPoolsUserData(userData);\n    },\n\n    setPoolsUserData(\n      userData: Array<{\n        id: number;\n        allowance: string;\n        stakingTokenBalance: string;\n        stakedBalance: string;\n        pendingReward: string;\n      }>,\n    ) {\n      userData.forEach((newUserData) => {\n        const foundPool = self.data.find((pool) => newUserData.id === pool.id);\n        if (foundPool) {\n          foundPool.userData = newUserData;\n        }\n      });\n      // self.data.forEach((pool) => {\n      //   const userPoolData = userData.find((entry) => entry.id === pool.id);\n      //   if (userPoolData) {\n      //     userPoolData\n      //   }\n      //   return { ...pool, userData: userPoolData }\n      // })\n      // state.userDataLoaded = true\n    },\n  }));\n\nexport default PoolsModel;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber'; // import { convertSharesToRefinery } from './helpers';\n\nimport { pools as poolsConfig } from '@/config';\nimport { SmartRefinerInitializable as smartRefinerInitializableAbi } from '@/config/abi';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport { getAddress, getContract, getContractData } from '@/services/web3/contractHelpers';\nimport { BIG_ZERO } from '@/utils/constants';\nimport { multicall } from '@/utils/multicall';\nexport const fetchPoolsBlockLimits = async () => {\n  const poolsWithEnd = poolsConfig.filter(pool => pool.id !== 0);\n  const callsStartBlock = poolsWithEnd.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'startBlock'\n    };\n  });\n  const callsEndBlock = poolsWithEnd.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'bonusEndBlock'\n    };\n  });\n  const [, abi] = getContractData('SMART_REFINER_INITIALIZABLE');\n  const starts = await multicall(abi, callsStartBlock);\n  const ends = await multicall(abi, callsEndBlock);\n  return poolsWithEnd.map((cakePoolConfig, index) => {\n    const startBlock = starts[index];\n    const endBlock = ends[index];\n    return {\n      id: cakePoolConfig.id,\n      startBlock: new BigNumber(startBlock).toNumber(),\n      endBlock: new BigNumber(endBlock).toNumber()\n    };\n  });\n};\nexport const fetchPoolsTotalStaking = async () => {\n  // TODO: если в будущем будет поддержка BNB, то надо будет стянуть ещё функциональность\n  //       для пулов, работающих на BNB, BEP-20\n  //       @see https://github.com/pancakeswap/pancake-frontend/blob/c8a7c5c3b32ae99801cf047b5d10afc5b68bf4f8/src/state/pools/fetchPools.ts#L40\n  const calls = poolsConfig.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.stakingToken.address),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)]\n    };\n  });\n  const [, rocketPropellantABI] = getContractData('RP1');\n  const poolsTotalStaked = await multicall(rocketPropellantABI, calls);\n  return [...poolsConfig.map((pool, index) => ({\n    id: pool.id,\n    totalStaked: poolsTotalStaked ? new BigNumber(poolsTotalStaked[index]).toFixed() : '0'\n  }))];\n};\nexport const fetchPoolStakingLimit = async id => {\n  try {\n    const [{\n      contractAddress\n    }] = poolsConfig.filter(pool => pool.id === id);\n    const contract = metamaskService.getContract(getAddress(contractAddress), smartRefinerInitializableAbi);\n    const stakingLimit = await contract.methods.poolLimitPerUser().call();\n    return new BigNumber(stakingLimit.toString());\n  } catch (error) {\n    return BIG_ZERO;\n  }\n};\nexport const fetchPoolsStakingLimits = async (poolsWithStakingLimit) => {\n  const validPools = poolsConfig.filter(pool => pool.stakingToken.symbol !== 'BNB' && !pool.isFinished).filter(pool => !poolsWithStakingLimit.includes(pool.id)); // Get the staking limit for each valid pool\n  // Note: We cannot batch the calls via multicall because V1 pools do not have \"poolLimitPerUser\" and will throw an error\n\n  const stakingLimitPromises = validPools.map(validPool => fetchPoolStakingLimit(validPool.id));\n  const stakingLimits = await Promise.all(stakingLimitPromises);\n  return stakingLimits.reduce((accumulator, stakingLimit, index) => {\n    return { ...accumulator,\n      [validPools[index].id]: stakingLimit\n    };\n  }, {});\n}; // export const batchRequests = (requests: Array<any>): Promise<PromiseSettledResult<any>[]> =>\n//   Promise.allSettled(requests.map((req) => req()));\n// Pool 0, Rp1 / Rp1 is a different kind of contract (master refinery)\n// BNB pools use the native BNB token (wrapping ? unwrapping is done at the contract level)\n// const nonBnbPools = poolsConfig.filter((pool) => pool.stakingToken.symbol !== 'BNB')\n// const bnbPools = poolsConfig.filter((pool) => pool.stakingToken.symbol === 'BNB')\n\nconst nonBnbPools = poolsConfig;\nconst nonMasterPools = poolsConfig.filter(pool => pool.id !== 0);\nexport const fetchPoolsAllowance = async (accountAddress) => {\n  const calls = nonBnbPools.map(pool => ({\n    address: getAddress(pool.stakingToken.address),\n    name: 'allowance',\n    params: [accountAddress, getAddress(pool.contractAddress)]\n  }));\n  const [, erc20Abi] = getContractData('ERC20');\n  const allowances = await multicall(erc20Abi, calls);\n  return nonBnbPools.reduce((acc, pool, index) => ({ ...acc,\n    [pool.id]: new BigNumber(allowances[index]).toJSON()\n  }), {});\n};\nexport const fetchUserBalances = async (accountAddress) => {\n  // Non BNB pools\n  const calls = poolsConfig.map(pool => ({\n    address: getAddress(pool.stakingToken.address),\n    name: 'balanceOf',\n    params: [accountAddress]\n  }));\n  const [, erc20Abi] = getContractData('ERC20');\n  const tokenBalances = await multicall(erc20Abi, calls);\n  return nonBnbPools.reduce((acc, pool, index) => ({ ...acc,\n    [pool.id]: new BigNumber(tokenBalances[index]).toJSON()\n  }), {});\n};\nexport const fetchUserStakeBalances = async (accountAddress) => {\n  const calls = nonMasterPools.map(pool => ({\n    address: getAddress(pool.contractAddress),\n    name: 'userInfo',\n    params: [accountAddress]\n  }));\n  const userInfo = await multicall(smartRefinerInitializableAbi, calls);\n  const stakedBalances = nonMasterPools.reduce((acc, pool, index) => {\n    const [amount] = userInfo[index];\n    return { ...acc,\n      [pool.id]: new BigNumber(amount).toJSON()\n    };\n  }, {}); // RocketPropellant1 / RocketPropellant1 pool\n\n  const masterRefinerContract = getContract('MASTER_REFINER');\n  const {\n    amount: masterPoolAmount\n  } = await masterRefinerContract.methods.userInfo('0', accountAddress).call();\n  return { ...stakedBalances,\n    0: new BigNumber(masterPoolAmount.toString()).toJSON()\n  };\n};\nexport const fetchUserPendingRewards = async (accountAddress) => {\n  const calls = nonMasterPools.map(pool => ({\n    address: getAddress(pool.contractAddress),\n    name: 'pendingReward',\n    params: [accountAddress]\n  }));\n  const pendingRewardsRaw = await multicall(smartRefinerInitializableAbi, calls);\n  const pendingRewards = nonMasterPools.reduce((acc, pool, index) => ({ ...acc,\n    [pool.id]: new BigNumber(pendingRewardsRaw[index]).toJSON()\n  }), {}); // RocketPropellant1 / RocketPropellant1 pool\n\n  const masterRefinerContract = getContract('MASTER_REFINER');\n  const pendingReward = await masterRefinerContract.methods.pendingRP1('0', accountAddress).call();\n  return { ...pendingRewards,\n    0: new BigNumber(pendingReward.toString()).toJSON()\n  };\n};","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/store/pools/index.ts"],"names":["BigNumber","pools","poolsConfig","SmartRefinerInitializable","smartRefinerInitializableAbi","metamaskService","getAddress","getContract","getContractData","BIG_ZERO","multicall","fetchPoolsBlockLimits","poolsWithEnd","filter","pool","id","callsStartBlock","map","poolConfig","address","contractAddress","name","callsEndBlock","abi","starts","ends","cakePoolConfig","index","startBlock","endBlock","toNumber","fetchPoolsTotalStaking","calls","stakingToken","params","rocketPropellantABI","poolsTotalStaked","totalStaked","toFixed","fetchPoolStakingLimit","contract","stakingLimit","methods","poolLimitPerUser","call","toString","error","fetchPoolsStakingLimits","poolsWithStakingLimit","validPools","symbol","isFinished","includes","stakingLimitPromises","validPool","stakingLimits","Promise","all","reduce","accumulator","nonBnbPools","nonMasterPools","fetchPoolsAllowance","accountAddress","erc20Abi","allowances","acc","toJSON","fetchUserBalances","tokenBalances","fetchUserStakeBalances","userInfo","stakedBalances","amount","masterRefinerContract","masterPoolAmount","fetchUserPendingRewards","pendingRewardsRaw","pendingRewards","pendingReward","pendingRP1"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js/bignumber';\n\n// import { convertSharesToRefinery } from './helpers';\nimport { pools as poolsConfig } from '@/config';\nimport { SmartRefinerInitializable as smartRefinerInitializableAbi } from '@/config/abi';\nimport { metamaskService } from '@/services/MetamaskConnect';\nimport { getAddress, getContract, getContractData } from '@/services/web3/contractHelpers';\nimport { BIG_ZERO } from '@/utils/constants';\nimport { multicall } from '@/utils/multicall';\n\nexport const fetchPoolsBlockLimits = async (): Promise<\n  {\n    id: number;\n    startBlock: number;\n    endBlock: number;\n  }[]\n> => {\n  const poolsWithEnd = poolsConfig.filter((pool) => pool.id !== 0);\n  const callsStartBlock = poolsWithEnd.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'startBlock',\n    };\n  });\n  const callsEndBlock = poolsWithEnd.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'bonusEndBlock',\n    };\n  });\n\n  const [, abi] = getContractData('SMART_REFINER_INITIALIZABLE');\n\n  const starts = await multicall(abi, callsStartBlock);\n  const ends = await multicall(abi, callsEndBlock);\n\n  return poolsWithEnd.map((cakePoolConfig, index) => {\n    const startBlock = starts[index];\n    const endBlock = ends[index];\n    return {\n      id: cakePoolConfig.id,\n      startBlock: new BigNumber(startBlock).toNumber(),\n      endBlock: new BigNumber(endBlock).toNumber(),\n    };\n  });\n};\n\nexport const fetchPoolsTotalStaking = async (): Promise<\n  {\n    id: number;\n    totalStaked: string;\n  }[]\n> => {\n  // TODO: если в будущем будет поддержка BNB, то надо будет стянуть ещё функциональность\n  //       для пулов, работающих на BNB, BEP-20\n  //       @see https://github.com/pancakeswap/pancake-frontend/blob/c8a7c5c3b32ae99801cf047b5d10afc5b68bf4f8/src/state/pools/fetchPools.ts#L40\n  const calls = poolsConfig.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.stakingToken.address),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)],\n    };\n  });\n\n  const [, rocketPropellantABI] = getContractData('RP1');\n  const poolsTotalStaked = await multicall<string[]>(rocketPropellantABI, calls);\n\n  return [\n    ...poolsConfig.map((pool, index) => ({\n      id: pool.id,\n      totalStaked: poolsTotalStaked ? new BigNumber(poolsTotalStaked[index]).toFixed() : '0',\n    })),\n  ];\n};\n\nexport const fetchPoolStakingLimit = async (id: number): Promise<BigNumber> => {\n  try {\n    const [{ contractAddress }] = poolsConfig.filter((pool) => pool.id === id);\n\n    const contract = metamaskService.getContract(\n      getAddress(contractAddress),\n      smartRefinerInitializableAbi,\n    );\n\n    const stakingLimit = await contract.methods.poolLimitPerUser().call();\n    return new BigNumber(stakingLimit.toString());\n  } catch (error) {\n    return BIG_ZERO;\n  }\n};\n\nexport const fetchPoolsStakingLimits = async (\n  poolsWithStakingLimit: number[],\n): Promise<{ [key: string]: BigNumber }> => {\n  const validPools = poolsConfig\n    .filter((pool) => pool.stakingToken.symbol !== 'BNB' && !pool.isFinished)\n    .filter((pool) => !poolsWithStakingLimit.includes(pool.id));\n\n  // Get the staking limit for each valid pool\n  // Note: We cannot batch the calls via multicall because V1 pools do not have \"poolLimitPerUser\" and will throw an error\n  const stakingLimitPromises = validPools.map((validPool) => fetchPoolStakingLimit(validPool.id));\n  const stakingLimits = await Promise.all(stakingLimitPromises);\n\n  return stakingLimits.reduce((accumulator, stakingLimit, index) => {\n    return {\n      ...accumulator,\n      [validPools[index].id]: stakingLimit,\n    };\n  }, {});\n};\n\n// export const batchRequests = (requests: Array<any>): Promise<PromiseSettledResult<any>[]> =>\n//   Promise.allSettled(requests.map((req) => req()));\n\n// Pool 0, Rp1 / Rp1 is a different kind of contract (master refinery)\n// BNB pools use the native BNB token (wrapping ? unwrapping is done at the contract level)\n// const nonBnbPools = poolsConfig.filter((pool) => pool.stakingToken.symbol !== 'BNB')\n// const bnbPools = poolsConfig.filter((pool) => pool.stakingToken.symbol === 'BNB')\nconst nonBnbPools = poolsConfig;\nconst nonMasterPools = poolsConfig.filter((pool) => pool.id !== 0);\n\nexport const fetchPoolsAllowance = async (\n  accountAddress: string,\n): Promise<Record<string, string>> => {\n  const calls = nonBnbPools.map((pool) => ({\n    address: getAddress(pool.stakingToken.address),\n    name: 'allowance',\n    params: [accountAddress, getAddress(pool.contractAddress)],\n  }));\n  const [, erc20Abi] = getContractData('ERC20');\n  const allowances = await multicall(erc20Abi, calls);\n\n  return nonBnbPools.reduce(\n    (acc, pool, index) => ({ ...acc, [pool.id]: new BigNumber(allowances[index]).toJSON() }),\n    {},\n  );\n};\n\nexport const fetchUserBalances = async (\n  accountAddress: string,\n): Promise<Record<string, string>> => {\n  // Non BNB pools\n  const calls = poolsConfig.map((pool) => ({\n    address: getAddress(pool.stakingToken.address),\n    name: 'balanceOf',\n    params: [accountAddress],\n  }));\n  const [, erc20Abi] = getContractData('ERC20');\n  const tokenBalances = await multicall(erc20Abi, calls);\n\n  return nonBnbPools.reduce(\n    (acc, pool, index) => ({\n      ...acc,\n      [pool.id]: new BigNumber(tokenBalances[index]).toJSON(),\n    }),\n    {},\n  );\n};\n\nexport const fetchUserStakeBalances = async (\n  accountAddress: string,\n): Promise<Record<string, string>> => {\n  const calls = nonMasterPools.map((pool) => ({\n    address: getAddress(pool.contractAddress),\n    name: 'userInfo',\n    params: [accountAddress],\n  }));\n  const userInfo = await multicall(smartRefinerInitializableAbi, calls);\n\n  const stakedBalances = nonMasterPools.reduce((acc, pool, index) => {\n    const [amount] = userInfo[index];\n    return {\n      ...acc,\n      [pool.id]: new BigNumber(amount).toJSON(),\n    };\n  }, {});\n\n  // RocketPropellant1 / RocketPropellant1 pool\n  const masterRefinerContract = getContract('MASTER_REFINER');\n  const { amount: masterPoolAmount } = await masterRefinerContract.methods\n    .userInfo('0', accountAddress)\n    .call();\n\n  return { ...stakedBalances, 0: new BigNumber(masterPoolAmount.toString()).toJSON() };\n};\n\nexport const fetchUserPendingRewards = async (\n  accountAddress: string,\n): Promise<Record<string, string>> => {\n  const calls = nonMasterPools.map((pool) => ({\n    address: getAddress(pool.contractAddress),\n    name: 'pendingReward',\n    params: [accountAddress],\n  }));\n  const pendingRewardsRaw = await multicall(smartRefinerInitializableAbi, calls);\n\n  const pendingRewards = nonMasterPools.reduce(\n    (acc, pool, index) => ({\n      ...acc,\n      [pool.id]: new BigNumber(pendingRewardsRaw[index]).toJSON(),\n    }),\n    {},\n  );\n\n  // RocketPropellant1 / RocketPropellant1 pool\n  const masterRefinerContract = getContract('MASTER_REFINER');\n  const pendingReward = await masterRefinerContract.methods.pendingRP1('0', accountAddress).call();\n\n  return { ...pendingRewards, 0: new BigNumber(pendingReward.toString()).toJSON() };\n};\n"]},"metadata":{},"sourceType":"module"}
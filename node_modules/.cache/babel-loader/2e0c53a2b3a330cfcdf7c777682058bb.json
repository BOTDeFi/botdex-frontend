{"ast":null,"code":"/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  /** @type {Array.<string>} */\n\n  const results = [];\n  let index = -1;\n  let before = safeOptions.before;\n  indexStack.push(-1);\n\n  while (++index < children.length) {\n    const child = children[index];\n    /** @type {string} */\n\n    let after;\n    indexStack[indexStack.length - 1] = index;\n\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type];\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, context, {\n        before: '',\n        after: ''\n      }).charAt(0) : '';\n    } else {\n      after = safeOptions.after;\n    } // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n\n\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n    }\n\n    results.push(context.handle(child, parent, context, {\n      before,\n      after\n    }));\n    before = results[results.length - 1].slice(-1);\n  }\n\n  indexStack.pop();\n  return results.join('');\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"names":["containerPhrasing","parent","context","safeOptions","indexStack","children","results","index","before","push","length","child","after","handle","handlers","type","peek","charAt","replace","slice","pop","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,iBAAT,CAA2BC,MAA3B,EAAmCC,OAAnC,EAA4CC,WAA5C,EAAyD;AAC9D,QAAMC,UAAU,GAAGF,OAAO,CAACE,UAA3B;AACA,QAAMC,QAAQ,GAAGJ,MAAM,CAACI,QAAP,IAAmB,EAApC;AACA;;AACA,QAAMC,OAAO,GAAG,EAAhB;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;AACA,MAAIC,MAAM,GAAGL,WAAW,CAACK,MAAzB;AAEAJ,EAAAA,UAAU,CAACK,IAAX,CAAgB,CAAC,CAAjB;;AAEA,SAAO,EAAEF,KAAF,GAAUF,QAAQ,CAACK,MAA1B,EAAkC;AAChC,UAAMC,KAAK,GAAGN,QAAQ,CAACE,KAAD,CAAtB;AACA;;AACA,QAAIK,KAAJ;AAEAR,IAAAA,UAAU,CAACA,UAAU,CAACM,MAAX,GAAoB,CAArB,CAAV,GAAoCH,KAApC;;AAEA,QAAIA,KAAK,GAAG,CAAR,GAAYF,QAAQ,CAACK,MAAzB,EAAiC;AAC/B;AACA,UAAIG,MAAM,GAAGX,OAAO,CAACW,MAAR,CAAeC,QAAf,CAAwBT,QAAQ,CAACE,KAAK,GAAG,CAAT,CAAR,CAAoBQ,IAA5C,CAAb;AACA,UAAIF,MAAM,IAAIA,MAAM,CAACG,IAArB,EAA2BH,MAAM,GAAGA,MAAM,CAACG,IAAhB;AAC3BJ,MAAAA,KAAK,GAAGC,MAAM,GACVA,MAAM,CAACR,QAAQ,CAACE,KAAK,GAAG,CAAT,CAAT,EAAsBN,MAAtB,EAA8BC,OAA9B,EAAuC;AAC3CM,QAAAA,MAAM,EAAE,EADmC;AAE3CI,QAAAA,KAAK,EAAE;AAFoC,OAAvC,CAAN,CAGGK,MAHH,CAGU,CAHV,CADU,GAKV,EALJ;AAMD,KAVD,MAUO;AACLL,MAAAA,KAAK,GAAGT,WAAW,CAACS,KAApB;AACD,KAnB+B,CAqBhC;AACA;AACA;AACA;AACA;AACA;;;AACA,QACEN,OAAO,CAACI,MAAR,GAAiB,CAAjB,KACCF,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,IAD/B,KAEAG,KAAK,CAACI,IAAN,KAAe,MAHjB,EAIE;AACAT,MAAAA,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAAP,GAA8BJ,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAAP,CAA4BQ,OAA5B,CAC5B,aAD4B,EAE5B,GAF4B,CAA9B;AAIAV,MAAAA,MAAM,GAAG,GAAT;AACD;;AAEDF,IAAAA,OAAO,CAACG,IAAR,CAAaP,OAAO,CAACW,MAAR,CAAeF,KAAf,EAAsBV,MAAtB,EAA8BC,OAA9B,EAAuC;AAACM,MAAAA,MAAD;AAASI,MAAAA;AAAT,KAAvC,CAAb;AAEAJ,IAAAA,MAAM,GAAGF,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAAP,CAA4BS,KAA5B,CAAkC,CAAC,CAAnC,CAAT;AACD;;AAEDf,EAAAA,UAAU,CAACgB,GAAX;AAEA,SAAOd,OAAO,CAACe,IAAR,CAAa,EAAb,CAAP;AACD","sourcesContent":["/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  /** @type {Array.<string>} */\n  const results = []\n  let index = -1\n  let before = safeOptions.before\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: ''\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n    }\n\n    results.push(context.handle(child, parent, context, {before, after}))\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n"]},"metadata":{},"sourceType":"module"}
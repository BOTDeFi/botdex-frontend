{"ast":null,"code":"/* globals chrome: false */\n\n/* globals __dirname: false */\n\n/* globals require: false */\n\n/* globals Buffer: false */\n\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\nvar Typo;\n\n(function () {\n  \"use strict\";\n  /**\n   * Typo constructor.\n   *\n   * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n   *                              \"en_US\". This is only used to auto-load dictionaries.\n   * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .aff\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n   * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .dic\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n   * @param {Object} [settings]   Constructor settings. Available properties are:\n   *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n   *                              environment.\n   *                              {Object} [flags]: flag information.\n   *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n   *                              asynchronously.\n   *                              {Function} [loadedCallback]: Called when both affData and wordsData\n   *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n   *                              is the instantiated Typo object.\n   *\n   * @returns {Typo} A Typo object.\n   */\n\n  Typo = function (dictionary, affData, wordsData, settings) {\n    settings = settings || {};\n    this.dictionary = null;\n    this.rules = {};\n    this.dictionaryTable = {};\n    this.compoundRules = [];\n    this.compoundRuleCodes = {};\n    this.replacementTable = [];\n    this.flags = settings.flags || {};\n    this.memoized = {};\n    this.loaded = false;\n    var self = this;\n    var path; // Loop-control variables.\n\n    var i, j, _len, _jlen;\n\n    if (dictionary) {\n      self.dictionary = dictionary; // If the data is preloaded, just setup the Typo object.\n\n      if (affData && wordsData) {\n        setup();\n      } // Loading data for Chrome extentions.\n      else if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n          if (settings.dictionaryPath) {\n            path = settings.dictionaryPath;\n          } else {\n            path = \"typo/dictionaries\";\n          }\n\n          if (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n          if (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n        } else {\n          if (settings.dictionaryPath) {\n            path = settings.dictionaryPath;\n          } else if (typeof __dirname !== 'undefined') {\n            path = __dirname + '/dictionaries';\n          } else {\n            path = './dictionaries';\n          }\n\n          if (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n          if (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n        }\n    }\n\n    function readDataFile(url, setFunc) {\n      var response = self._readFile(url, null, settings.asyncLoad);\n\n      if (settings.asyncLoad) {\n        response.then(function (data) {\n          setFunc(data);\n        });\n      } else {\n        setFunc(response);\n      }\n    }\n\n    function setAffData(data) {\n      affData = data;\n\n      if (wordsData) {\n        setup();\n      }\n    }\n\n    function setWordsData(data) {\n      wordsData = data;\n\n      if (affData) {\n        setup();\n      }\n    }\n\n    function setup() {\n      self.rules = self._parseAFF(affData); // Save the rule codes that are used in compound rules.\n\n      self.compoundRuleCodes = {};\n\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var rule = self.compoundRules[i];\n\n        for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n          self.compoundRuleCodes[rule[j]] = [];\n        }\n      } // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n      // will do the work of saving the list of words that are compound-only.\n\n\n      if (\"ONLYINCOMPOUND\" in self.flags) {\n        self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n      }\n\n      self.dictionaryTable = self._parseDIC(wordsData); // Get rid of any codes from the compound rule codes that are never used \n      // (or that were special regex characters).  Not especially necessary... \n\n      for (i in self.compoundRuleCodes) {\n        if (self.compoundRuleCodes[i].length === 0) {\n          delete self.compoundRuleCodes[i];\n        }\n      } // Build the full regular expressions for each compound rule.\n      // I have a feeling (but no confirmation yet) that this method of \n      // testing for compound words is probably slow.\n\n\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var ruleText = self.compoundRules[i];\n        var expressionText = \"\";\n\n        for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n          var character = ruleText[j];\n\n          if (character in self.compoundRuleCodes) {\n            expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n          } else {\n            expressionText += character;\n          }\n        }\n\n        self.compoundRules[i] = new RegExp(expressionText, \"i\");\n      }\n\n      self.loaded = true;\n\n      if (settings.asyncLoad && settings.loadedCallback) {\n        settings.loadedCallback(self);\n      }\n    }\n\n    return this;\n  };\n\n  Typo.prototype = {\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load: function (obj) {\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          this[i] = obj[i];\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Read the contents of a file.\n     * \n     * @param {String} path The path (relative) to the file.\n     * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     *        files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     *          always returned.\n     */\n    _readFile: function (path, charset, async) {\n      charset = charset || \"utf8\";\n\n      if (typeof XMLHttpRequest !== 'undefined') {\n        var promise;\n        var req = new XMLHttpRequest();\n        req.open(\"GET\", path, async);\n\n        if (async) {\n          promise = new Promise(function (resolve, reject) {\n            req.onload = function () {\n              if (req.status === 200) {\n                resolve(req.responseText);\n              } else {\n                reject(req.statusText);\n              }\n            };\n\n            req.onerror = function () {\n              reject(req.statusText);\n            };\n          });\n        }\n\n        if (req.overrideMimeType) req.overrideMimeType(\"text/plain; charset=\" + charset);\n        req.send(null);\n        return async ? promise : req.responseText;\n      } else if (typeof require !== 'undefined') {\n        // Node.js\n        var fs = require(\"fs\");\n\n        try {\n          if (fs.existsSync(path)) {\n            return fs.readFileSync(path, charset);\n          } else {\n            console.log(\"Path \" + path + \" does not exist.\");\n          }\n        } catch (e) {\n          console.log(e);\n          return '';\n        }\n      }\n    },\n\n    /**\n     * Parse the rules out from a .aff file.\n     *\n     * @param {String} data The contents of the affix file.\n     * @returns object The rules from the file.\n     */\n    _parseAFF: function (data) {\n      var rules = {};\n      var line, subline, numEntries, lineParts;\n\n      var i, j, _len, _jlen; // Remove comment lines\n\n\n      data = this._removeAffixComments(data);\n      var lines = data.split(/\\r?\\n/);\n\n      for (i = 0, _len = lines.length; i < _len; i++) {\n        line = lines[i];\n        var definitionParts = line.split(/\\s+/);\n        var ruleType = definitionParts[0];\n\n        if (ruleType == \"PFX\" || ruleType == \"SFX\") {\n          var ruleCode = definitionParts[1];\n          var combineable = definitionParts[2];\n          numEntries = parseInt(definitionParts[3], 10);\n          var entries = [];\n\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            subline = lines[j];\n            lineParts = subline.split(/\\s+/);\n            var charactersToRemove = lineParts[2];\n            var additionParts = lineParts[3].split(\"/\");\n            var charactersToAdd = additionParts[0];\n            if (charactersToAdd === \"0\") charactersToAdd = \"\";\n            var continuationClasses = this.parseRuleCodes(additionParts[1]);\n            var regexToMatch = lineParts[4];\n            var entry = {};\n            entry.add = charactersToAdd;\n            if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n\n            if (regexToMatch !== \".\") {\n              if (ruleType === \"SFX\") {\n                entry.match = new RegExp(regexToMatch + \"$\");\n              } else {\n                entry.match = new RegExp(\"^\" + regexToMatch);\n              }\n            }\n\n            if (charactersToRemove != \"0\") {\n              if (ruleType === \"SFX\") {\n                entry.remove = new RegExp(charactersToRemove + \"$\");\n              } else {\n                entry.remove = charactersToRemove;\n              }\n            }\n\n            entries.push(entry);\n          }\n\n          rules[ruleCode] = {\n            \"type\": ruleType,\n            \"combineable\": combineable == \"Y\",\n            \"entries\": entries\n          };\n          i += numEntries;\n        } else if (ruleType === \"COMPOUNDRULE\") {\n          numEntries = parseInt(definitionParts[1], 10);\n\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            line = lines[j];\n            lineParts = line.split(/\\s+/);\n            this.compoundRules.push(lineParts[1]);\n          }\n\n          i += numEntries;\n        } else if (ruleType === \"REP\") {\n          lineParts = line.split(/\\s+/);\n\n          if (lineParts.length === 3) {\n            this.replacementTable.push([lineParts[1], lineParts[2]]);\n          }\n        } else {\n          // ONLYINCOMPOUND\n          // COMPOUNDMIN\n          // FLAG\n          // KEEPCASE\n          // NEEDAFFIX\n          this.flags[ruleType] = definitionParts[1];\n        }\n      }\n\n      return rules;\n    },\n\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from an affix file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeAffixComments: function (data) {\n      // Remove comments\n      // This used to remove any string starting with '#' up to the end of the line,\n      // but some COMPOUNDRULE definitions include '#' as part of the rule.\n      // I haven't seen any affix files that use comments on the same line as real data,\n      // so I don't think this will break anything.\n      data = data.replace(/^\\s*#.*$/mg, \"\"); // Trim each line\n\n      data = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, ''); // Remove blank lines.\n\n      data = data.replace(/\\n{2,}/g, \"\\n\"); // Trim the entire string\n\n      data = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n      return data;\n    },\n\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n     */\n    _parseDIC: function (data) {\n      data = this._removeDicComments(data);\n      var lines = data.split(/\\r?\\n/);\n      var dictionaryTable = {};\n\n      function addWord(word, rules) {\n        // Some dictionaries will list the same word multiple times with different rule sets.\n        if (!dictionaryTable.hasOwnProperty(word)) {\n          dictionaryTable[word] = null;\n        }\n\n        if (rules.length > 0) {\n          if (dictionaryTable[word] === null) {\n            dictionaryTable[word] = [];\n          }\n\n          dictionaryTable[word].push(rules);\n        }\n      } // The first line is the number of words in the dictionary.\n\n\n      for (var i = 1, _len = lines.length; i < _len; i++) {\n        var line = lines[i];\n\n        if (!line) {\n          // Ignore empty lines.\n          continue;\n        }\n\n        var parts = line.split(\"/\", 2);\n        var word = parts[0]; // Now for each affix rule, generate that form of the word.\n\n        if (parts.length > 1) {\n          var ruleCodesArray = this.parseRuleCodes(parts[1]); // Save the ruleCodes for compound word situations.\n\n          if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n            addWord(word, ruleCodesArray);\n          }\n\n          for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n            var code = ruleCodesArray[j];\n            var rule = this.rules[code];\n\n            if (rule) {\n              var newWords = this._applyRule(word, rule);\n\n              for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                var newWord = newWords[ii];\n                addWord(newWord, []);\n\n                if (rule.combineable) {\n                  for (var k = j + 1; k < _jlen; k++) {\n                    var combineCode = ruleCodesArray[k];\n                    var combineRule = this.rules[combineCode];\n\n                    if (combineRule) {\n                      if (combineRule.combineable && rule.type != combineRule.type) {\n                        var otherNewWords = this._applyRule(newWord, combineRule);\n\n                        for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                          var otherNewWord = otherNewWords[iii];\n                          addWord(otherNewWord, []);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (code in this.compoundRuleCodes) {\n              this.compoundRuleCodes[code].push(word);\n            }\n          }\n        } else {\n          addWord(word.trim(), []);\n        }\n      }\n\n      return dictionaryTable;\n    },\n\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments: function (data) {\n      // I can't find any official documentation on it, but at least the de_DE\n      // dictionary uses tab-indented lines as comments.\n      // Remove comments\n      data = data.replace(/^\\t.*$/mg, \"\");\n      return data;\n    },\n    parseRuleCodes: function (textCodes) {\n      if (!textCodes) {\n        return [];\n      } else if (!(\"FLAG\" in this.flags)) {\n        return textCodes.split(\"\");\n      } else if (this.flags.FLAG === \"long\") {\n        var flags = [];\n\n        for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n          flags.push(textCodes.substr(i, 2));\n        }\n\n        return flags;\n      } else if (this.flags.FLAG === \"num\") {\n        return textCodes.split(\",\");\n      }\n    },\n\n    /**\n     * Applies an affix rule to a word.\n     *\n     * @param {String} word The base word.\n     * @param {Object} rule The affix rule.\n     * @returns {String[]} The new words generated by the rule.\n     */\n    _applyRule: function (word, rule) {\n      var entries = rule.entries;\n      var newWords = [];\n\n      for (var i = 0, _len = entries.length; i < _len; i++) {\n        var entry = entries[i];\n\n        if (!entry.match || word.match(entry.match)) {\n          var newWord = word;\n\n          if (entry.remove) {\n            newWord = newWord.replace(entry.remove, \"\");\n          }\n\n          if (rule.type === \"SFX\") {\n            newWord = newWord + entry.add;\n          } else {\n            newWord = entry.add + newWord;\n          }\n\n          newWords.push(newWord);\n\n          if (\"continuationClasses\" in entry) {\n            for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n              var continuationRule = this.rules[entry.continuationClasses[j]];\n\n              if (continuationRule) {\n                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n              }\n              /*\n              else {\n              \t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n              \t// I think the author mistakenly supplied lower-case rule codes instead \n              \t// of upper-case.\n              }\n              */\n\n            }\n          }\n        }\n      }\n\n      return newWords;\n    },\n\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {String} aWord The word to check.\n     * @returns {Boolean}\n     */\n    check: function (aWord) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      } // Remove leading and trailing whitespace\n\n\n      var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n      if (this.checkExact(trimmedWord)) {\n        return true;\n      } // The exact word is not in the dictionary.\n\n\n      if (trimmedWord.toUpperCase() === trimmedWord) {\n        // The word was supplied in all uppercase.\n        // Check for a capitalized form of the word.\n        var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n\n        if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n\n        if (this.checkExact(capitalizedWord)) {\n          // The all-caps word is a capitalized word spelled correctly.\n          return true;\n        }\n\n        if (this.checkExact(trimmedWord.toLowerCase())) {\n          // The all-caps is a lowercase word spelled correctly.\n          return true;\n        }\n      }\n\n      var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n\n      if (uncapitalizedWord !== trimmedWord) {\n        if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        } // Check for an uncapitalized form\n\n\n        if (this.checkExact(uncapitalizedWord)) {\n          // The word is spelled correctly but with the first letter capitalized.\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Checks whether a word exists in the current dictionary.\n     *\n     * @param {String} word The word to check.\n     * @returns {Boolean}\n     */\n    checkExact: function (word) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      var ruleCodes = this.dictionaryTable[word];\n\n      var i, _len;\n\n      if (typeof ruleCodes === 'undefined') {\n        // Check if this might be a compound word.\n        if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n          for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n            if (word.match(this.compoundRules[i])) {\n              return true;\n            }\n          }\n        }\n      } else if (ruleCodes === null) {\n        // a null (but not undefined) value for an entry in the dictionary table\n        // means that the word is in the dictionary but has no flags.\n        return true;\n      } else if (typeof ruleCodes === 'object') {\n        // this.dictionary['hasOwnProperty'] will be a function.\n        for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n          if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {String} word The word in question.\n     * @param {String} flag The flag in question.\n     * @return {Boolean}\n     */\n    hasFlag: function (word, flag, wordFlags) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      if (flag in this.flags) {\n        if (typeof wordFlags === 'undefined') {\n          wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n        }\n\n        if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Returns a list of suggestions for a misspelled word.\n     *\n     * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n     * This suggestor is primitive, but it works.\n     *\n     * @param {String} word The misspelling.\n     * @param {Number} [limit=5] The maximum number of suggestions to return.\n     * @returns {String[]} The array of suggestions.\n     */\n    alphabet: \"\",\n    suggest: function (word, limit) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      limit = limit || 5;\n\n      if (this.memoized.hasOwnProperty(word)) {\n        var memoizedLimit = this.memoized[word]['limit']; // Only return the cached list if it's big enough or if there weren't enough suggestions\n        // to fill a smaller limit.\n\n        if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n          return this.memoized[word]['suggestions'].slice(0, limit);\n        }\n      }\n\n      if (this.check(word)) return []; // Check the replacement table.\n\n      for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n        var replacementEntry = this.replacementTable[i];\n\n        if (word.indexOf(replacementEntry[0]) !== -1) {\n          var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n\n          if (this.check(correctedWord)) {\n            return [correctedWord];\n          }\n        }\n      }\n\n      var self = this;\n      self.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n      /*\n      if (!self.alphabet) {\n      \t// Use the alphabet as implicitly defined by the words in the dictionary.\n      \tvar alphaHash = {};\n      \t\n      \tfor (var i in self.dictionaryTable) {\n      \t\tfor (var j = 0, _len = i.length; j < _len; j++) {\n      \t\t\talphaHash[i[j]] = true;\n      \t\t}\n      \t}\n      \t\n      \tfor (var i in alphaHash) {\n      \t\tself.alphabet += i;\n      \t}\n      \t\n      \tvar alphaArray = self.alphabet.split(\"\");\n      \talphaArray.sort();\n      \tself.alphabet = alphaArray.join(\"\");\n      }\n      */\n\n      /**\n       * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n       * The value of each entry is the number of unique ways that the resulting word can be made.\n       *\n       * @arg mixed words Either a hash keyed by words or a string word to operate on.\n       * @arg bool known_only Whether this function should ignore strings that are not in the dictionary.\n       */\n\n      function edits1(words, known_only) {\n        var rv = {};\n\n        var i, j, _iilen, _len, _jlen, _edit;\n\n        var alphabetLength = self.alphabet.length;\n\n        if (typeof words == 'string') {\n          var word = words;\n          words = {};\n          words[word] = true;\n        }\n\n        for (var word in words) {\n          for (i = 0, _len = word.length + 1; i < _len; i++) {\n            var s = [word.substring(0, i), word.substring(i)]; // Remove a letter.\n\n            if (s[1]) {\n              _edit = s[0] + s[1].substring(1);\n\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            } // Transpose letters\n            // Eliminate transpositions of identical letters\n\n\n            if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n              _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            }\n\n            if (s[1]) {\n              // Replace a letter with another letter.\n              var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n\n              for (j = 0; j < alphabetLength; j++) {\n                var replacementLetter = self.alphabet[j]; // Set the case of the replacement letter to the same as the letter being replaced.\n\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                } // Eliminate replacement of a letter by itself\n\n\n                if (replacementLetter != s[1].substring(0, 1)) {\n                  _edit = s[0] + replacementLetter + s[1].substring(1);\n\n                  if (!known_only || self.check(_edit)) {\n                    if (!(_edit in rv)) {\n                      rv[_edit] = 1;\n                    } else {\n                      rv[_edit] += 1;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (s[1]) {\n              // Add a letter between each letter.\n              for (j = 0; j < alphabetLength; j++) {\n                // If the letters on each side are capitalized, capitalize the replacement.\n                var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n                var replacementLetter = self.alphabet[j];\n\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                }\n\n                _edit = s[0] + replacementLetter + s[1];\n\n                if (!known_only || self.check(_edit)) {\n                  if (!(_edit in rv)) {\n                    rv[_edit] = 1;\n                  } else {\n                    rv[_edit] += 1;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        return rv;\n      }\n\n      function correct(word) {\n        // Get the edit-distance-1 and edit-distance-2 forms of this word.\n        var ed1 = edits1(word);\n        var ed2 = edits1(ed1, true); // Sort the edits based on how many different ways they were created.\n\n        var weighted_corrections = ed2;\n\n        for (var ed1word in ed1) {\n          if (!self.check(ed1word)) {\n            continue;\n          }\n\n          if (ed1word in weighted_corrections) {\n            weighted_corrections[ed1word] += ed1[ed1word];\n          } else {\n            weighted_corrections[ed1word] = ed1[ed1word];\n          }\n        }\n\n        var i, _len;\n\n        var sorted_corrections = [];\n\n        for (i in weighted_corrections) {\n          if (weighted_corrections.hasOwnProperty(i)) {\n            sorted_corrections.push([i, weighted_corrections[i]]);\n          }\n        }\n\n        function sorter(a, b) {\n          var a_val = a[1];\n          var b_val = b[1];\n\n          if (a_val < b_val) {\n            return -1;\n          } else if (a_val > b_val) {\n            return 1;\n          } // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n\n\n          return b[0].localeCompare(a[0]);\n        }\n\n        sorted_corrections.sort(sorter).reverse();\n        var rv = [];\n        var capitalization_scheme = \"lowercase\";\n\n        if (word.toUpperCase() === word) {\n          capitalization_scheme = \"uppercase\";\n        } else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n          capitalization_scheme = \"capitalized\";\n        }\n\n        var working_limit = limit;\n\n        for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n          if (\"uppercase\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n          } else if (\"capitalized\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n          }\n\n          if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) == -1) {\n            rv.push(sorted_corrections[i][0]);\n          } else {\n            // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n            working_limit++;\n          }\n        }\n\n        return rv;\n      }\n\n      this.memoized[word] = {\n        'suggestions': correct(word),\n        'limit': limit\n      };\n      return this.memoized[word]['suggestions'];\n    }\n  };\n})(); // Support for use as a node.js module.\n\n\nif (typeof module !== 'undefined') {\n  module.exports = Typo;\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/typo-js/typo.js"],"names":["Typo","dictionary","affData","wordsData","settings","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","flags","memoized","loaded","self","path","i","j","_len","_jlen","setup","window","chrome","extension","dictionaryPath","readDataFile","getURL","setAffData","setWordsData","__dirname","url","setFunc","response","_readFile","asyncLoad","then","data","_parseAFF","length","rule","ONLYINCOMPOUND","_parseDIC","ruleText","expressionText","character","join","RegExp","loadedCallback","prototype","load","obj","hasOwnProperty","charset","async","XMLHttpRequest","promise","req","open","Promise","resolve","reject","onload","status","responseText","statusText","onerror","overrideMimeType","send","require","fs","existsSync","readFileSync","console","log","e","line","subline","numEntries","lineParts","_removeAffixComments","lines","split","definitionParts","ruleType","ruleCode","combineable","parseInt","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","replace","_removeDicComments","addWord","word","parts","ruleCodesArray","indexOf","NEEDAFFIX","code","newWords","_applyRule","ii","_iilen","newWord","k","combineCode","combineRule","type","otherNewWords","iii","_iiilen","otherNewWord","trim","textCodes","FLAG","substr","continuationRule","concat","check","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","uncapitalizedWord","ruleCodes","COMPOUNDMIN","flag","wordFlags","Array","apply","alphabet","suggest","limit","memoizedLimit","slice","replacementEntry","correctedWord","edits1","words","known_only","rv","_edit","alphabetLength","s","lettercase","replacementLetter","correct","ed1","ed2","weighted_corrections","ed1word","sorted_corrections","sorter","a","b","a_val","b_val","localeCompare","sort","reverse","capitalization_scheme","working_limit","Math","min","module","exports"],"mappings":"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","sourcesContent":["/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\n\nvar Typo;\n\n(function () {\n\"use strict\";\n\n/**\n * Typo constructor.\n *\n * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n *                              \"en_US\". This is only used to auto-load dictionaries.\n * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .aff\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .dic\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n * @param {Object} [settings]   Constructor settings. Available properties are:\n *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n *                              environment.\n *                              {Object} [flags]: flag information.\n *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n *                              asynchronously.\n *                              {Function} [loadedCallback]: Called when both affData and wordsData\n *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n *                              is the instantiated Typo object.\n *\n * @returns {Typo} A Typo object.\n */\n\nTypo = function (dictionary, affData, wordsData, settings) {\n\tsettings = settings || {};\n\n\tthis.dictionary = null;\n\t\n\tthis.rules = {};\n\tthis.dictionaryTable = {};\n\t\n\tthis.compoundRules = [];\n\tthis.compoundRuleCodes = {};\n\t\n\tthis.replacementTable = [];\n\t\n\tthis.flags = settings.flags || {}; \n\t\n\tthis.memoized = {};\n\n\tthis.loaded = false;\n\t\n\tvar self = this;\n\t\n\tvar path;\n\t\n\t// Loop-control variables.\n\tvar i, j, _len, _jlen;\n\t\n\tif (dictionary) {\n\t\tself.dictionary = dictionary;\n\t\t\n\t\t// If the data is preloaded, just setup the Typo object.\n\t\tif (affData && wordsData) {\n\t\t\tsetup();\n\t\t}\n\t\t// Loading data for Chrome extentions.\n\t\telse if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = \"typo/dictionaries\";\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n\t\t\tif (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n\t\t}\n\t\telse {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse if (typeof __dirname !== 'undefined') {\n\t\t\t\tpath = __dirname + '/dictionaries';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = './dictionaries';\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n\t\t\tif (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n\t\t}\n\t}\n\t\n\tfunction readDataFile(url, setFunc) {\n\t\tvar response = self._readFile(url, null, settings.asyncLoad);\n\t\t\n\t\tif (settings.asyncLoad) {\n\t\t\tresponse.then(function(data) {\n\t\t\t\tsetFunc(data);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tsetFunc(response);\n\t\t}\n\t}\n\n\tfunction setAffData(data) {\n\t\taffData = data;\n\n\t\tif (wordsData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setWordsData(data) {\n\t\twordsData = data;\n\n\t\tif (affData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setup() {\n\t\tself.rules = self._parseAFF(affData);\n\t\t\n\t\t// Save the rule codes that are used in compound rules.\n\t\tself.compoundRuleCodes = {};\n\t\t\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar rule = self.compoundRules[i];\n\t\t\t\n\t\t\tfor (j = 0, _jlen = rule.length; j < _jlen; j++) {\n\t\t\t\tself.compoundRuleCodes[rule[j]] = [];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n\t\t// will do the work of saving the list of words that are compound-only.\n\t\tif (\"ONLYINCOMPOUND\" in self.flags) {\n\t\t\tself.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n\t\t}\n\t\t\n\t\tself.dictionaryTable = self._parseDIC(wordsData);\n\t\t\n\t\t// Get rid of any codes from the compound rule codes that are never used \n\t\t// (or that were special regex characters).  Not especially necessary... \n\t\tfor (i in self.compoundRuleCodes) {\n\t\t\tif (self.compoundRuleCodes[i].length === 0) {\n\t\t\t\tdelete self.compoundRuleCodes[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build the full regular expressions for each compound rule.\n\t\t// I have a feeling (but no confirmation yet) that this method of \n\t\t// testing for compound words is probably slow.\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar ruleText = self.compoundRules[i];\n\t\t\t\n\t\t\tvar expressionText = \"\";\n\t\t\t\n\t\t\tfor (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n\t\t\t\tvar character = ruleText[j];\n\t\t\t\t\n\t\t\t\tif (character in self.compoundRuleCodes) {\n\t\t\t\t\texpressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texpressionText += character;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tself.compoundRules[i] = new RegExp(expressionText, \"i\");\n\t\t}\n\t\t\n\t\tself.loaded = true;\n\t\t\n\t\tif (settings.asyncLoad && settings.loadedCallback) {\n\t\t\tsettings.loadedCallback(self);\n\t\t}\n\t}\n\t\n\treturn this;\n};\n\nTypo.prototype = {\n\t/**\n\t * Loads a Typo instance from a hash of all of the Typo properties.\n\t *\n\t * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n\t */\n\t\n\tload : function (obj) {\n\t\tfor (var i in obj) {\n\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\tthis[i] = obj[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t * Read the contents of a file.\n\t * \n\t * @param {String} path The path (relative) to the file.\n\t * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n\t * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n\t *        files are read synchronously.\n\t * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n\t *          always returned.\n\t */\n\t\n\t_readFile : function (path, charset, async) {\n\t\tcharset = charset || \"utf8\";\n\t\t\n\t\tif (typeof XMLHttpRequest !== 'undefined') {\n\t\t\tvar promise;\n\t\t\tvar req = new XMLHttpRequest();\n\t\t\treq.open(\"GET\", path, async);\n\t\t\t\n\t\t\tif (async) {\n\t\t\t\tpromise = new Promise(function(resolve, reject) {\n\t\t\t\t\treq.onload = function() {\n\t\t\t\t\t\tif (req.status === 200) {\n\t\t\t\t\t\t\tresolve(req.responseText);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\treq.onerror = function() {\n\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tif (req.overrideMimeType)\n\t\t\t\treq.overrideMimeType(\"text/plain; charset=\" + charset);\n\t\t\n\t\t\treq.send(null);\n\t\t\t\n\t\t\treturn async ? promise : req.responseText;\n\t\t}\n\t\telse if (typeof require !== 'undefined') {\n\t\t\t// Node.js\n\t\t\tvar fs = require(\"fs\");\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (fs.existsSync(path)) {\n\t\t\t\t\treturn fs.readFileSync(path, charset);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(\"Path \" + path + \" does not exist.\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Parse the rules out from a .aff file.\n\t *\n\t * @param {String} data The contents of the affix file.\n\t * @returns object The rules from the file.\n\t */\n\t\n\t_parseAFF : function (data) {\n\t\tvar rules = {};\n\t\t\n\t\tvar line, subline, numEntries, lineParts;\n\t\tvar i, j, _len, _jlen;\n\t\t\n\t\t// Remove comment lines\n\t\tdata = this._removeAffixComments(data);\n\t\t\n\t\tvar lines = data.split(/\\r?\\n/);\n\t\t\n\t\tfor (i = 0, _len = lines.length; i < _len; i++) {\n\t\t\tline = lines[i];\n\t\t\t\n\t\t\tvar definitionParts = line.split(/\\s+/);\n\t\t\t\n\t\t\tvar ruleType = definitionParts[0];\n\t\t\t\n\t\t\tif (ruleType == \"PFX\" || ruleType == \"SFX\") {\n\t\t\t\tvar ruleCode = definitionParts[1];\n\t\t\t\tvar combineable = definitionParts[2];\n\t\t\t\tnumEntries = parseInt(definitionParts[3], 10);\n\t\t\t\t\n\t\t\t\tvar entries = [];\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tsubline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = subline.split(/\\s+/);\n\t\t\t\t\tvar charactersToRemove = lineParts[2];\n\t\t\t\t\t\n\t\t\t\t\tvar additionParts = lineParts[3].split(\"/\");\n\t\t\t\t\t\n\t\t\t\t\tvar charactersToAdd = additionParts[0];\n\t\t\t\t\tif (charactersToAdd === \"0\") charactersToAdd = \"\";\n\t\t\t\t\t\n\t\t\t\t\tvar continuationClasses = this.parseRuleCodes(additionParts[1]);\n\t\t\t\t\t\n\t\t\t\t\tvar regexToMatch = lineParts[4];\n\t\t\t\t\t\n\t\t\t\t\tvar entry = {};\n\t\t\t\t\tentry.add = charactersToAdd;\n\t\t\t\t\t\n\t\t\t\t\tif (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n\t\t\t\t\t\n\t\t\t\t\tif (regexToMatch !== \".\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.match = new RegExp(regexToMatch + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.match = new RegExp(\"^\" + regexToMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (charactersToRemove != \"0\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.remove = new RegExp(charactersToRemove  + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.remove = charactersToRemove;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trules[ruleCode] = { \"type\" : ruleType, \"combineable\" : (combineable == \"Y\"), \"entries\" : entries };\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"COMPOUNDRULE\") {\n\t\t\t\tnumEntries = parseInt(definitionParts[1], 10);\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\tthis.compoundRules.push(lineParts[1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"REP\") {\n\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\n\t\t\t\tif (lineParts.length === 3) {\n\t\t\t\t\tthis.replacementTable.push([ lineParts[1], lineParts[2] ]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// ONLYINCOMPOUND\n\t\t\t\t// COMPOUNDMIN\n\t\t\t\t// FLAG\n\t\t\t\t// KEEPCASE\n\t\t\t\t// NEEDAFFIX\n\t\t\t\t\n\t\t\t\tthis.flags[ruleType] = definitionParts[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn rules;\n\t},\n\t\n\t/**\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\n\t *\n\t * @param {String} data The data from an affix file.\n\t * @return {String} The cleaned-up data.\n\t */\n\t\n\t_removeAffixComments : function (data) {\n\t\t// Remove comments\n\t\t// This used to remove any string starting with '#' up to the end of the line,\n\t\t// but some COMPOUNDRULE definitions include '#' as part of the rule.\n\t\t// I haven't seen any affix files that use comments on the same line as real data,\n\t\t// so I don't think this will break anything.\n\t\tdata = data.replace(/^\\s*#.*$/mg, \"\");\n\t\t\n\t\t// Trim each line\n\t\tdata = data.replace(/^\\s\\s*/m, '').replace(/\\s\\s*$/m, '');\n\t\t\n\t\t// Remove blank lines.\n\t\tdata = data.replace(/\\n{2,}/g, \"\\n\");\n\t\t\n\t\t// Trim the entire string\n\t\tdata = data.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t\n\t\treturn data;\n\t},\n\t\n\t/**\n\t * Parses the words out from the .dic file.\n\t *\n\t * @param {String} data The data from the dictionary file.\n\t * @returns object The lookup table containing all of the words and\n\t *                 word forms from the dictionary.\n\t */\n\t\n\t_parseDIC : function (data) {\n\t\tdata = this._removeDicComments(data);\n\t\t\n\t\tvar lines = data.split(/\\r?\\n/);\n\t\tvar dictionaryTable = {};\n\t\t\n\t\tfunction addWord(word, rules) {\n\t\t\t// Some dictionaries will list the same word multiple times with different rule sets.\n\t\t\tif (!dictionaryTable.hasOwnProperty(word)) {\n\t\t\t\tdictionaryTable[word] = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (rules.length > 0) {\n\t\t\t\tif (dictionaryTable[word] === null) {\n\t\t\t\t\tdictionaryTable[word] = [];\n\t\t\t\t}\n\n\t\t\t\tdictionaryTable[word].push(rules);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// The first line is the number of words in the dictionary.\n\t\tfor (var i = 1, _len = lines.length; i < _len; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tif (!line) {\n\t\t\t\t// Ignore empty lines.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar parts = line.split(\"/\", 2);\n\t\t\t\n\t\t\tvar word = parts[0];\n\n\t\t\t// Now for each affix rule, generate that form of the word.\n\t\t\tif (parts.length > 1) {\n\t\t\t\tvar ruleCodesArray = this.parseRuleCodes(parts[1]);\n\t\t\t\t\n\t\t\t\t// Save the ruleCodes for compound word situations.\n\t\t\t\tif (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n\t\t\t\t\taddWord(word, ruleCodesArray);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n\t\t\t\t\tvar code = ruleCodesArray[j];\n\t\t\t\t\t\n\t\t\t\t\tvar rule = this.rules[code];\n\t\t\t\t\t\n\t\t\t\t\tif (rule) {\n\t\t\t\t\t\tvar newWords = this._applyRule(word, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n\t\t\t\t\t\t\tvar newWord = newWords[ii];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddWord(newWord, []);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (rule.combineable) {\n\t\t\t\t\t\t\t\tfor (var k = j + 1; k < _jlen; k++) {\n\t\t\t\t\t\t\t\t\tvar combineCode = ruleCodesArray[k];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvar combineRule = this.rules[combineCode];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (combineRule) {\n\t\t\t\t\t\t\t\t\t\tif (combineRule.combineable && (rule.type != combineRule.type)) {\n\t\t\t\t\t\t\t\t\t\t\tvar otherNewWords = this._applyRule(newWord, combineRule);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tfor (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar otherNewWord = otherNewWords[iii];\n\t\t\t\t\t\t\t\t\t\t\t\taddWord(otherNewWord, []);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (code in this.compoundRuleCodes) {\n\t\t\t\t\t\tthis.compoundRuleCodes[code].push(word);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddWord(word.trim(), []);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dictionaryTable;\n\t},\n\t\n\t\n\t/**\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\n\t *\n\t * @param {String} data The data from a .dic file.\n\t * @return {String} The cleaned-up data.\n\t */\n\t\n\t_removeDicComments : function (data) {\n\t\t// I can't find any official documentation on it, but at least the de_DE\n\t\t// dictionary uses tab-indented lines as comments.\n\t\t\n\t\t// Remove comments\n\t\tdata = data.replace(/^\\t.*$/mg, \"\");\n\t\t\n\t\treturn data;\n\t},\n\t\n\tparseRuleCodes : function (textCodes) {\n\t\tif (!textCodes) {\n\t\t\treturn [];\n\t\t}\n\t\telse if (!(\"FLAG\" in this.flags)) {\n\t\t\treturn textCodes.split(\"\");\n\t\t}\n\t\telse if (this.flags.FLAG === \"long\") {\n\t\t\tvar flags = [];\n\t\t\t\n\t\t\tfor (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n\t\t\t\tflags.push(textCodes.substr(i, 2));\n\t\t\t}\n\t\t\t\n\t\t\treturn flags;\n\t\t}\n\t\telse if (this.flags.FLAG === \"num\") {\n\t\t\treturn textCodes.split(\",\");\n\t\t}\n\t},\n\t\n\t/**\n\t * Applies an affix rule to a word.\n\t *\n\t * @param {String} word The base word.\n\t * @param {Object} rule The affix rule.\n\t * @returns {String[]} The new words generated by the rule.\n\t */\n\t\n\t_applyRule : function (word, rule) {\n\t\tvar entries = rule.entries;\n\t\tvar newWords = [];\n\t\t\n\t\tfor (var i = 0, _len = entries.length; i < _len; i++) {\n\t\t\tvar entry = entries[i];\n\t\t\t\n\t\t\tif (!entry.match || word.match(entry.match)) {\n\t\t\t\tvar newWord = word;\n\t\t\t\t\n\t\t\t\tif (entry.remove) {\n\t\t\t\t\tnewWord = newWord.replace(entry.remove, \"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rule.type === \"SFX\") {\n\t\t\t\t\tnewWord = newWord + entry.add;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewWord = entry.add + newWord;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnewWords.push(newWord);\n\t\t\t\t\n\t\t\t\tif (\"continuationClasses\" in entry) {\n\t\t\t\t\tfor (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n\t\t\t\t\t\tvar continuationRule = this.rules[entry.continuationClasses[j]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (continuationRule) {\n\t\t\t\t\t\t\tnewWords = newWords.concat(this._applyRule(newWord, continuationRule));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n\t\t\t\t\t\t\t// I think the author mistakenly supplied lower-case rule codes instead \n\t\t\t\t\t\t\t// of upper-case.\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newWords;\n\t},\n\t\n\t/**\n\t * Checks whether a word or a capitalization variant exists in the current dictionary.\n\t * The word is trimmed and several variations of capitalizations are checked.\n\t * If you want to check a word without any changes made to it, call checkExact()\n\t *\n\t * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n\t *\n\t * @param {String} aWord The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheck : function (aWord) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\t\t\n\t\t// Remove leading and trailing whitespace\n\t\tvar trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t\n\t\tif (this.checkExact(trimmedWord)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// The exact word is not in the dictionary.\n\t\tif (trimmedWord.toUpperCase() === trimmedWord) {\n\t\t\t// The word was supplied in all uppercase.\n\t\t\t// Check for a capitalized form of the word.\n\t\t\tvar capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n\t\t\t\n\t\t\tif (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.checkExact(capitalizedWord)) {\n\t\t\t\t// The all-caps word is a capitalized word spelled correctly.\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (this.checkExact(trimmedWord.toLowerCase())) {\n\t\t\t\t// The all-caps is a lowercase word spelled correctly.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n\t\t\n\t\tif (uncapitalizedWord !== trimmedWord) {\n\t\t\tif (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// Check for an uncapitalized form\n\t\t\tif (this.checkExact(uncapitalizedWord)) {\n\t\t\t\t// The word is spelled correctly but with the first letter capitalized.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Checks whether a word exists in the current dictionary.\n\t *\n\t * @param {String} word The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheckExact : function (word) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tvar ruleCodes = this.dictionaryTable[word];\n\t\t\n\t\tvar i, _len;\n\t\t\n\t\tif (typeof ruleCodes === 'undefined') {\n\t\t\t// Check if this might be a compound word.\n\t\t\tif (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n\t\t\t\tfor (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n\t\t\t\t\tif (word.match(this.compoundRules[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ruleCodes === null) {\n\t\t\t// a null (but not undefined) value for an entry in the dictionary table\n\t\t\t// means that the word is in the dictionary but has no flags.\n\t\t\treturn true;\n\t\t}\n\t\telse if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n\t\t\tfor (i = 0, _len = ruleCodes.length; i < _len; i++) {\n\t\t\t\tif (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Looks up whether a given word is flagged with a given flag.\n\t *\n\t * @param {String} word The word in question.\n\t * @param {String} flag The flag in question.\n\t * @return {Boolean}\n\t */\n\t \n\thasFlag : function (word, flag, wordFlags) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tif (flag in this.flags) {\n\t\t\tif (typeof wordFlags === 'undefined') {\n\t\t\t\twordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n\t\t\t}\n\t\t\t\n\t\t\tif (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Returns a list of suggestions for a misspelled word.\n\t *\n\t * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n\t * This suggestor is primitive, but it works.\n\t *\n\t * @param {String} word The misspelling.\n\t * @param {Number} [limit=5] The maximum number of suggestions to return.\n\t * @returns {String[]} The array of suggestions.\n\t */\n\t\n\talphabet : \"\",\n\t\n\tsuggest : function (word, limit) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tlimit = limit || 5;\n\n\t\tif (this.memoized.hasOwnProperty(word)) {\n\t\t\tvar memoizedLimit = this.memoized[word]['limit'];\n\n\t\t\t// Only return the cached list if it's big enough or if there weren't enough suggestions\n\t\t\t// to fill a smaller limit.\n\t\t\tif (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n\t\t\t\treturn this.memoized[word]['suggestions'].slice(0, limit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.check(word)) return [];\n\t\t\n\t\t// Check the replacement table.\n\t\tfor (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n\t\t\tvar replacementEntry = this.replacementTable[i];\n\t\t\t\n\t\t\tif (word.indexOf(replacementEntry[0]) !== -1) {\n\t\t\t\tvar correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n\t\t\t\t\n\t\t\t\tif (this.check(correctedWord)) {\n\t\t\t\t\treturn [ correctedWord ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar self = this;\n\t\tself.alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\t\t\n\t\t/*\n\t\tif (!self.alphabet) {\n\t\t\t// Use the alphabet as implicitly defined by the words in the dictionary.\n\t\t\tvar alphaHash = {};\n\t\t\t\n\t\t\tfor (var i in self.dictionaryTable) {\n\t\t\t\tfor (var j = 0, _len = i.length; j < _len; j++) {\n\t\t\t\t\talphaHash[i[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (var i in alphaHash) {\n\t\t\t\tself.alphabet += i;\n\t\t\t}\n\t\t\t\n\t\t\tvar alphaArray = self.alphabet.split(\"\");\n\t\t\talphaArray.sort();\n\t\t\tself.alphabet = alphaArray.join(\"\");\n\t\t}\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n\t\t * The value of each entry is the number of unique ways that the resulting word can be made.\n\t\t *\n\t\t * @arg mixed words Either a hash keyed by words or a string word to operate on.\n\t\t * @arg bool known_only Whether this function should ignore strings that are not in the dictionary.\n\t\t */\n\t\tfunction edits1(words, known_only) {\n\t\t\tvar rv = {};\n\t\t\t\n\t\t\tvar i, j, _iilen, _len, _jlen, _edit;\n\n\t\t\tvar alphabetLength = self.alphabet.length;\n\t\t\t\n\t\t\tif (typeof words == 'string') {\n\t\t\t\tvar word = words;\n\t\t\t\twords = {};\n\t\t\t\twords[word] = true;\n\t\t\t}\n\n\t\t\tfor (var word in words) {\n\t\t\t\tfor (i = 0, _len = word.length + 1; i < _len; i++) {\n\t\t\t\t\tvar s = [ word.substring(0, i), word.substring(i) ];\n\t\t\t\t\n\t\t\t\t\t// Remove a letter.\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t_edit = s[0] + s[1].substring(1);\n\n\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Transpose letters\n\t\t\t\t\t// Eliminate transpositions of identical letters\n\t\t\t\t\tif (s[1].length > 1 && s[1][1] !== s[1][0]) {\n\t\t\t\t\t\t_edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n\n\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t// Replace a letter with another letter.\n\n\t\t\t\t\t\tvar lettercase = (s[1].substring(0,1).toUpperCase() === s[1].substring(0,1)) ? 'uppercase' : 'lowercase';\n\n\t\t\t\t\t\tfor (j = 0; j < alphabetLength; j++) {\n\t\t\t\t\t\t\tvar replacementLetter = self.alphabet[j];\n\n\t\t\t\t\t\t\t// Set the case of the replacement letter to the same as the letter being replaced.\n\t\t\t\t\t\t\tif ( 'uppercase' === lettercase ) {\n\t\t\t\t\t\t\t\treplacementLetter = replacementLetter.toUpperCase();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eliminate replacement of a letter by itself\n\t\t\t\t\t\t\tif (replacementLetter != s[1].substring(0,1)){\n\t\t\t\t\t\t\t\t_edit = s[0] + replacementLetter + s[1].substring(1);\n\n\t\t\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t// Add a letter between each letter.\n\t\t\t\t\t\tfor (j = 0; j < alphabetLength; j++) {\n\t\t\t\t\t\t\t// If the letters on each side are capitalized, capitalize the replacement.\n\t\t\t\t\t\t\tvar lettercase = (s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0,1).toUpperCase() === s[1].substring(0,1)) ? 'uppercase' : 'lowercase';\n\n\t\t\t\t\t\t\tvar replacementLetter = self.alphabet[j];\n\n\t\t\t\t\t\t\tif ( 'uppercase' === lettercase ) {\n\t\t\t\t\t\t\t\treplacementLetter = replacementLetter.toUpperCase();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_edit = s[0] + replacementLetter + s[1];\n\n\t\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rv;\n\t\t}\n\n\t\tfunction correct(word) {\n\t\t\t// Get the edit-distance-1 and edit-distance-2 forms of this word.\n\t\t\tvar ed1 = edits1(word);\n\t\t\tvar ed2 = edits1(ed1, true);\n\t\t\t\n\t\t\t// Sort the edits based on how many different ways they were created.\n\t\t\tvar weighted_corrections = ed2;\n\t\t\t\n\t\t\tfor (var ed1word in ed1) {\n\t\t\t\tif (!self.check(ed1word)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ed1word in weighted_corrections) {\n\t\t\t\t\tweighted_corrections[ed1word] += ed1[ed1word];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tweighted_corrections[ed1word] = ed1[ed1word];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar i, _len;\n\n\t\t\tvar sorted_corrections = [];\n\t\t\t\n\t\t\tfor (i in weighted_corrections) {\n\t\t\t\tif (weighted_corrections.hasOwnProperty(i)) {\n\t\t\t\t\tsorted_corrections.push([ i, weighted_corrections[i] ]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction sorter(a, b) {\n\t\t\t\tvar a_val = a[1];\n\t\t\t\tvar b_val = b[1];\n\t\t\t\tif (a_val < b_val) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (a_val > b_val) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\t// @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n\t\t\t\treturn b[0].localeCompare(a[0]);\n\t\t\t}\n\t\t\t\n\t\t\tsorted_corrections.sort(sorter).reverse();\n\n\t\t\tvar rv = [];\n\n\t\t\tvar capitalization_scheme = \"lowercase\";\n\t\t\t\n\t\t\tif (word.toUpperCase() === word) {\n\t\t\t\tcapitalization_scheme = \"uppercase\";\n\t\t\t}\n\t\t\telse if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n\t\t\t\tcapitalization_scheme = \"capitalized\";\n\t\t\t}\n\t\t\t\n\t\t\tvar working_limit = limit;\n\n\t\t\tfor (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n\t\t\t\tif (\"uppercase\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n\t\t\t\t}\n\t\t\t\telse if (\"capitalized\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) == -1) {\n\t\t\t\t\trv.push(sorted_corrections[i][0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n\t\t\t\t\tworking_limit++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rv;\n\t\t}\n\t\t\n\t\tthis.memoized[word] = {\n\t\t\t'suggestions': correct(word),\n\t\t\t'limit': limit\n\t\t};\n\n\t\treturn this.memoized[word]['suggestions'];\n\t}\n};\n})();\n\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n\tmodule.exports = Typo;\n}\n"]},"metadata":{},"sourceType":"script"}
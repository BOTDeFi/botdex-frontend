{"ast":null,"code":"\"use strict\";\n\nconst moment = require('moment');\n\nmodule.exports = class {\n  constructor(web3) {\n    this.web3 = web3.constructor.name === 'Web3' ? web3 : {\n      eth: web3\n    };\n    this.checkedBlocks = {};\n    this.savedBlocks = {};\n    this.requests = 0;\n  }\n\n  async getBoundaries() {\n    this.latestBlock = await this.getBlockWrapper('latest');\n    this.firstBlock = await this.getBlockWrapper(1);\n    this.blockTime = (parseInt(this.latestBlock.timestamp, 10) - parseInt(this.firstBlock.timestamp, 10)) / (parseInt(this.latestBlock.number, 10) - 1);\n  }\n\n  async getDate(date, after = true) {\n    if (!moment.isMoment(date)) date = moment(date).utc();\n    if (typeof this.firstBlock == 'undefined' || typeof this.latestBlock == 'undefined' || typeof this.blockTime == 'undefined') await this.getBoundaries();\n    if (date.isBefore(moment.unix(this.firstBlock.timestamp))) return this.returnWrapper(date.format(), 1);\n    if (date.isSameOrAfter(moment.unix(this.latestBlock.timestamp))) return this.returnWrapper(date.format(), this.latestBlock.number);\n    this.checkedBlocks[date.unix()] = [];\n    let predictedBlock = await this.getBlockWrapper(Math.ceil(date.diff(moment.unix(this.firstBlock.timestamp), 'seconds') / this.blockTime));\n    return this.returnWrapper(date.format(), await this.findBetter(date, predictedBlock, after));\n  }\n\n  async getEvery(duration, start, end, every = 1, after = true) {\n    start = moment(start), end = moment(end);\n    let current = start,\n        dates = [];\n\n    while (current.isSameOrBefore(end)) {\n      dates.push(current.format());\n      current.add(every, duration);\n    }\n\n    if (typeof this.firstBlock == 'undefined' || typeof this.latestBlock == 'undefined' || typeof this.blockTime == 'undefined') await this.getBoundaries();\n    return await Promise.all(dates.map(date => this.getDate(date, after)));\n  }\n\n  async findBetter(date, predictedBlock, after, blockTime = this.blockTime) {\n    if (await this.isBetterBlock(date, predictedBlock, after)) return predictedBlock.number;\n    let difference = date.diff(moment.unix(predictedBlock.timestamp), 'seconds');\n    let skip = Math.ceil(difference / (blockTime == 0 ? 1 : blockTime));\n    if (skip == 0) skip = difference < 0 ? -1 : 1;\n    let nextPredictedBlock = await this.getBlockWrapper(this.getNextBlock(date, predictedBlock.number, skip));\n    blockTime = Math.abs((parseInt(predictedBlock.timestamp, 10) - parseInt(nextPredictedBlock.timestamp, 10)) / (parseInt(predictedBlock.number, 10) - parseInt(nextPredictedBlock.number, 10)));\n    return this.findBetter(date, nextPredictedBlock, after, blockTime);\n  }\n\n  async isBetterBlock(date, predictedBlock, after) {\n    let blockTime = moment.unix(predictedBlock.timestamp);\n\n    if (after) {\n      if (blockTime.isBefore(date)) return false;\n      let previousBlock = await this.getBlockWrapper(predictedBlock.number - 1);\n      if (blockTime.isSameOrAfter(date) && moment.unix(previousBlock.timestamp).isBefore(date)) return true;\n    } else {\n      if (blockTime.isSameOrAfter(date)) return false;\n      let nextBlock = await this.getBlockWrapper(predictedBlock.number + 1);\n      if (blockTime.isBefore(date) && moment.unix(nextBlock.timestamp).isSameOrAfter(date)) return true;\n    }\n\n    return false;\n  }\n\n  getNextBlock(date, currentBlock, skip) {\n    let nextBlock = currentBlock + skip;\n    if (this.checkedBlocks[date.unix()].includes(nextBlock)) return this.getNextBlock(date, currentBlock, skip < 0 ? --skip : ++skip);\n    this.checkedBlocks[date.unix()].push(nextBlock);\n    return nextBlock < 1 ? 1 : nextBlock;\n  }\n\n  returnWrapper(date, block) {\n    return {\n      date: date,\n      block: block,\n      timestamp: this.savedBlocks[block].timestamp\n    };\n  }\n\n  async getBlockWrapper(block) {\n    block = block == 'latest' ? await this.web3.eth.getBlockNumber() : block;\n    if (this.savedBlocks[block]) return this.savedBlocks[block];\n    let {\n      timestamp\n    } = await this.web3.eth.getBlock(block);\n    this.savedBlocks[block] = {\n      timestamp: timestamp,\n      number: block\n    };\n    this.requests++;\n    return this.savedBlocks[block];\n  }\n\n};","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/ethereum-block-by-date/lib/ethereum-block-by-date.js"],"names":["moment","require","module","exports","constructor","web3","name","eth","checkedBlocks","savedBlocks","requests","getBoundaries","latestBlock","getBlockWrapper","firstBlock","blockTime","parseInt","timestamp","number","getDate","date","after","isMoment","utc","isBefore","unix","returnWrapper","format","isSameOrAfter","predictedBlock","Math","ceil","diff","findBetter","getEvery","duration","start","end","every","current","dates","isSameOrBefore","push","add","Promise","all","map","isBetterBlock","difference","skip","nextPredictedBlock","getNextBlock","abs","previousBlock","nextBlock","currentBlock","includes","block","getBlockNumber","getBlock"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst moment = require('moment');\n\nmodule.exports = class {\n  constructor(web3) {\n    this.web3 = web3.constructor.name === 'Web3' ? web3 : {\n      eth: web3\n    };\n    this.checkedBlocks = {};\n    this.savedBlocks = {};\n    this.requests = 0;\n  }\n\n  async getBoundaries() {\n    this.latestBlock = await this.getBlockWrapper('latest');\n    this.firstBlock = await this.getBlockWrapper(1);\n    this.blockTime = (parseInt(this.latestBlock.timestamp, 10) - parseInt(this.firstBlock.timestamp, 10)) / (parseInt(this.latestBlock.number, 10) - 1);\n  }\n\n  async getDate(date, after = true) {\n    if (!moment.isMoment(date)) date = moment(date).utc();\n    if (typeof this.firstBlock == 'undefined' || typeof this.latestBlock == 'undefined' || typeof this.blockTime == 'undefined') await this.getBoundaries();\n    if (date.isBefore(moment.unix(this.firstBlock.timestamp))) return this.returnWrapper(date.format(), 1);\n    if (date.isSameOrAfter(moment.unix(this.latestBlock.timestamp))) return this.returnWrapper(date.format(), this.latestBlock.number);\n    this.checkedBlocks[date.unix()] = [];\n    let predictedBlock = await this.getBlockWrapper(Math.ceil(date.diff(moment.unix(this.firstBlock.timestamp), 'seconds') / this.blockTime));\n    return this.returnWrapper(date.format(), await this.findBetter(date, predictedBlock, after));\n  }\n\n  async getEvery(duration, start, end, every = 1, after = true) {\n    start = moment(start), end = moment(end);\n    let current = start,\n        dates = [];\n\n    while (current.isSameOrBefore(end)) {\n      dates.push(current.format());\n      current.add(every, duration);\n    }\n\n    if (typeof this.firstBlock == 'undefined' || typeof this.latestBlock == 'undefined' || typeof this.blockTime == 'undefined') await this.getBoundaries();\n    return await Promise.all(dates.map(date => this.getDate(date, after)));\n  }\n\n  async findBetter(date, predictedBlock, after, blockTime = this.blockTime) {\n    if (await this.isBetterBlock(date, predictedBlock, after)) return predictedBlock.number;\n    let difference = date.diff(moment.unix(predictedBlock.timestamp), 'seconds');\n    let skip = Math.ceil(difference / (blockTime == 0 ? 1 : blockTime));\n    if (skip == 0) skip = difference < 0 ? -1 : 1;\n    let nextPredictedBlock = await this.getBlockWrapper(this.getNextBlock(date, predictedBlock.number, skip));\n    blockTime = Math.abs((parseInt(predictedBlock.timestamp, 10) - parseInt(nextPredictedBlock.timestamp, 10)) / (parseInt(predictedBlock.number, 10) - parseInt(nextPredictedBlock.number, 10)));\n    return this.findBetter(date, nextPredictedBlock, after, blockTime);\n  }\n\n  async isBetterBlock(date, predictedBlock, after) {\n    let blockTime = moment.unix(predictedBlock.timestamp);\n\n    if (after) {\n      if (blockTime.isBefore(date)) return false;\n      let previousBlock = await this.getBlockWrapper(predictedBlock.number - 1);\n      if (blockTime.isSameOrAfter(date) && moment.unix(previousBlock.timestamp).isBefore(date)) return true;\n    } else {\n      if (blockTime.isSameOrAfter(date)) return false;\n      let nextBlock = await this.getBlockWrapper(predictedBlock.number + 1);\n      if (blockTime.isBefore(date) && moment.unix(nextBlock.timestamp).isSameOrAfter(date)) return true;\n    }\n\n    return false;\n  }\n\n  getNextBlock(date, currentBlock, skip) {\n    let nextBlock = currentBlock + skip;\n    if (this.checkedBlocks[date.unix()].includes(nextBlock)) return this.getNextBlock(date, currentBlock, skip < 0 ? --skip : ++skip);\n    this.checkedBlocks[date.unix()].push(nextBlock);\n    return nextBlock < 1 ? 1 : nextBlock;\n  }\n\n  returnWrapper(date, block) {\n    return {\n      date: date,\n      block: block,\n      timestamp: this.savedBlocks[block].timestamp\n    };\n  }\n\n  async getBlockWrapper(block) {\n    block = block == 'latest' ? await this.web3.eth.getBlockNumber() : block;\n    if (this.savedBlocks[block]) return this.savedBlocks[block];\n    let {\n      timestamp\n    } = await this.web3.eth.getBlock(block);\n    this.savedBlocks[block] = {\n      timestamp: timestamp,\n      number: block\n    };\n    this.requests++;\n    return this.savedBlocks[block];\n  }\n\n};"]},"metadata":{},"sourceType":"script"}
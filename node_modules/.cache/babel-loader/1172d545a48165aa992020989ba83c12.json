{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\nexport var u =\n/**\n* @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n*/\n\n/**\n * @param {string} type Type of node\n * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n * @param {ChildrenOrValue} [value] `children` or `value` of node\n * @returns {Node}\n */\nfunction (type, props, value) {\n  /** @type {Node} */\n  var node = {\n    type: String(type)\n  };\n\n  if ((value === undefined || value === null) && (typeof props === 'string' || Array.isArray(props))) {\n    value = props;\n  } else {\n    Object.assign(node, props);\n  }\n\n  if (Array.isArray(value)) {\n    node.children = value;\n  } else if (value !== undefined && value !== null) {\n    node.value = String(value);\n  }\n\n  return node;\n};","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/unist-builder/index.js"],"names":["u","type","props","value","node","String","undefined","Array","isArray","Object","assign","children"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,IAAIA,CAAC;AAAG;AACf;AACA;;AACE;AACF;AACA;AACA;AACA;AACA;AACE,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,KAAvB,EAA8B;AAC5B;AACA,MAAIC,IAAI,GAAG;AAACH,IAAAA,IAAI,EAAEI,MAAM,CAACJ,IAAD;AAAb,GAAX;;AAEA,MACE,CAACE,KAAK,KAAKG,SAAV,IAAuBH,KAAK,KAAK,IAAlC,MACC,OAAOD,KAAP,KAAiB,QAAjB,IAA6BK,KAAK,CAACC,OAAN,CAAcN,KAAd,CAD9B,CADF,EAGE;AACAC,IAAAA,KAAK,GAAGD,KAAR;AACD,GALD,MAKO;AACLO,IAAAA,MAAM,CAACC,MAAP,CAAcN,IAAd,EAAoBF,KAApB;AACD;;AAED,MAAIK,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAJ,EAA0B;AACxBC,IAAAA,IAAI,CAACO,QAAL,GAAgBR,KAAhB;AACD,GAFD,MAEO,IAAIA,KAAK,KAAKG,SAAV,IAAuBH,KAAK,KAAK,IAArC,EAA2C;AAChDC,IAAAA,IAAI,CAACD,KAAL,GAAaE,MAAM,CAACF,KAAD,CAAnB;AACD;;AAED,SAAOC,IAAP;AACD,CA7BI","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\n\nexport var u = /**\n * @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n */ (\n  /**\n   * @param {string} type Type of node\n   * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n   * @param {ChildrenOrValue} [value] `children` or `value` of node\n   * @returns {Node}\n   */\n  function (type, props, value) {\n    /** @type {Node} */\n    var node = {type: String(type)}\n\n    if (\n      (value === undefined || value === null) &&\n      (typeof props === 'string' || Array.isArray(props))\n    ) {\n      value = props\n    } else {\n      Object.assign(node, props)\n    }\n\n    if (Array.isArray(value)) {\n      node.children = value\n    } else if (value !== undefined && value !== null) {\n      node.value = String(value)\n    }\n\n    return node\n  }\n)\n"]},"metadata":{},"sourceType":"module"}
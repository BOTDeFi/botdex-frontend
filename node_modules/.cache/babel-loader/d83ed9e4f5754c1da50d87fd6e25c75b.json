{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\n\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    marker = code === 40 ? 41 : code;\n    return atFirstTitleBreak;\n  }\n  /** @type {State} */\n\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    return atTitleBreak(code);\n  }\n  /** @type {State} */\n\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType);\n      return atFirstTitleBreak(marker);\n    }\n\n    if (code === null) {\n      return nok(code);\n    } // Note: blank lines can’t exist in content.\n\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return factorySpace(effects, atTitleBreak, 'linePrefix');\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return title(code);\n  }\n  /** @type {State} */\n\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString');\n      return atTitleBreak(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? titleEscape : title;\n  }\n  /** @type {State} */\n\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code);\n      return title;\n    }\n\n    return title(code);\n  }\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-factory-title/index.js"],"names":["factorySpace","markdownLineEnding","factoryTitle","effects","ok","nok","type","markerType","stringType","marker","start","code","enter","consume","exit","atFirstTitleBreak","atTitleBreak","contentType","title","titleEscape"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAAQA,YAAR,QAA2B,yBAA3B;AACA,SAAQC,kBAAR,QAAiC,0BAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,EAA/B,EAAmCC,GAAnC,EAAwCC,IAAxC,EAA8CC,UAA9C,EAA0DC,UAA1D,EAAsE;AAC3E;AACA,MAAIC,MAAJ;AACA,SAAOC,KAAP;AACA;;AAEA,WAASA,KAAT,CAAeC,IAAf,EAAqB;AACnBR,IAAAA,OAAO,CAACS,KAAR,CAAcN,IAAd;AACAH,IAAAA,OAAO,CAACS,KAAR,CAAcL,UAAd;AACAJ,IAAAA,OAAO,CAACU,OAAR,CAAgBF,IAAhB;AACAR,IAAAA,OAAO,CAACW,IAAR,CAAaP,UAAb;AACAE,IAAAA,MAAM,GAAGE,IAAI,KAAK,EAAT,GAAc,EAAd,GAAmBA,IAA5B;AACA,WAAOI,iBAAP;AACD;AACD;;;AAEA,WAASA,iBAAT,CAA2BJ,IAA3B,EAAiC;AAC/B,QAAIA,IAAI,KAAKF,MAAb,EAAqB;AACnBN,MAAAA,OAAO,CAACS,KAAR,CAAcL,UAAd;AACAJ,MAAAA,OAAO,CAACU,OAAR,CAAgBF,IAAhB;AACAR,MAAAA,OAAO,CAACW,IAAR,CAAaP,UAAb;AACAJ,MAAAA,OAAO,CAACW,IAAR,CAAaR,IAAb;AACA,aAAOF,EAAP;AACD;;AAEDD,IAAAA,OAAO,CAACS,KAAR,CAAcJ,UAAd;AACA,WAAOQ,YAAY,CAACL,IAAD,CAAnB;AACD;AACD;;;AAEA,WAASK,YAAT,CAAsBL,IAAtB,EAA4B;AAC1B,QAAIA,IAAI,KAAKF,MAAb,EAAqB;AACnBN,MAAAA,OAAO,CAACW,IAAR,CAAaN,UAAb;AACA,aAAOO,iBAAiB,CAACN,MAAD,CAAxB;AACD;;AAED,QAAIE,IAAI,KAAK,IAAb,EAAmB;AACjB,aAAON,GAAG,CAACM,IAAD,CAAV;AACD,KARyB,CAQxB;;;AAEF,QAAIV,kBAAkB,CAACU,IAAD,CAAtB,EAA8B;AAC5BR,MAAAA,OAAO,CAACS,KAAR,CAAc,YAAd;AACAT,MAAAA,OAAO,CAACU,OAAR,CAAgBF,IAAhB;AACAR,MAAAA,OAAO,CAACW,IAAR,CAAa,YAAb;AACA,aAAOd,YAAY,CAACG,OAAD,EAAUa,YAAV,EAAwB,YAAxB,CAAnB;AACD;;AAEDb,IAAAA,OAAO,CAACS,KAAR,CAAc,aAAd,EAA6B;AAC3BK,MAAAA,WAAW,EAAE;AADc,KAA7B;AAGA,WAAOC,KAAK,CAACP,IAAD,CAAZ;AACD;AACD;;;AAEA,WAASO,KAAT,CAAeP,IAAf,EAAqB;AACnB,QAAIA,IAAI,KAAKF,MAAT,IAAmBE,IAAI,KAAK,IAA5B,IAAoCV,kBAAkB,CAACU,IAAD,CAA1D,EAAkE;AAChER,MAAAA,OAAO,CAACW,IAAR,CAAa,aAAb;AACA,aAAOE,YAAY,CAACL,IAAD,CAAnB;AACD;;AAEDR,IAAAA,OAAO,CAACU,OAAR,CAAgBF,IAAhB;AACA,WAAOA,IAAI,KAAK,EAAT,GAAcQ,WAAd,GAA4BD,KAAnC;AACD;AACD;;;AAEA,WAASC,WAAT,CAAqBR,IAArB,EAA2B;AACzB,QAAIA,IAAI,KAAKF,MAAT,IAAmBE,IAAI,KAAK,EAAhC,EAAoC;AAClCR,MAAAA,OAAO,CAACU,OAAR,CAAgBF,IAAhB;AACA,aAAOO,KAAP;AACD;;AAED,WAAOA,KAAK,CAACP,IAAD,CAAZ;AACD;AACF","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    marker = code === 40 ? 41 : code\n    return atFirstTitleBreak\n  }\n  /** @type {State} */\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atTitleBreak(code)\n  }\n  /** @type {State} */\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return atFirstTitleBreak(marker)\n    }\n\n    if (code === null) {\n      return nok(code)\n    } // Note: blank lines can’t exist in content.\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atTitleBreak, 'linePrefix')\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return title(code)\n  }\n  /** @type {State} */\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atTitleBreak(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? titleEscape : title\n  }\n  /** @type {State} */\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return title\n    }\n\n    return title(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { asciiAlphanumeric } from 'micromark-util-character';\nimport { encode } from 'micromark-util-encode';\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\n\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n\n  if (!protocol) {\n    return value;\n  }\n\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n\n  if ( // If there is no protocol, it’s relative.\n  colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n\n  return '';\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\nfunction normalizeUri(value) {\n  /** @type {string[]} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n\n    let replace = ''; // A correct percent encoded value.\n\n    if (code === 37 && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    } // ASCII.\n    else if (code < 128) {\n        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n          replace = String.fromCharCode(code);\n        }\n      } // Astral.\n      else if (code > 55295 && code < 57344) {\n          const next = value.charCodeAt(index + 1); // A correct surrogate pair.\n\n          if (code < 56320 && next > 56319 && next < 57344) {\n            replace = String.fromCharCode(code, next);\n            skip = 1;\n          } // Lone surrogate.\n          else {\n              replace = '\\uFFFD';\n            }\n        } // Unicode.\n        else {\n            replace = String.fromCharCode(code);\n          }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n\n  return result.join('') + value.slice(start);\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-util-sanitize-uri/index.js"],"names":["asciiAlphanumeric","encode","sanitizeUri","url","protocol","value","normalizeUri","colon","indexOf","questionMark","numberSign","slash","test","slice","result","index","start","skip","length","code","charCodeAt","replace","String","fromCharCode","next","push","encodeURIComponent","join"],"mappings":"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","sourcesContent":["import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, it’s relative.\n    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) || // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\nfunction normalizeUri(value) {\n  /** @type {string[]} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n\n    let replace = '' // A correct percent encoded value.\n\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    } // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    } // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1) // A correct surrogate pair.\n\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      } // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    } // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n"]},"metadata":{},"sourceType":"module"}
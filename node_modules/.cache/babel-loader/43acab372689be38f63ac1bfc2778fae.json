{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber';\nimport { Observable } from 'rxjs';\nimport Web3 from 'web3';\nimport { contracts } from '@/config';\nconst networks = {\n  mainnet: '0x1',\n  ropsten: '0x3',\n  kovan: '0x2a',\n  rinkeby: '0x4',\n  bsct: '0x61',\n  bsc: '0x38'\n};\nexport default class MetamaskService {\n  constructor({\n    testnet,\n    isProduction = false\n  }) {\n    this.wallet = void 0;\n    this.web3Provider = void 0;\n    this.testnet = void 0;\n    this.isProduction = void 0;\n    this.walletAddress = '';\n    this.chainChangedObs = void 0;\n    this.accountChangedObs = void 0;\n    this.usedNetwork = void 0;\n    this.usedChain = void 0;\n    this.contracts = {};\n    this.wallet = window.ethereum;\n    this.web3Provider = new Web3(this.wallet);\n    this.testnet = testnet;\n    this.isProduction = isProduction;\n    this.usedNetwork = this.isProduction ? 'mainnet' : this.testnet;\n    this.usedChain = this.isProduction ? networks.mainnet : networks[this.testnet];\n    this.chainChangedObs = new Observable(subscriber => {\n      if (!this.wallet) {\n        return;\n      }\n\n      this.wallet.on('chainChanged', () => {\n        const currentChain = this.wallet.chainId;\n\n        if (currentChain !== this.usedChain) {\n          subscriber.next(`Please choose ${this.usedNetwork} network in metamask wallet.`);\n        }\n      });\n    });\n    this.accountChangedObs = new Observable(subscriber => {\n      if (!this.wallet) {\n        return;\n      }\n\n      this.wallet.on('accountsChanged', () => {\n        subscriber.next();\n      });\n    });\n  }\n\n  ethRequestAccounts() {\n    return this.wallet.request({\n      method: 'eth_requestAccounts'\n    });\n  }\n\n  connect() {\n    if (!this.wallet) {\n      return Promise.reject(new Error(`Couldn't find Metamask extension, check if it's installed and enabled.`));\n    }\n\n    const currentChain = this.wallet.chainId;\n    return new Promise((resolve, reject) => {\n      if (!this.wallet) {\n        reject(new Error(`metamask wallet is not injected`));\n      }\n\n      if (!currentChain || currentChain === null) {\n        this.wallet.request({\n          method: 'eth_chainId'\n        }).then(resChain => {\n          if (resChain === this.usedChain) {\n            this.ethRequestAccounts().then(account => {\n              [this.walletAddress] = account;\n              resolve({\n                address: account[0],\n                network: resChain\n              });\n            }).catch(() => reject(new Error('Not authorized')));\n          } else {\n            reject(new Error(`Please choose ${this.usedNetwork} network in metamask wallet`));\n          }\n        }).catch(() => reject(new Error('Not authorized')));\n      } else if (currentChain === this.usedChain) {\n        this.ethRequestAccounts().then(account => {\n          [this.walletAddress] = account;\n          resolve({\n            address: account[0],\n            network: currentChain\n          });\n        }).catch(() => reject(new Error('Not authorized')));\n      } else {\n        reject(new Error(`Please choose ${this.usedNetwork} network in metamask wallet.`));\n      }\n    });\n  }\n\n  createContract(contractName, tokenAddress, abi) {\n    if (!this.contracts[contractName]) {\n      const contract = this.getContract(tokenAddress, abi);\n      this.contracts = { ...this.contracts,\n        [contractName]: contract\n      };\n    }\n  }\n\n  getContract(tokenAddress, abi) {\n    return new this.web3Provider.eth.Contract(abi, tokenAddress);\n  }\n\n  getEthBalance() {\n    return this.web3Provider.eth.getBalance(this.walletAddress);\n  }\n\n  static getMethodInterface(abi, methodName) {\n    return abi.filter(m => {\n      return m.name === methodName;\n    })[0];\n  }\n\n  encodeFunctionCall(abi, data) {\n    return this.web3Provider.eth.abi.encodeFunctionCall(abi, data);\n  }\n\n  async totalSupply(tokenAddress, abi, tokenDecimals) {\n    const contract = this.getContract(tokenAddress, abi);\n    const totalSupply = await contract.methods.totalSupply().call();\n    return +new BigNumber(totalSupply).dividedBy(new BigNumber(10).pow(tokenDecimals)).toString(10);\n  }\n\n  async getTokenInfo(address, abi) {\n    try {\n      const contract = this.getContract(address, abi);\n      const name = await contract.methods.name().call();\n      const decimals = await contract.methods.decimals().call();\n      const symbol = await contract.methods.symbol().call();\n      return {\n        name,\n        decimals,\n        symbol,\n        address\n      };\n    } catch (err) {\n      throw new Error('err get token info');\n    }\n  }\n\n  async checkTokenAllowance({\n    contractName,\n    tokenDecimals,\n    approvedAddress,\n    walletAddress,\n    tokenAddress,\n    approveSum\n  }) {\n    let decimals = NaN;\n    const contract = this.getContract(tokenAddress, contracts[contractName].ABI);\n\n    if (!tokenDecimals) {\n      const tokenInfo = await this.getTokenInfo(tokenAddress, contracts[contractName].ABI);\n      decimals = tokenInfo.decimals;\n    }\n\n    const walletAdr = walletAddress || this.walletAddress;\n\n    try {\n      let result = await contract.methods.allowance(walletAdr, approvedAddress).call();\n      result = result === '0' ? null : +new BigNumber(result).dividedBy(new BigNumber(10).pow(tokenDecimals || decimals)).toString(10);\n\n      if (result && new BigNumber(result).minus(approveSum || 0).isPositive()) {\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async approveToken({\n    contractName,\n    tokenDecimals,\n    approvedAddress,\n    walletAddress,\n    tokenAddress\n  }) {\n    try {\n      let decimals = NaN;\n\n      if (!tokenDecimals) {\n        const tokenInfo = await this.getTokenInfo(tokenAddress, contracts[contractName].ABI);\n        decimals = tokenInfo.decimals;\n      }\n\n      const approveMethod = MetamaskService.getMethodInterface(contracts[contractName].ABI, 'approve');\n      const approveSignature = this.encodeFunctionCall(approveMethod, [approvedAddress || walletAddress || this.walletAddress, new BigNumber(90071992.5474099).times(new BigNumber(10).pow(decimals || 8)).toString(10)]);\n      return this.sendTransaction({\n        from: walletAddress || this.walletAddress,\n        to: tokenAddress,\n        data: approveSignature\n      });\n    } catch (error) {\n      return error;\n    }\n  }\n\n  static calcTransactionAmount(amount, tokenDecimal) {\n    return new BigNumber(amount).times(new BigNumber(10).pow(tokenDecimal)).toString(10);\n  }\n\n  static amountFromGwei(amount, tokenDecimal) {\n    return new BigNumber(amount).dividedBy(new BigNumber(10).pow(tokenDecimal)).toString(10);\n  }\n\n  createTransaction({\n    method,\n    data,\n    contractName,\n    tx,\n    toAddress,\n    fromAddress,\n    value\n  }) {\n    const contract = contracts[contractName];\n    const {\n      ABI,\n      ADDRESS\n    } = contract;\n    const transactionMethod = MetamaskService.getMethodInterface(ABI, method);\n    let signature;\n\n    if (transactionMethod.inputs.length) {\n      signature = this.encodeFunctionCall(transactionMethod, data);\n    }\n\n    if (tx) {\n      tx.from = fromAddress || this.walletAddress;\n      tx.data = signature;\n      return this.sendTransaction(tx);\n    }\n\n    return this.sendTransaction({\n      from: fromAddress || this.walletAddress,\n      to: toAddress || ADDRESS,\n      data: signature || '',\n      value: value || ''\n    });\n  }\n\n  signMsg(msg) {\n    return this.web3Provider.eth.personal.sign(msg, this.walletAddress, '');\n  }\n\n  async callContractMethod(contractName, methodName, data, contractAddress, contractAbi) {\n    try {\n      if (!this.contracts[contractName] && contractAddress && contractAbi) {\n        await this.createContract(contractName, contractAddress, contractAbi);\n      }\n\n      if (this.contracts[contractName]) {\n        const method = await this.contracts[contractName].methods[methodName];\n\n        if (data) {\n          return await method(...data).call();\n        }\n\n        return await method().call();\n      }\n    } catch (err) {\n      debugger;\n      throw new Error(err);\n    }\n\n    return new Error(`contract ${contractName} didn't created`);\n  }\n\n  async callContractMethodFromNewContract(contractAddress, abi, methodName, data) {\n    try {\n      const contract = this.getContract(contractAddress, abi);\n      const method = contract.methods[methodName];\n\n      if (data) {\n        return await method(...data).call();\n      }\n\n      return await method().call();\n    } catch (err) {\n      throw new Error(err);\n    }\n  }\n\n  sendTransaction(transactionConfig) {\n    return this.web3Provider.eth.sendTransaction({ ...transactionConfig,\n      from: this.walletAddress\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/services/web3/index.ts"],"names":["BigNumber","Observable","Web3","contracts","networks","mainnet","ropsten","kovan","rinkeby","bsct","bsc","MetamaskService","constructor","testnet","isProduction","wallet","web3Provider","walletAddress","chainChangedObs","accountChangedObs","usedNetwork","usedChain","window","ethereum","subscriber","on","currentChain","chainId","next","ethRequestAccounts","request","method","connect","Promise","reject","Error","resolve","then","resChain","account","address","network","catch","createContract","contractName","tokenAddress","abi","contract","getContract","eth","Contract","getEthBalance","getBalance","getMethodInterface","methodName","filter","m","name","encodeFunctionCall","data","totalSupply","tokenDecimals","methods","call","dividedBy","pow","toString","getTokenInfo","decimals","symbol","err","checkTokenAllowance","approvedAddress","approveSum","NaN","ABI","tokenInfo","walletAdr","result","allowance","minus","isPositive","error","approveToken","approveMethod","approveSignature","times","sendTransaction","from","to","calcTransactionAmount","amount","tokenDecimal","amountFromGwei","createTransaction","tx","toAddress","fromAddress","value","ADDRESS","transactionMethod","signature","inputs","length","signMsg","msg","personal","sign","callContractMethod","contractAddress","contractAbi","callContractMethodFromNewContract","transactionConfig"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,wBAAtB;AACA,SAASC,UAAT,QAA2B,MAA3B;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,SAASC,SAAT,QAA0B,UAA1B;AAgBA,MAAMC,QAAmB,GAAG;AAC1BC,EAAAA,OAAO,EAAE,KADiB;AAE1BC,EAAAA,OAAO,EAAE,KAFiB;AAG1BC,EAAAA,KAAK,EAAE,MAHmB;AAI1BC,EAAAA,OAAO,EAAE,KAJiB;AAK1BC,EAAAA,IAAI,EAAE,MALoB;AAM1BC,EAAAA,GAAG,EAAE;AANqB,CAA5B;AASA,eAAe,MAAMC,eAAN,CAAsB;AAqBnCC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,OAAF;AAAWC,IAAAA,YAAY,GAAG;AAA1B,GAAD,EAAsD;AAAA,SApB1DC,MAoB0D;AAAA,SAlB1DC,YAkB0D;AAAA,SAhBzDH,OAgByD;AAAA,SAdzDC,YAcyD;AAAA,SAZ1DG,aAY0D,GAZ1C,EAY0C;AAAA,SAV1DC,eAU0D;AAAA,SAR1DC,iBAQ0D;AAAA,SAN1DC,WAM0D;AAAA,SAJ1DC,SAI0D;AAAA,SAF1DlB,SAE0D,GAFzC,EAEyC;AAC/D,SAAKY,MAAL,GAAcO,MAAM,CAACC,QAArB;AACA,SAAKP,YAAL,GAAoB,IAAId,IAAJ,CAAS,KAAKa,MAAd,CAApB;AACA,SAAKF,OAAL,GAAeA,OAAf;AACA,SAAKC,YAAL,GAAoBA,YAApB;AAEA,SAAKM,WAAL,GAAmB,KAAKN,YAAL,GAAoB,SAApB,GAAgC,KAAKD,OAAxD;AACA,SAAKQ,SAAL,GAAiB,KAAKP,YAAL,GAAoBV,QAAQ,CAACC,OAA7B,GAAuCD,QAAQ,CAAC,KAAKS,OAAN,CAAhE;AAEA,SAAKK,eAAL,GAAuB,IAAIjB,UAAJ,CAAgBuB,UAAD,IAAgB;AACpD,UAAI,CAAC,KAAKT,MAAV,EAAkB;AAChB;AACD;;AAED,WAAKA,MAAL,CAAYU,EAAZ,CAAe,cAAf,EAA+B,MAAM;AACnC,cAAMC,YAAY,GAAG,KAAKX,MAAL,CAAYY,OAAjC;;AAEA,YAAID,YAAY,KAAK,KAAKL,SAA1B,EAAqC;AACnCG,UAAAA,UAAU,CAACI,IAAX,CAAiB,iBAAgB,KAAKR,WAAY,8BAAlD;AACD;AACF,OAND;AAOD,KAZsB,CAAvB;AAcA,SAAKD,iBAAL,GAAyB,IAAIlB,UAAJ,CAAgBuB,UAAD,IAAgB;AACtD,UAAI,CAAC,KAAKT,MAAV,EAAkB;AAChB;AACD;;AAED,WAAKA,MAAL,CAAYU,EAAZ,CAAe,iBAAf,EAAkC,MAAM;AACtCD,QAAAA,UAAU,CAACI,IAAX;AACD,OAFD;AAGD,KARwB,CAAzB;AASD;;AAEDC,EAAAA,kBAAkB,GAAG;AACnB,WAAO,KAAKd,MAAL,CAAYe,OAAZ,CAAoB;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAApB,CAAP;AACD;;AAEMC,EAAAA,OAAO,GAAG;AACf,QAAI,CAAC,KAAKjB,MAAV,EAAkB;AAChB,aAAOkB,OAAO,CAACC,MAAR,CACL,IAAIC,KAAJ,CAAW,wEAAX,CADK,CAAP;AAGD;;AACD,UAAMT,YAAY,GAAG,KAAKX,MAAL,CAAYY,OAAjC;AAEA,WAAO,IAAIM,OAAJ,CAAY,CAACG,OAAD,EAAUF,MAAV,KAAqB;AACtC,UAAI,CAAC,KAAKnB,MAAV,EAAkB;AAChBmB,QAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAW,iCAAX,CAAD,CAAN;AACD;;AAED,UAAI,CAACT,YAAD,IAAiBA,YAAY,KAAK,IAAtC,EAA4C;AAC1C,aAAKX,MAAL,CACGe,OADH,CACW;AAAEC,UAAAA,MAAM,EAAE;AAAV,SADX,EAEGM,IAFH,CAESC,QAAD,IAAmB;AACvB,cAAIA,QAAQ,KAAK,KAAKjB,SAAtB,EAAiC;AAC/B,iBAAKQ,kBAAL,GACGQ,IADH,CACSE,OAAD,IAAkB;AACtB,eAAC,KAAKtB,aAAN,IAAuBsB,OAAvB;AACAH,cAAAA,OAAO,CAAC;AACNI,gBAAAA,OAAO,EAAED,OAAO,CAAC,CAAD,CADV;AAENE,gBAAAA,OAAO,EAAEH;AAFH,eAAD,CAAP;AAID,aAPH,EAQGI,KARH,CAQS,MAAMR,MAAM,CAAC,IAAIC,KAAJ,CAAU,gBAAV,CAAD,CARrB;AASD,WAVD,MAUO;AACLD,YAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAW,iBAAgB,KAAKf,WAAY,6BAA5C,CAAD,CAAN;AACD;AACF,SAhBH,EAiBGsB,KAjBH,CAiBS,MAAMR,MAAM,CAAC,IAAIC,KAAJ,CAAU,gBAAV,CAAD,CAjBrB;AAkBD,OAnBD,MAmBO,IAAIT,YAAY,KAAK,KAAKL,SAA1B,EAAqC;AAC1C,aAAKQ,kBAAL,GACGQ,IADH,CACSE,OAAD,IAAkB;AACtB,WAAC,KAAKtB,aAAN,IAAuBsB,OAAvB;AACAH,UAAAA,OAAO,CAAC;AACNI,YAAAA,OAAO,EAAED,OAAO,CAAC,CAAD,CADV;AAENE,YAAAA,OAAO,EAAEf;AAFH,WAAD,CAAP;AAID,SAPH,EAQGgB,KARH,CAQS,MAAMR,MAAM,CAAC,IAAIC,KAAJ,CAAU,gBAAV,CAAD,CARrB;AASD,OAVM,MAUA;AACLD,QAAAA,MAAM,CAAC,IAAIC,KAAJ,CAAW,iBAAgB,KAAKf,WAAY,8BAA5C,CAAD,CAAN;AACD;AACF,KArCM,CAAP;AAsCD;;AAEDuB,EAAAA,cAAc,CAACC,YAAD,EAAuBC,YAAvB,EAA6CC,GAA7C,EAA8D;AAC1E,QAAI,CAAC,KAAK3C,SAAL,CAAeyC,YAAf,CAAL,EAAmC;AACjC,YAAMG,QAAQ,GAAG,KAAKC,WAAL,CAAiBH,YAAjB,EAA+BC,GAA/B,CAAjB;AACA,WAAK3C,SAAL,GAAiB,EACf,GAAG,KAAKA,SADO;AAEf,SAACyC,YAAD,GAAgBG;AAFD,OAAjB;AAID;AACF;;AAEDC,EAAAA,WAAW,CAACH,YAAD,EAAuBC,GAAvB,EAAwC;AACjD,WAAO,IAAI,KAAK9B,YAAL,CAAkBiC,GAAlB,CAAsBC,QAA1B,CAAmCJ,GAAnC,EAAwCD,YAAxC,CAAP;AACD;;AAEDM,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKnC,YAAL,CAAkBiC,GAAlB,CAAsBG,UAAtB,CAAiC,KAAKnC,aAAtC,CAAP;AACD;;AAEwB,SAAlBoC,kBAAkB,CAACP,GAAD,EAAkBQ,UAAlB,EAAsC;AAC7D,WAAOR,GAAG,CAACS,MAAJ,CAAYC,CAAD,IAAO;AACvB,aAAOA,CAAC,CAACC,IAAF,KAAWH,UAAlB;AACD,KAFM,EAEJ,CAFI,CAAP;AAGD;;AAEDI,EAAAA,kBAAkB,CAACZ,GAAD,EAAWa,IAAX,EAA6B;AAC7C,WAAO,KAAK3C,YAAL,CAAkBiC,GAAlB,CAAsBH,GAAtB,CAA0BY,kBAA1B,CAA6CZ,GAA7C,EAAkDa,IAAlD,CAAP;AACD;;AAEgB,QAAXC,WAAW,CAACf,YAAD,EAAuBC,GAAvB,EAAwCe,aAAxC,EAA+D;AAC9E,UAAMd,QAAQ,GAAG,KAAKC,WAAL,CAAiBH,YAAjB,EAA+BC,GAA/B,CAAjB;AACA,UAAMc,WAAW,GAAG,MAAMb,QAAQ,CAACe,OAAT,CAAiBF,WAAjB,GAA+BG,IAA/B,EAA1B;AAEA,WAAO,CAAC,IAAI/D,SAAJ,CAAc4D,WAAd,EAA2BI,SAA3B,CAAqC,IAAIhE,SAAJ,CAAc,EAAd,EAAkBiE,GAAlB,CAAsBJ,aAAtB,CAArC,EAA2EK,QAA3E,CAAoF,EAApF,CAAR;AACD;;AAEiB,QAAZC,YAAY,CAAC3B,OAAD,EAAkBM,GAAlB,EAA4B;AAC5C,QAAI;AACF,YAAMC,QAAQ,GAAG,KAAKC,WAAL,CAAiBR,OAAjB,EAA0BM,GAA1B,CAAjB;AACA,YAAMW,IAAI,GAAG,MAAMV,QAAQ,CAACe,OAAT,CAAiBL,IAAjB,GAAwBM,IAAxB,EAAnB;AACA,YAAMK,QAAQ,GAAG,MAAMrB,QAAQ,CAACe,OAAT,CAAiBM,QAAjB,GAA4BL,IAA5B,EAAvB;AACA,YAAMM,MAAM,GAAG,MAAMtB,QAAQ,CAACe,OAAT,CAAiBO,MAAjB,GAA0BN,IAA1B,EAArB;AAEA,aAAO;AACLN,QAAAA,IADK;AAELW,QAAAA,QAFK;AAGLC,QAAAA,MAHK;AAIL7B,QAAAA;AAJK,OAAP;AAMD,KAZD,CAYE,OAAO8B,GAAP,EAAY;AACZ,YAAM,IAAInC,KAAJ,CAAU,oBAAV,CAAN;AACD;AACF;;AAEwB,QAAnBoC,mBAAmB,CAAC;AACxB3B,IAAAA,YADwB;AAExBiB,IAAAA,aAFwB;AAGxBW,IAAAA,eAHwB;AAIxBvD,IAAAA,aAJwB;AAKxB4B,IAAAA,YALwB;AAMxB4B,IAAAA;AANwB,GAAD,EActB;AACD,QAAIL,QAAQ,GAAGM,GAAf;AAEA,UAAM3B,QAAQ,GAAG,KAAKC,WAAL,CAAiBH,YAAjB,EAA+B1C,SAAS,CAACyC,YAAD,CAAT,CAAwB+B,GAAvD,CAAjB;;AAEA,QAAI,CAACd,aAAL,EAAoB;AAClB,YAAMe,SAAS,GAAG,MAAM,KAAKT,YAAL,CAAkBtB,YAAlB,EAAgC1C,SAAS,CAACyC,YAAD,CAAT,CAAwB+B,GAAxD,CAAxB;AACAP,MAAAA,QAAQ,GAAGQ,SAAS,CAACR,QAArB;AACD;;AACD,UAAMS,SAAS,GAAG5D,aAAa,IAAI,KAAKA,aAAxC;;AAEA,QAAI;AACF,UAAI6D,MAAM,GAAG,MAAM/B,QAAQ,CAACe,OAAT,CAAiBiB,SAAjB,CAA2BF,SAA3B,EAAsCL,eAAtC,EAAuDT,IAAvD,EAAnB;AAEAe,MAAAA,MAAM,GACJA,MAAM,KAAK,GAAX,GACI,IADJ,GAEI,CAAC,IAAI9E,SAAJ,CAAc8E,MAAd,EACEd,SADF,CACY,IAAIhE,SAAJ,CAAc,EAAd,EAAkBiE,GAAlB,CAAsBJ,aAAa,IAAIO,QAAvC,CADZ,EAEEF,QAFF,CAEW,EAFX,CAHP;;AAMA,UAAIY,MAAM,IAAI,IAAI9E,SAAJ,CAAc8E,MAAd,EAAsBE,KAAtB,CAA4BP,UAAU,IAAI,CAA1C,EAA6CQ,UAA7C,EAAd,EAAyE;AACvE,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD,KAbD,CAaE,OAAOC,KAAP,EAAc;AACd,aAAO,KAAP;AACD;AACF;;AAEiB,QAAZC,YAAY,CAAC;AACjBvC,IAAAA,YADiB;AAEjBiB,IAAAA,aAFiB;AAGjBW,IAAAA,eAHiB;AAIjBvD,IAAAA,aAJiB;AAKjB4B,IAAAA;AALiB,GAAD,EAYf;AACD,QAAI;AACF,UAAIuB,QAAQ,GAAGM,GAAf;;AAEA,UAAI,CAACb,aAAL,EAAoB;AAClB,cAAMe,SAAS,GAAG,MAAM,KAAKT,YAAL,CAAkBtB,YAAlB,EAAgC1C,SAAS,CAACyC,YAAD,CAAT,CAAwB+B,GAAxD,CAAxB;AACAP,QAAAA,QAAQ,GAAGQ,SAAS,CAACR,QAArB;AACD;;AAED,YAAMgB,aAAa,GAAGzE,eAAe,CAAC0C,kBAAhB,CACpBlD,SAAS,CAACyC,YAAD,CAAT,CAAwB+B,GADJ,EAEpB,SAFoB,CAAtB;AAKA,YAAMU,gBAAgB,GAAG,KAAK3B,kBAAL,CAAwB0B,aAAxB,EAAuC,CAC9DZ,eAAe,IAAIvD,aAAnB,IAAoC,KAAKA,aADqB,EAE9D,IAAIjB,SAAJ,CAAc,gBAAd,EAAgCsF,KAAhC,CAAsC,IAAItF,SAAJ,CAAc,EAAd,EAAkBiE,GAAlB,CAAsBG,QAAQ,IAAI,CAAlC,CAAtC,EAA4EF,QAA5E,CAAqF,EAArF,CAF8D,CAAvC,CAAzB;AAKA,aAAO,KAAKqB,eAAL,CAAqB;AAC1BC,QAAAA,IAAI,EAAEvE,aAAa,IAAI,KAAKA,aADF;AAE1BwE,QAAAA,EAAE,EAAE5C,YAFsB;AAG1Bc,QAAAA,IAAI,EAAE0B;AAHoB,OAArB,CAAP;AAKD,KAvBD,CAuBE,OAAOH,KAAP,EAAc;AACd,aAAOA,KAAP;AACD;AACF;;AAE2B,SAArBQ,qBAAqB,CAACC,MAAD,EAA0BC,YAA1B,EAAgD;AAC1E,WAAO,IAAI5F,SAAJ,CAAc2F,MAAd,EAAsBL,KAAtB,CAA4B,IAAItF,SAAJ,CAAc,EAAd,EAAkBiE,GAAlB,CAAsB2B,YAAtB,CAA5B,EAAiE1B,QAAjE,CAA0E,EAA1E,CAAP;AACD;;AAEoB,SAAd2B,cAAc,CAACF,MAAD,EAA0BC,YAA1B,EAAgD;AACnE,WAAO,IAAI5F,SAAJ,CAAc2F,MAAd,EAAsB3B,SAAtB,CAAgC,IAAIhE,SAAJ,CAAc,EAAd,EAAkBiE,GAAlB,CAAsB2B,YAAtB,CAAhC,EAAqE1B,QAArE,CAA8E,EAA9E,CAAP;AACD;;AAED4B,EAAAA,iBAAiB,CAAC;AAChB/D,IAAAA,MADgB;AAEhB4B,IAAAA,IAFgB;AAGhBf,IAAAA,YAHgB;AAIhBmD,IAAAA,EAJgB;AAKhBC,IAAAA,SALgB;AAMhBC,IAAAA,WANgB;AAOhBC,IAAAA;AAPgB,GAAD,EAgBd;AACD,UAAMnD,QAAQ,GAAG5C,SAAS,CAACyC,YAAD,CAA1B;AACA,UAAM;AAAE+B,MAAAA,GAAF;AAAOwB,MAAAA;AAAP,QAAmBpD,QAAzB;AACA,UAAMqD,iBAAiB,GAAGzF,eAAe,CAAC0C,kBAAhB,CAAmCsB,GAAnC,EAAwC5C,MAAxC,CAA1B;AAEA,QAAIsE,SAAJ;;AACA,QAAID,iBAAiB,CAACE,MAAlB,CAAyBC,MAA7B,EAAqC;AACnCF,MAAAA,SAAS,GAAG,KAAK3C,kBAAL,CAAwB0C,iBAAxB,EAA2CzC,IAA3C,CAAZ;AACD;;AAED,QAAIoC,EAAJ,EAAQ;AACNA,MAAAA,EAAE,CAACP,IAAH,GAAUS,WAAW,IAAI,KAAKhF,aAA9B;AACA8E,MAAAA,EAAE,CAACpC,IAAH,GAAU0C,SAAV;AAEA,aAAO,KAAKd,eAAL,CAAqBQ,EAArB,CAAP;AACD;;AACD,WAAO,KAAKR,eAAL,CAAqB;AAC1BC,MAAAA,IAAI,EAAES,WAAW,IAAI,KAAKhF,aADA;AAE1BwE,MAAAA,EAAE,EAAEO,SAAS,IAAIG,OAFS;AAG1BxC,MAAAA,IAAI,EAAE0C,SAAS,IAAI,EAHO;AAI1BH,MAAAA,KAAK,EAAEA,KAAK,IAAI;AAJU,KAArB,CAAP;AAMD;;AAEDM,EAAAA,OAAO,CAACC,GAAD,EAAc;AACnB,WAAO,KAAKzF,YAAL,CAAkBiC,GAAlB,CAAsByD,QAAtB,CAA+BC,IAA/B,CAAoCF,GAApC,EAAyC,KAAKxF,aAA9C,EAA6D,EAA7D,CAAP;AACD;;AAEuB,QAAlB2F,kBAAkB,CACtBhE,YADsB,EAEtBU,UAFsB,EAGtBK,IAHsB,EAItBkD,eAJsB,EAKtBC,WALsB,EAMtB;AACA,QAAI;AACF,UAAI,CAAC,KAAK3G,SAAL,CAAeyC,YAAf,CAAD,IAAiCiE,eAAjC,IAAoDC,WAAxD,EAAqE;AACnE,cAAM,KAAKnE,cAAL,CAAoBC,YAApB,EAAkCiE,eAAlC,EAAmDC,WAAnD,CAAN;AACD;;AAED,UAAI,KAAK3G,SAAL,CAAeyC,YAAf,CAAJ,EAAkC;AAChC,cAAMb,MAAM,GAAG,MAAM,KAAK5B,SAAL,CAAeyC,YAAf,EAA6BkB,OAA7B,CAAqCR,UAArC,CAArB;;AACA,YAAIK,IAAJ,EAAU;AACR,iBAAO,MAAM5B,MAAM,CAAC,GAAG4B,IAAJ,CAAN,CAAgBI,IAAhB,EAAb;AACD;;AACD,eAAO,MAAMhC,MAAM,GAAGgC,IAAT,EAAb;AACD;AACF,KAZD,CAYE,OAAOO,GAAP,EAAiB;AACjB;AACA,YAAM,IAAInC,KAAJ,CAAUmC,GAAV,CAAN;AACD;;AACD,WAAO,IAAInC,KAAJ,CAAW,YAAWS,YAAa,iBAAnC,CAAP;AACD;;AAEsC,QAAjCmE,iCAAiC,CACrCF,eADqC,EAErC/D,GAFqC,EAGrCQ,UAHqC,EAIrCK,IAJqC,EAKrC;AACA,QAAI;AACF,YAAMZ,QAAQ,GAAG,KAAKC,WAAL,CAAiB6D,eAAjB,EAAkC/D,GAAlC,CAAjB;AACA,YAAMf,MAAM,GAAGgB,QAAQ,CAACe,OAAT,CAAiBR,UAAjB,CAAf;;AAEA,UAAIK,IAAJ,EAAU;AACR,eAAO,MAAM5B,MAAM,CAAC,GAAG4B,IAAJ,CAAN,CAAgBI,IAAhB,EAAb;AACD;;AACD,aAAO,MAAMhC,MAAM,GAAGgC,IAAT,EAAb;AACD,KARD,CAQE,OAAOO,GAAP,EAAiB;AACjB,YAAM,IAAInC,KAAJ,CAAUmC,GAAV,CAAN;AACD;AACF;;AAEDiB,EAAAA,eAAe,CAACyB,iBAAD,EAAyB;AACtC,WAAO,KAAKhG,YAAL,CAAkBiC,GAAlB,CAAsBsC,eAAtB,CAAsC,EAC3C,GAAGyB,iBADwC;AAE3CxB,MAAAA,IAAI,EAAE,KAAKvE;AAFgC,KAAtC,CAAP;AAID;;AA1VkC","sourcesContent":["import BigNumber from 'bignumber.js/bignumber';\nimport { Observable } from 'rxjs';\nimport Web3 from 'web3';\n\nimport { contracts } from '@/config';\n\ndeclare global {\n  interface Window {\n    ethereum: any;\n  }\n}\ninterface INetworks {\n  [key: string]: string;\n}\n\ninterface IMetamaskService {\n  testnet: 'ropsten' | 'kovan' | 'rinkeby' | 'bsct';\n  isProduction?: boolean;\n}\n\nconst networks: INetworks = {\n  mainnet: '0x1',\n  ropsten: '0x3',\n  kovan: '0x2a',\n  rinkeby: '0x4',\n  bsct: '0x61',\n  bsc: '0x38',\n};\n\nexport default class MetamaskService {\n  public wallet;\n\n  public web3Provider;\n\n  private testnet: string;\n\n  private isProduction: boolean;\n\n  public walletAddress = '';\n\n  public chainChangedObs: any;\n\n  public accountChangedObs: any;\n\n  public usedNetwork: string;\n\n  public usedChain: string;\n\n  public contracts: any = {};\n\n  constructor({ testnet, isProduction = false }: IMetamaskService) {\n    this.wallet = window.ethereum;\n    this.web3Provider = new Web3(this.wallet);\n    this.testnet = testnet;\n    this.isProduction = isProduction;\n\n    this.usedNetwork = this.isProduction ? 'mainnet' : this.testnet;\n    this.usedChain = this.isProduction ? networks.mainnet : networks[this.testnet];\n\n    this.chainChangedObs = new Observable((subscriber) => {\n      if (!this.wallet) {\n        return;\n      }\n\n      this.wallet.on('chainChanged', () => {\n        const currentChain = this.wallet.chainId;\n\n        if (currentChain !== this.usedChain) {\n          subscriber.next(`Please choose ${this.usedNetwork} network in metamask wallet.`);\n        }\n      });\n    });\n\n    this.accountChangedObs = new Observable((subscriber) => {\n      if (!this.wallet) {\n        return;\n      }\n\n      this.wallet.on('accountsChanged', () => {\n        subscriber.next();\n      });\n    });\n  }\n\n  ethRequestAccounts() {\n    return this.wallet.request({ method: 'eth_requestAccounts' });\n  }\n\n  public connect() {\n    if (!this.wallet) {\n      return Promise.reject(\n        new Error(`Couldn't find Metamask extension, check if it's installed and enabled.`),\n      );\n    }\n    const currentChain = this.wallet.chainId;\n\n    return new Promise((resolve, reject) => {\n      if (!this.wallet) {\n        reject(new Error(`metamask wallet is not injected`));\n      }\n\n      if (!currentChain || currentChain === null) {\n        this.wallet\n          .request({ method: 'eth_chainId' })\n          .then((resChain: any) => {\n            if (resChain === this.usedChain) {\n              this.ethRequestAccounts()\n                .then((account: any) => {\n                  [this.walletAddress] = account;\n                  resolve({\n                    address: account[0],\n                    network: resChain,\n                  });\n                })\n                .catch(() => reject(new Error('Not authorized')));\n            } else {\n              reject(new Error(`Please choose ${this.usedNetwork} network in metamask wallet`));\n            }\n          })\n          .catch(() => reject(new Error('Not authorized')));\n      } else if (currentChain === this.usedChain) {\n        this.ethRequestAccounts()\n          .then((account: any) => {\n            [this.walletAddress] = account;\n            resolve({\n              address: account[0],\n              network: currentChain,\n            });\n          })\n          .catch(() => reject(new Error('Not authorized')));\n      } else {\n        reject(new Error(`Please choose ${this.usedNetwork} network in metamask wallet.`));\n      }\n    });\n  }\n\n  createContract(contractName: string, tokenAddress: string, abi: Array<any>) {\n    if (!this.contracts[contractName]) {\n      const contract = this.getContract(tokenAddress, abi);\n      this.contracts = {\n        ...this.contracts,\n        [contractName]: contract,\n      };\n    }\n  }\n\n  getContract(tokenAddress: string, abi: Array<any>) {\n    return new this.web3Provider.eth.Contract(abi, tokenAddress);\n  }\n\n  getEthBalance() {\n    return this.web3Provider.eth.getBalance(this.walletAddress);\n  }\n\n  static getMethodInterface(abi: Array<any>, methodName: string) {\n    return abi.filter((m) => {\n      return m.name === methodName;\n    })[0];\n  }\n\n  encodeFunctionCall(abi: any, data: Array<any>) {\n    return this.web3Provider.eth.abi.encodeFunctionCall(abi, data);\n  }\n\n  async totalSupply(tokenAddress: string, abi: Array<any>, tokenDecimals: number) {\n    const contract = this.getContract(tokenAddress, abi);\n    const totalSupply = await contract.methods.totalSupply().call();\n\n    return +new BigNumber(totalSupply).dividedBy(new BigNumber(10).pow(tokenDecimals)).toString(10);\n  }\n\n  async getTokenInfo(address: string, abi: any) {\n    try {\n      const contract = this.getContract(address, abi);\n      const name = await contract.methods.name().call();\n      const decimals = await contract.methods.decimals().call();\n      const symbol = await contract.methods.symbol().call();\n\n      return {\n        name,\n        decimals,\n        symbol,\n        address,\n      };\n    } catch (err) {\n      throw new Error('err get token info');\n    }\n  }\n\n  async checkTokenAllowance({\n    contractName,\n    tokenDecimals,\n    approvedAddress,\n    walletAddress,\n    tokenAddress,\n    approveSum,\n  }: {\n    contractName: 'ROUTER' | 'ERC20' | 'PAIR';\n    tokenDecimals?: number;\n    approvedAddress?: string;\n    walletAddress?: string;\n    tokenAddress: string;\n    approveSum?: number;\n  }) {\n    let decimals = NaN;\n\n    const contract = this.getContract(tokenAddress, contracts[contractName].ABI);\n\n    if (!tokenDecimals) {\n      const tokenInfo = await this.getTokenInfo(tokenAddress, contracts[contractName].ABI);\n      decimals = tokenInfo.decimals;\n    }\n    const walletAdr = walletAddress || this.walletAddress;\n\n    try {\n      let result = await contract.methods.allowance(walletAdr, approvedAddress).call();\n\n      result =\n        result === '0'\n          ? null\n          : +new BigNumber(result)\n              .dividedBy(new BigNumber(10).pow(tokenDecimals || decimals))\n              .toString(10);\n      if (result && new BigNumber(result).minus(approveSum || 0).isPositive()) {\n        return true;\n      }\n      return false;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async approveToken({\n    contractName,\n    tokenDecimals,\n    approvedAddress,\n    walletAddress,\n    tokenAddress,\n  }: {\n    contractName: 'ROUTER' | 'ERC20' | 'PAIR';\n    tokenDecimals?: number;\n    approvedAddress?: string;\n    walletAddress?: string;\n    tokenAddress: string;\n  }) {\n    try {\n      let decimals = NaN;\n\n      if (!tokenDecimals) {\n        const tokenInfo = await this.getTokenInfo(tokenAddress, contracts[contractName].ABI);\n        decimals = tokenInfo.decimals;\n      }\n\n      const approveMethod = MetamaskService.getMethodInterface(\n        contracts[contractName].ABI,\n        'approve',\n      );\n\n      const approveSignature = this.encodeFunctionCall(approveMethod, [\n        approvedAddress || walletAddress || this.walletAddress,\n        new BigNumber(90071992.5474099).times(new BigNumber(10).pow(decimals || 8)).toString(10),\n      ]);\n\n      return this.sendTransaction({\n        from: walletAddress || this.walletAddress,\n        to: tokenAddress,\n        data: approveSignature,\n      });\n    } catch (error) {\n      return error;\n    }\n  }\n\n  static calcTransactionAmount(amount: number | string, tokenDecimal: number) {\n    return new BigNumber(amount).times(new BigNumber(10).pow(tokenDecimal)).toString(10);\n  }\n\n  static amountFromGwei(amount: number | string, tokenDecimal: number) {\n    return new BigNumber(amount).dividedBy(new BigNumber(10).pow(tokenDecimal)).toString(10);\n  }\n\n  createTransaction({\n    method,\n    data,\n    contractName,\n    tx,\n    toAddress,\n    fromAddress,\n    value,\n  }: {\n    method: string;\n    data: Array<any>;\n    contractName: 'ROUTER' | 'FACTORY';\n    tx?: any;\n    toAddress?: string;\n    fromAddress?: string;\n    value?: any;\n  }) {\n    const contract = contracts[contractName];\n    const { ABI, ADDRESS } = contract;\n    const transactionMethod = MetamaskService.getMethodInterface(ABI, method);\n\n    let signature;\n    if (transactionMethod.inputs.length) {\n      signature = this.encodeFunctionCall(transactionMethod, data);\n    }\n\n    if (tx) {\n      tx.from = fromAddress || this.walletAddress;\n      tx.data = signature;\n\n      return this.sendTransaction(tx);\n    }\n    return this.sendTransaction({\n      from: fromAddress || this.walletAddress,\n      to: toAddress || ADDRESS,\n      data: signature || '',\n      value: value || '',\n    });\n  }\n\n  signMsg(msg: string) {\n    return this.web3Provider.eth.personal.sign(msg, this.walletAddress, '');\n  }\n\n  async callContractMethod(\n    contractName: string,\n    methodName: string,\n    data?: any[],\n    contractAddress?: string,\n    contractAbi?: Array<any>,\n  ) {\n    try {\n      if (!this.contracts[contractName] && contractAddress && contractAbi) {\n        await this.createContract(contractName, contractAddress, contractAbi);\n      }\n\n      if (this.contracts[contractName]) {\n        const method = await this.contracts[contractName].methods[methodName];\n        if (data) {\n          return await method(...data).call();\n        }\n        return await method().call();\n      }\n    } catch (err: any) {\n      debugger;\n      throw new Error(err);\n    }\n    return new Error(`contract ${contractName} didn't created`);\n  }\n\n  async callContractMethodFromNewContract(\n    contractAddress: string,\n    abi: any[],\n    methodName: string,\n    data?: any[],\n  ) {\n    try {\n      const contract = this.getContract(contractAddress, abi);\n      const method = contract.methods[methodName];\n\n      if (data) {\n        return await method(...data).call();\n      }\n      return await method().call();\n    } catch (err: any) {\n      throw new Error(err);\n    }\n  }\n\n  sendTransaction(transactionConfig: any) {\n    return this.web3Provider.eth.sendTransaction({\n      ...transactionConfig,\n      from: this.walletAddress,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var _jsxFileName = \"/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/HOC/TradeWrapper.tsx\";\nimport React from 'react';\nimport { contracts, tokens as configTokens } from '@/config';\nimport { walletConnectorContext } from '@/services/MetamaskConnect';\nimport MetamaskService from '@/services/web3';\nimport { clogError } from '@/utils/logger';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst TradeWrapper = (Component, getExchangeMethod, compProps) => {\n  var _class, _temp;\n\n  return _temp = _class = class TradeWrapperComponent extends React.Component {\n    // eslint-disable-next-line react/static-property-placement\n    // eslint-disable-next-line react/static-property-placement\n    constructor(props) {\n      super(props);\n      this.context = void 0;\n      this.state = {\n        tokensData: localStorage[`refinery-finance-${getExchangeMethod}`] && JSON.parse(localStorage[`refinery-finance-${getExchangeMethod}`]) || {\n          from: {\n            token: undefined,\n            amount: NaN\n          },\n          to: {\n            token: undefined,\n            amount: NaN\n          }\n        },\n        isAllowanceFrom: true,\n        isAllowanceTo: true,\n        tokensResurves: undefined,\n        resurvesInterval: null,\n        pairAddress: '',\n        maxFrom: '',\n        maxTo: '',\n        isLoadingExchange: false,\n        isApproving: false\n      };\n      this.handleChangeTokensData = this.handleChangeTokensData.bind(this);\n      this.handleApproveTokens = this.handleApproveTokens.bind(this);\n      this.handleChangeAllowanceFrom = this.handleChangeAllowanceFrom.bind(this);\n      this.handleChangeAllowanceTo = this.handleChangeAllowanceTo.bind(this);\n      this.handleGetExchange = this.handleGetExchange.bind(this);\n    }\n\n    componentDidMount() {\n      this.handleGetExchange(this.state.tokensData, 'from');\n\n      if (getExchangeMethod !== 'quote') {\n        const interval = setInterval(async () => {\n          if (this.state.pairAddress && this.state.tokensData.from.token && this.state.tokensData.to.token && this.state.tokensData.to.amount && this.state.tokensData.from.amount) {\n            this.handleGetExchange(this.state.tokensData, 'from');\n          }\n        }, 60000);\n        this.setState({\n          resurvesInterval: interval\n        });\n      }\n    }\n\n    componentDidUpdate() {\n      localStorage[`refinery-finance-${getExchangeMethod}`] = JSON.stringify(this.state.tokensData);\n    }\n\n    componentWillUnmount() {\n      if (this.state.resurvesInterval) {\n        clearInterval(this.state.resurvesInterval);\n      }\n    }\n\n    async handleApproveTokens() {\n      try {\n        if (!this.state.isAllowanceFrom && this.state.tokensData.from.token && this.state.tokensData.from.token.symbol.toLowerCase() !== 'bnb') {\n          this.setState({\n            isApproving: true\n          });\n          await this.context.metamaskService.approveToken({\n            contractName: 'ERC20',\n            approvedAddress: contracts.ROUTER.ADDRESS,\n            tokenAddress: this.state.tokensData.from.token.address\n          });\n          this.setState({\n            isAllowanceFrom: true\n          });\n        }\n\n        if (!this.state.isAllowanceTo && this.state.tokensData.to.token && this.state.tokensData.to.token.symbol.toLowerCase() !== 'bnb') {\n          await this.context.metamaskService.approveToken({\n            contractName: 'ERC20',\n            approvedAddress: contracts.ROUTER.ADDRESS,\n            tokenAddress: this.state.tokensData.to.token.address\n          });\n          this.setState({\n            isAllowanceTo: true\n          });\n        }\n\n        this.setState({\n          isApproving: false\n        });\n      } catch (err) {\n        this.setState({\n          isAllowanceFrom: false,\n          isAllowanceTo: false,\n          isApproving: false\n        });\n        clogError('err approve tokens', err);\n      }\n    }\n\n    async handleGetExchange(tokens, type) {\n      if (!tokens.from.token || !tokens.to.token) {\n        return;\n      }\n\n      try {\n        var _tokens$from$token, _tokens$to$token;\n\n        this.setState({\n          isLoadingExchange: true\n        });\n        const isFromBnb = tokens.from.token.symbol.toLowerCase() === 'bnb';\n        const isToBnb = tokens.to.token.symbol.toLowerCase() === 'bnb';\n        const pairAddr = await this.context.metamaskService.callContractMethod('FACTORY', 'getPair', [isFromBnb ? configTokens.wbnb.address[97] : (_tokens$from$token = tokens.from.token) === null || _tokens$from$token === void 0 ? void 0 : _tokens$from$token.address, isToBnb ? configTokens.wbnb.address[97] : (_tokens$to$token = tokens.to.token) === null || _tokens$to$token === void 0 ? void 0 : _tokens$to$token.address], contracts.FACTORY.ADDRESS, contracts.FACTORY.ABI);\n\n        if (pairAddr === '0x0000000000000000000000000000000000000000') {\n          if (type === 'from') {\n            this.setState(prev => {\n              var _prev$tokensData$from, _tokens$from$token2;\n\n              return {\n                tokensResurves: null,\n                pairAddress: '',\n                isLoadingExchange: false,\n                tokensData: {\n                  to: tokens.to,\n                  from: {\n                    token: tokens.from.token,\n                    amount: ((_prev$tokensData$from = prev.tokensData.from.token) === null || _prev$tokensData$from === void 0 ? void 0 : _prev$tokensData$from.symbol) !== ((_tokens$from$token2 = tokens.from.token) === null || _tokens$from$token2 === void 0 ? void 0 : _tokens$from$token2.symbol) ? NaN : tokens.from.amount\n                  }\n                }\n              };\n            });\n          } else {\n            this.setState(prev => {\n              var _prev$tokensData$to$t, _tokens$to$token2;\n\n              return {\n                tokensResurves: null,\n                pairAddress: '',\n                isLoadingExchange: false,\n                tokensData: {\n                  from: tokens.from,\n                  to: {\n                    token: tokens.to.token,\n                    amount: ((_prev$tokensData$to$t = prev.tokensData.to.token) === null || _prev$tokensData$to$t === void 0 ? void 0 : _prev$tokensData$to$t.symbol) !== ((_tokens$to$token2 = tokens.to.token) === null || _tokens$to$token2 === void 0 ? void 0 : _tokens$to$token2.symbol) ? NaN : tokens.to.amount\n                  }\n                }\n              };\n            });\n          }\n\n          return;\n        }\n\n        this.setState({\n          pairAddress: pairAddr,\n          tokensResurves: undefined\n        });\n\n        if (tokens.from.token && tokens.to.token && (tokens.from.amount || tokens.to.amount) && pairAddr) {\n          const token0 = await this.context.metamaskService.callContractMethodFromNewContract(pairAddr, contracts.PAIR.ABI, 'token0');\n          const token1 = await this.context.metamaskService.callContractMethodFromNewContract(pairAddr, contracts.PAIR.ABI, 'token1');\n          const resurves = await this.context.metamaskService.callContractMethodFromNewContract(pairAddr, contracts.PAIR.ABI, 'getReserves');\n          this.setState({\n            tokensResurves: resurves\n          });\n\n          if (type === 'from' && tokens.from.amount || tokens.from.token && tokens.from.amount && !tokens.to.amount) {\n            let resurve1;\n            let resurve2;\n\n            if (tokens.from.token.address.toLowerCase() === token0.toLowerCase()) {\n              resurve1 = resurves['0'];\n              resurve2 = resurves['1'];\n            } else {\n              resurve1 = resurves['1'];\n              resurve2 = resurves['0'];\n            }\n\n            this.setState({\n              maxFrom: MetamaskService.amountFromGwei(resurve1, +tokens.from.token.decimals),\n              maxTo: MetamaskService.amountFromGwei(resurve2, +tokens.to.token.decimals)\n            });\n            const quote = await this.context.metamaskService.callContractMethod('ROUTER', getExchangeMethod, [MetamaskService.calcTransactionAmount(tokens.from.amount, +tokens.from.token.decimals), resurve1, resurve2]);\n            this.setState({\n              tokensData: {\n                from: {\n                  token: tokens.from.token,\n                  amount: tokens.from.amount\n                },\n                to: {\n                  token: tokens.to.token,\n                  amount: MetamaskService.amountFromGwei(quote, +tokens.to.token.decimals)\n                }\n              }\n            });\n          } else if (type === 'to' && tokens.to.amount || tokens.to.token && tokens.to.amount && !tokens.from.amount) {\n            let resurve1;\n            let resurve2;\n\n            if (tokens.to.token.address.toLowerCase() === token1.toLowerCase()) {\n              resurve1 = resurves['1'];\n              resurve2 = resurves['0'];\n            } else {\n              resurve1 = resurves['0'];\n              resurve2 = resurves['1'];\n            }\n\n            this.setState({\n              maxFrom: MetamaskService.amountFromGwei(resurve2, +tokens.from.token.decimals),\n              maxTo: MetamaskService.amountFromGwei(resurve1, +tokens.to.token.decimals)\n            });\n            const quote = await this.context.metamaskService.callContractMethod('ROUTER', getExchangeMethod, [MetamaskService.calcTransactionAmount(tokens.to.amount, +tokens.to.token.decimals), resurve1, resurve2]);\n            this.setState({\n              tokensData: {\n                from: {\n                  token: tokens.from.token,\n                  amount: MetamaskService.amountFromGwei(quote, +tokens.from.token.decimals)\n                },\n                to: {\n                  token: tokens.to.token,\n                  amount: tokens.to.amount\n                }\n              }\n            });\n          } else {\n            this.setState({\n              tokensData: tokens\n            });\n          }\n        } else {\n          this.setState({\n            tokensData: tokens\n          });\n        }\n\n        this.setState({\n          isLoadingExchange: false\n        });\n      } catch (err) {\n        this.setState({\n          isLoadingExchange: false\n        });\n        clogError('get pair', err);\n      }\n    }\n\n    handleChangeAllowanceFrom(value) {\n      this.setState({\n        isAllowanceFrom: value\n      });\n    }\n\n    handleChangeAllowanceTo(value) {\n      this.setState({\n        isAllowanceTo: value\n      });\n    }\n\n    handleChangeTokensData(tokensData, type) {\n      if (tokensData.from.amount === 0 || tokensData.to.amount === 0) {\n        console.log(1);\n      } else if (tokensData.from.token && tokensData.to.token && type) {\n        this.handleGetExchange(tokensData, type);\n      } else {\n        this.setState({\n          tokensData\n        });\n      }\n    }\n\n    render() {\n      return /*#__PURE__*/_jsxDEV(Component, { ...this.props,\n        ...compProps,\n        tokensData: this.state.tokensData,\n        setTokensData: this.handleChangeTokensData,\n        setAllowanceFrom: this.handleChangeAllowanceFrom,\n        setAllowanceTo: this.handleChangeAllowanceTo,\n        isAllowanceFrom: this.state.isAllowanceFrom,\n        isAllowanceTo: this.state.isAllowanceTo,\n        handleApproveTokens: this.handleApproveTokens,\n        tokensResurves: this.state.tokensResurves,\n        maxFrom: this.state.maxFrom,\n        maxTo: this.state.maxTo,\n        isLoadingExchange: this.state.isLoadingExchange,\n        isApproving: this.state.isApproving\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 9\n      }, this);\n    }\n\n  }, _class.contextType = walletConnectorContext, _temp; // TradeWrapperComponent.contextType = walletConnectorContext;\n  // return TradeWrapperComponent;\n};\n\n_c = TradeWrapper;\nexport default TradeWrapper;\n\nvar _c;\n\n$RefreshReg$(_c, \"TradeWrapper\");","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/HOC/TradeWrapper.tsx"],"names":["React","contracts","tokens","configTokens","walletConnectorContext","MetamaskService","clogError","TradeWrapper","Component","getExchangeMethod","compProps","TradeWrapperComponent","constructor","props","context","state","tokensData","localStorage","JSON","parse","from","token","undefined","amount","NaN","to","isAllowanceFrom","isAllowanceTo","tokensResurves","resurvesInterval","pairAddress","maxFrom","maxTo","isLoadingExchange","isApproving","handleChangeTokensData","bind","handleApproveTokens","handleChangeAllowanceFrom","handleChangeAllowanceTo","handleGetExchange","componentDidMount","interval","setInterval","setState","componentDidUpdate","stringify","componentWillUnmount","clearInterval","symbol","toLowerCase","metamaskService","approveToken","contractName","approvedAddress","ROUTER","ADDRESS","tokenAddress","address","err","type","isFromBnb","isToBnb","pairAddr","callContractMethod","wbnb","FACTORY","ABI","prev","token0","callContractMethodFromNewContract","PAIR","token1","resurves","resurve1","resurve2","amountFromGwei","decimals","quote","calcTransactionAmount","value","console","log","render","contextType"],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport { contracts, tokens as configTokens } from '@/config';\nimport { walletConnectorContext } from '@/services/MetamaskConnect';\nimport MetamaskService from '@/services/web3';\nimport { IToken, ITokens } from '@/types';\nimport { clogError } from '@/utils/logger';\n\ninterface ITradeWrapper {\n  isAllowanceFrom: boolean;\n  isAllowanceTo: boolean;\n  tokensData: {\n    from: {\n      token: IToken | undefined;\n      amount: number | string;\n    };\n    to: {\n      token: IToken | undefined;\n      amount: number | string;\n    };\n  };\n  tokensResurves: any;\n  resurvesInterval: any;\n  pairAddress: string;\n  maxFrom: number | string;\n  maxTo: number | string;\n  isLoadingExchange: boolean;\n  isApproving: boolean;\n}\n\nconst TradeWrapper = (\n  Component: React.FC<any>,\n  getExchangeMethod: 'quote' | 'getAmountOut',\n  compProps?: any,\n) => {\n  return class TradeWrapperComponent extends React.Component<any, ITradeWrapper, any> {\n    // eslint-disable-next-line react/static-property-placement\n    static contextType = walletConnectorContext;\n\n    // eslint-disable-next-line react/static-property-placement\n    context!: React.ContextType<typeof walletConnectorContext>;\n\n    constructor(props: any) {\n      super(props);\n\n      this.state = {\n        tokensData: (localStorage[`refinery-finance-${getExchangeMethod}`] &&\n          JSON.parse(localStorage[`refinery-finance-${getExchangeMethod}`])) || {\n          from: {\n            token: undefined,\n            amount: NaN,\n          },\n          to: {\n            token: undefined,\n            amount: NaN,\n          },\n        },\n        isAllowanceFrom: true,\n        isAllowanceTo: true,\n        tokensResurves: undefined,\n        resurvesInterval: null,\n        pairAddress: '',\n        maxFrom: '',\n        maxTo: '',\n        isLoadingExchange: false,\n        isApproving: false,\n      };\n\n      this.handleChangeTokensData = this.handleChangeTokensData.bind(this);\n      this.handleApproveTokens = this.handleApproveTokens.bind(this);\n      this.handleChangeAllowanceFrom = this.handleChangeAllowanceFrom.bind(this);\n      this.handleChangeAllowanceTo = this.handleChangeAllowanceTo.bind(this);\n      this.handleGetExchange = this.handleGetExchange.bind(this);\n    }\n\n    componentDidMount() {\n      this.handleGetExchange(this.state.tokensData, 'from');\n      if (getExchangeMethod !== 'quote') {\n        const interval = setInterval(async () => {\n          if (\n            this.state.pairAddress &&\n            this.state.tokensData.from.token &&\n            this.state.tokensData.to.token &&\n            this.state.tokensData.to.amount &&\n            this.state.tokensData.from.amount\n          ) {\n            this.handleGetExchange(this.state.tokensData, 'from');\n          }\n        }, 60000);\n\n        this.setState({\n          resurvesInterval: interval,\n        });\n      }\n    }\n\n    componentDidUpdate() {\n      localStorage[`refinery-finance-${getExchangeMethod}`] = JSON.stringify(this.state.tokensData);\n    }\n\n    componentWillUnmount() {\n      if (this.state.resurvesInterval) {\n        clearInterval(this.state.resurvesInterval);\n      }\n    }\n\n    async handleApproveTokens() {\n      try {\n        if (\n          !this.state.isAllowanceFrom &&\n          this.state.tokensData.from.token &&\n          this.state.tokensData.from.token.symbol.toLowerCase() !== 'bnb'\n        ) {\n          this.setState({\n            isApproving: true,\n          });\n          await this.context.metamaskService.approveToken({\n            contractName: 'ERC20',\n            approvedAddress: contracts.ROUTER.ADDRESS,\n            tokenAddress: this.state.tokensData.from.token.address,\n          });\n          this.setState({\n            isAllowanceFrom: true,\n          });\n        }\n        if (\n          !this.state.isAllowanceTo &&\n          this.state.tokensData.to.token &&\n          this.state.tokensData.to.token.symbol.toLowerCase() !== 'bnb'\n        ) {\n          await this.context.metamaskService.approveToken({\n            contractName: 'ERC20',\n            approvedAddress: contracts.ROUTER.ADDRESS,\n            tokenAddress: this.state.tokensData.to.token.address,\n          });\n          this.setState({\n            isAllowanceTo: true,\n          });\n        }\n        this.setState({\n          isApproving: false,\n        });\n      } catch (err) {\n        this.setState({\n          isAllowanceFrom: false,\n          isAllowanceTo: false,\n          isApproving: false,\n        });\n        clogError('err approve tokens', err);\n      }\n    }\n\n    async handleGetExchange(tokens: ITokens, type?: 'from' | 'to') {\n      if (!tokens.from.token || !tokens.to.token) {\n        return;\n      }\n      try {\n        this.setState({\n          isLoadingExchange: true,\n        });\n        const isFromBnb = tokens.from.token.symbol.toLowerCase() === 'bnb';\n        const isToBnb = tokens.to.token.symbol.toLowerCase() === 'bnb';\n\n        const pairAddr = await this.context.metamaskService.callContractMethod(\n          'FACTORY',\n          'getPair',\n          [\n            isFromBnb ? configTokens.wbnb.address[97] : tokens.from.token?.address,\n            isToBnb ? configTokens.wbnb.address[97] : tokens.to.token?.address,\n          ],\n          contracts.FACTORY.ADDRESS,\n          contracts.FACTORY.ABI,\n        );\n\n        if (pairAddr === '0x0000000000000000000000000000000000000000') {\n          if (type === 'from') {\n            this.setState((prev) => ({\n              tokensResurves: null,\n              pairAddress: '',\n              isLoadingExchange: false,\n              tokensData: {\n                to: tokens.to,\n                from: {\n                  token: tokens.from.token,\n                  amount:\n                    prev.tokensData.from.token?.symbol !== tokens.from.token?.symbol\n                      ? NaN\n                      : tokens.from.amount,\n                },\n              },\n            }));\n          } else {\n            this.setState((prev) => ({\n              tokensResurves: null,\n              pairAddress: '',\n              isLoadingExchange: false,\n              tokensData: {\n                from: tokens.from,\n                to: {\n                  token: tokens.to.token,\n                  amount:\n                    prev.tokensData.to.token?.symbol !== tokens.to.token?.symbol\n                      ? NaN\n                      : tokens.to.amount,\n                },\n              },\n            }));\n          }\n          return;\n        }\n        this.setState({\n          pairAddress: pairAddr,\n          tokensResurves: undefined,\n        });\n\n        if (\n          tokens.from.token &&\n          tokens.to.token &&\n          (tokens.from.amount || tokens.to.amount) &&\n          pairAddr\n        ) {\n          const token0 = await this.context.metamaskService.callContractMethodFromNewContract(\n            pairAddr,\n            contracts.PAIR.ABI,\n            'token0',\n          );\n\n          const token1 = await this.context.metamaskService.callContractMethodFromNewContract(\n            pairAddr,\n            contracts.PAIR.ABI,\n            'token1',\n          );\n\n          const resurves = await this.context.metamaskService.callContractMethodFromNewContract(\n            pairAddr,\n            contracts.PAIR.ABI,\n            'getReserves',\n          );\n\n          this.setState({\n            tokensResurves: resurves,\n          });\n\n          if (\n            (type === 'from' && tokens.from.amount) ||\n            (tokens.from.token && tokens.from.amount && !tokens.to.amount)\n          ) {\n            let resurve1: number;\n            let resurve2: number;\n            if (tokens.from.token.address.toLowerCase() === token0.toLowerCase()) {\n              resurve1 = resurves['0'];\n              resurve2 = resurves['1'];\n            } else {\n              resurve1 = resurves['1'];\n              resurve2 = resurves['0'];\n            }\n\n            this.setState({\n              maxFrom: MetamaskService.amountFromGwei(resurve1, +tokens.from.token.decimals),\n              maxTo: MetamaskService.amountFromGwei(resurve2, +tokens.to.token.decimals),\n            });\n\n            const quote = await this.context.metamaskService.callContractMethod(\n              'ROUTER',\n              getExchangeMethod,\n              [\n                MetamaskService.calcTransactionAmount(\n                  tokens.from.amount,\n                  +tokens.from.token.decimals,\n                ),\n                resurve1,\n                resurve2,\n              ],\n            );\n\n            this.setState({\n              tokensData: {\n                from: {\n                  token: tokens.from.token,\n                  amount: tokens.from.amount,\n                },\n                to: {\n                  token: tokens.to.token,\n                  amount: MetamaskService.amountFromGwei(quote, +tokens.to.token.decimals),\n                },\n              },\n            });\n          } else if (\n            (type === 'to' && tokens.to.amount) ||\n            (tokens.to.token && tokens.to.amount && !tokens.from.amount)\n          ) {\n            let resurve1: number;\n            let resurve2: number;\n            if (tokens.to.token.address.toLowerCase() === token1.toLowerCase()) {\n              resurve1 = resurves['1'];\n              resurve2 = resurves['0'];\n            } else {\n              resurve1 = resurves['0'];\n              resurve2 = resurves['1'];\n            }\n\n            this.setState({\n              maxFrom: MetamaskService.amountFromGwei(resurve2, +tokens.from.token.decimals),\n              maxTo: MetamaskService.amountFromGwei(resurve1, +tokens.to.token.decimals),\n            });\n\n            const quote = await this.context.metamaskService.callContractMethod(\n              'ROUTER',\n              getExchangeMethod,\n              [\n                MetamaskService.calcTransactionAmount(tokens.to.amount, +tokens.to.token.decimals),\n                resurve1,\n                resurve2,\n              ],\n            );\n\n            this.setState({\n              tokensData: {\n                from: {\n                  token: tokens.from.token,\n                  amount: MetamaskService.amountFromGwei(quote, +tokens.from.token.decimals),\n                },\n                to: {\n                  token: tokens.to.token,\n                  amount: tokens.to.amount,\n                },\n              },\n            });\n          } else {\n            this.setState({\n              tokensData: tokens,\n            });\n          }\n        } else {\n          this.setState({\n            tokensData: tokens,\n          });\n        }\n        this.setState({\n          isLoadingExchange: false,\n        });\n      } catch (err) {\n        this.setState({\n          isLoadingExchange: false,\n        });\n        clogError('get pair', err);\n      }\n    }\n\n    handleChangeAllowanceFrom(value: boolean) {\n      this.setState({\n        isAllowanceFrom: value,\n      });\n    }\n\n    handleChangeAllowanceTo(value: boolean) {\n      this.setState({\n        isAllowanceTo: value,\n      });\n    }\n\n    handleChangeTokensData(tokensData: ITokens, type?: 'from' | 'to') {\n      if (tokensData.from.amount === 0 || tokensData.to.amount === 0) {\n        console.log(1);\n      } else if (tokensData.from.token && tokensData.to.token && type) {\n        this.handleGetExchange(tokensData, type);\n      } else {\n        this.setState({\n          tokensData,\n        });\n      }\n    }\n\n    render() {\n      return (\n        <Component\n          {...this.props}\n          {...compProps}\n          tokensData={this.state.tokensData}\n          setTokensData={this.handleChangeTokensData}\n          setAllowanceFrom={this.handleChangeAllowanceFrom}\n          setAllowanceTo={this.handleChangeAllowanceTo}\n          isAllowanceFrom={this.state.isAllowanceFrom}\n          isAllowanceTo={this.state.isAllowanceTo}\n          handleApproveTokens={this.handleApproveTokens}\n          tokensResurves={this.state.tokensResurves}\n          maxFrom={this.state.maxFrom}\n          maxTo={this.state.maxTo}\n          isLoadingExchange={this.state.isLoadingExchange}\n          isApproving={this.state.isApproving}\n        />\n      );\n    }\n  };\n  // TradeWrapperComponent.contextType = walletConnectorContext;\n\n  // return TradeWrapperComponent;\n};\n\nexport default TradeWrapper;\n"]},"metadata":{},"sourceType":"module"}
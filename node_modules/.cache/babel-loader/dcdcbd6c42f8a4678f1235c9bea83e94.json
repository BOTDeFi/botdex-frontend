{"ast":null,"code":"/**\n * @typedef MarkdownTableOptions\n * @property {string|null|Array.<string|null|undefined>} [align]\n * @property {boolean} [padding=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterEnd=true]\n * @property {boolean} [alignDelimiters=true]\n * @property {(value: string) => number} [stringLength]\n */\n\n/**\n * Create a table from a matrix of strings.\n *\n * @param {Array.<Array.<string|null|undefined>>} table\n * @param {MarkdownTableOptions} [options]\n * @returns {string}\n */\nexport function markdownTable(table, options) {\n  const settings = options || {};\n  const align = (settings.align || []).concat();\n  const stringLength = settings.stringLength || defaultStringLength;\n  /** @type {number[]} Character codes as symbols for alignment per column. */\n\n  const alignments = [];\n  let rowIndex = -1;\n  /** @type {string[][]} Cells per row. */\n\n  const cellMatrix = [];\n  /** @type {number[][]} Sizes of each cell per row. */\n\n  const sizeMatrix = [];\n  /** @type {number[]} */\n\n  const longestCellByColumn = [];\n  let mostCellsPerRow = 0;\n  /** @type {number} */\n\n  let columnIndex;\n  /** @type {string[]} Cells of current row */\n\n  let row;\n  /** @type {number[]} Sizes of current row */\n\n  let sizes;\n  /** @type {number} Sizes of current cell */\n\n  let size;\n  /** @type {string} Current cell */\n\n  let cell;\n  /** @type {string[]} Chunks of current line. */\n\n  let line;\n  /** @type {string} */\n\n  let before;\n  /** @type {string} */\n\n  let after;\n  /** @type {number} */\n\n  let code; // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n\n  while (++rowIndex < table.length) {\n    columnIndex = -1;\n    row = [];\n    sizes = [];\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length;\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      cell = serialize(table[rowIndex][columnIndex]);\n\n      if (settings.alignDelimiters !== false) {\n        size = stringLength(cell);\n        sizes[columnIndex] = size;\n\n        if (longestCellByColumn[columnIndex] === undefined || size > longestCellByColumn[columnIndex]) {\n          longestCellByColumn[columnIndex] = size;\n        }\n      }\n\n      row.push(cell);\n    }\n\n    cellMatrix[rowIndex] = row;\n    sizeMatrix[rowIndex] = sizes;\n  } // Figure out which alignments to use.\n\n\n  columnIndex = -1;\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex]);\n    }\n  } else {\n    code = toAlignment(align);\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code;\n    }\n  } // Inject the alignment row.\n\n\n  columnIndex = -1;\n  row = [];\n  sizes = [];\n\n  while (++columnIndex < mostCellsPerRow) {\n    code = alignments[columnIndex];\n    before = '';\n    after = '';\n\n    if (code === 99\n    /* `c` */\n    ) {\n        before = ':';\n        after = ':';\n      } else if (code === 108\n    /* `l` */\n    ) {\n        before = ':';\n      } else if (code === 114\n    /* `r` */\n    ) {\n        after = ':';\n      } // There *must* be at least one hyphen-minus in each alignment cell.\n\n\n    size = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);\n    cell = before + '-'.repeat(size) + after;\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length;\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size;\n      }\n\n      sizes[columnIndex] = size;\n    }\n\n    row[columnIndex] = cell;\n  } // Inject the alignment row.\n\n\n  cellMatrix.splice(1, 0, row);\n  sizeMatrix.splice(1, 0, sizes);\n  rowIndex = -1;\n  /** @type {string[]} */\n\n  const lines = [];\n\n  while (++rowIndex < cellMatrix.length) {\n    row = cellMatrix[rowIndex];\n    sizes = sizeMatrix[rowIndex];\n    columnIndex = -1;\n    line = [];\n\n    while (++columnIndex < mostCellsPerRow) {\n      cell = row[columnIndex] || '';\n      before = '';\n      after = '';\n\n      if (settings.alignDelimiters !== false) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);\n        code = alignments[columnIndex];\n\n        if (code === 114\n        /* `r` */\n        ) {\n            before = ' '.repeat(size);\n          } else if (code === 99\n        /* `c` */\n        ) {\n            if (size % 2) {\n              before = ' '.repeat(size / 2 + 0.5);\n              after = ' '.repeat(size / 2 - 0.5);\n            } else {\n              before = ' '.repeat(size / 2);\n              after = before;\n            }\n          } else {\n          after = ' '.repeat(size);\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|');\n      }\n\n      if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is\n      // empty: there will be a closing space.\n      !(settings.alignDelimiters === false && cell === '') && (settings.delimiterStart !== false || columnIndex)) {\n        line.push(' ');\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before);\n      }\n\n      line.push(cell);\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after);\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ');\n      }\n\n      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {\n        line.push('|');\n      }\n    }\n\n    lines.push(settings.delimiterEnd === false ? line.join('').replace(/ +$/, '') : line.join(''));\n  }\n\n  return lines.join('\\n');\n}\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value);\n}\n/**\n * @param {string} value\n * @returns {number}\n */\n\n\nfunction defaultStringLength(value) {\n  return value.length;\n}\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\n\n\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.charCodeAt(0) : 0;\n  return code === 67\n  /* `C` */\n  || code === 99\n  /* `c` */\n  ? 99\n  /* `c` */\n  : code === 76\n  /* `L` */\n  || code === 108\n  /* `l` */\n  ? 108\n  /* `l` */\n  : code === 82\n  /* `R` */\n  || code === 114\n  /* `r` */\n  ? 114\n  /* `r` */\n  : 0;\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/markdown-table/index.js"],"names":["markdownTable","table","options","settings","align","concat","stringLength","defaultStringLength","alignments","rowIndex","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","columnIndex","row","sizes","size","cell","line","before","after","code","length","serialize","alignDelimiters","undefined","push","toAlignment","Math","max","repeat","splice","lines","delimiterStart","padding","delimiterEnd","join","replace","value","String","charCodeAt"],"mappings":"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","sourcesContent":["/**\n * @typedef MarkdownTableOptions\n * @property {string|null|Array.<string|null|undefined>} [align]\n * @property {boolean} [padding=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterStart=true]\n * @property {boolean} [delimiterEnd=true]\n * @property {boolean} [alignDelimiters=true]\n * @property {(value: string) => number} [stringLength]\n */\n\n/**\n * Create a table from a matrix of strings.\n *\n * @param {Array.<Array.<string|null|undefined>>} table\n * @param {MarkdownTableOptions} [options]\n * @returns {string}\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {number[]} Character codes as symbols for alignment per column. */\n  const alignments = []\n  let rowIndex = -1\n  /** @type {string[][]} Cells per row. */\n  const cellMatrix = []\n  /** @type {number[][]} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {number[]} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  /** @type {number} */\n  let columnIndex\n  /** @type {string[]} Cells of current row */\n  let row\n  /** @type {number[]} Sizes of current row */\n  let sizes\n  /** @type {number} Sizes of current cell */\n  let size\n  /** @type {string} Current cell */\n  let cell\n  /** @type {string[]} Chunks of current line. */\n  let line\n  /** @type {string} */\n  let before\n  /** @type {string} */\n  let after\n  /** @type {number} */\n  let code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    columnIndex = -1\n    row = []\n    sizes = []\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  row = []\n  sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {string[]} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (settings.alignDelimiters !== false) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.charCodeAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n};\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented');\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code);\n    }\n\n    effects.enter('codeFlowValue');\n    return content(code);\n  }\n  /** @type {State} */\n\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue');\n      return afterPrefix(code);\n    }\n\n    effects.consume(code);\n    return content;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('codeIndented');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return start;\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : markdownLineEnding(code) ? start(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-core-commonmark/lib/code-indented.js"],"names":["factorySpace","markdownLineEnding","codeIndented","name","tokenize","tokenizeCodeIndented","indentedContent","tokenizeIndentedContent","partial","effects","ok","nok","self","start","code","enter","afterStartPrefix","tail","events","length","type","sliceSerialize","afterPrefix","after","attempt","content","exit","consume","parser","lazy","now","line"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented')\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? afterPrefix(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? start(code)\n      : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
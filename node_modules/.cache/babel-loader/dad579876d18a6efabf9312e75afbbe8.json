{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber';\nimport { getAddress, getContractAddress, getContractData } from '@/services/web3/contractHelpers';\nimport rootStore from '@/store';\nimport { toBigNumber } from '@/utils';\nimport { BIG_ONE, BIG_TEN, BIG_ZERO } from '@/utils/constants';\nimport { multicall } from '@/utils/multicall';\nexport const getTokenPricesFromFarms = () => {\n  const farms = rootStore.farms.data.slice();\n  return farms.reduce((prices, farm) => {\n    const quoteTokenAddress = getAddress(farm.quoteToken.address).toLocaleLowerCase();\n    const tokenAddress = getAddress(farm.token.address).toLocaleLowerCase();\n\n    if (farm.quoteToken.busdPrice !== undefined) {\n      if (!prices[quoteTokenAddress]) {\n        prices[quoteTokenAddress] = new BigNumber(farm.quoteToken.busdPrice).toNumber();\n      }\n    }\n\n    if (farm.token.busdPrice !== undefined) {\n      if (!prices[tokenAddress]) {\n        prices[tokenAddress] = new BigNumber(farm.token.busdPrice).toNumber();\n      }\n    }\n\n    return prices;\n  }, {});\n};\n/**\n * Returns the first farm with a quote token that matches from an array of preferred quote tokens\n * @param farms Array of farms\n * @param preferredQuoteTokens Array of preferred quote tokens\n * @returns A preferred farm, if found - or the first element of the farms array\n */\n\nexport const filterFarmsByQuoteToken = (farms, preferredQuoteTokens = ['BUSD', 'WBNB']) => {\n  const preferredFarm = farms.find(farm => {\n    return preferredQuoteTokens.some(quoteToken => {\n      return farm.quoteToken.symbol === quoteToken;\n    });\n  });\n  return preferredFarm || farms[0];\n};\n\nconst getFarmFromTokenSymbol = (farms, tokenSymbol, preferredQuoteTokens) => {\n  const farmsWithTokenSymbol = farms.filter(farm => farm.token.symbol === tokenSymbol);\n  const filteredFarm = filterFarmsByQuoteToken(farmsWithTokenSymbol, preferredQuoteTokens);\n  return filteredFarm;\n};\n\nconst getFarmBaseTokenPrice = (farm, quoteTokenFarm, bnbPriceBusd) => {\n  if (farm.quoteToken.symbol === 'BUSD') {\n    // hasTokenPriceVsQuote\n    return toBigNumber(farm.tokenPriceVsQuote);\n  }\n\n  if (farm.quoteToken.symbol === 'wBNB') {\n    return farm.tokenPriceVsQuote ? bnbPriceBusd.times(farm.tokenPriceVsQuote) : BIG_ZERO;\n  } // We can only calculate profits without a quoteTokenFarm for BUSD/BNB farms\n\n\n  if (!quoteTokenFarm) {\n    return BIG_ZERO;\n  } // Possible alternative farm quoteTokens:\n  // UST (i.e. MIR-UST), pBTC (i.e. PNT-pBTC), BTCB (i.e. bBADGER-BTCB), ETH (i.e. SUSHI-ETH)\n  // If the farm's quote token isn't BUSD or wBNB, we then use the quote token, of the original farm's quote token\n  // i.e. for farm PNT - pBTC we use the pBTC farm's quote token - BNB, (pBTC - BNB)\n  // from the BNB - pBTC price, we can calculate the PNT - BUSD price\n\n\n  if (quoteTokenFarm.quoteToken.symbol === 'WBNB') {\n    const quoteTokenInBusd = bnbPriceBusd.times((quoteTokenFarm === null || quoteTokenFarm === void 0 ? void 0 : quoteTokenFarm.tokenPriceVsQuote) || BIG_ZERO);\n    return farm.tokenPriceVsQuote && quoteTokenInBusd ? new BigNumber(farm.tokenPriceVsQuote).times(quoteTokenInBusd) : BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'BUSD') {\n    const quoteTokenInBusd = quoteTokenFarm.tokenPriceVsQuote;\n    return farm.tokenPriceVsQuote && quoteTokenInBusd ? new BigNumber(farm.tokenPriceVsQuote).times(quoteTokenInBusd) : BIG_ZERO;\n  } // Catch in case token does not have immediate or once-removed BUSD/wBNB quoteToken\n\n\n  return BIG_ZERO;\n};\n\nconst getFarmQuoteTokenPrice = (farm, quoteTokenFarm, bnbPriceBusd) => {\n  if (farm.quoteToken.symbol === 'BUSD') {\n    return BIG_ONE;\n  }\n\n  if (farm.quoteToken.symbol === 'WBNB') {\n    return bnbPriceBusd;\n  }\n\n  if (!quoteTokenFarm) {\n    return BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'WBNB') {\n    return quoteTokenFarm.tokenPriceVsQuote ? bnbPriceBusd.times(quoteTokenFarm.tokenPriceVsQuote) : BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'BUSD') {\n    return toBigNumber(quoteTokenFarm.tokenPriceVsQuote);\n  }\n\n  return BIG_ZERO;\n};\n\nexport const fetchFarmsPrices = async farms => {\n  // TODO: probably bug\n  const bnbBusdFarm = farms.find(farm => farm.pid === 252);\n  const bnbPriceBusd = (bnbBusdFarm === null || bnbBusdFarm === void 0 ? void 0 : bnbBusdFarm.tokenPriceVsQuote) ? BIG_ONE.div(bnbBusdFarm.tokenPriceVsQuote) : BIG_ZERO;\n  const farmsWithPrices = farms.map(farm => {\n    const quoteTokenFarm = getFarmFromTokenSymbol(farms, farm.quoteToken.symbol);\n    const baseTokenPrice = getFarmBaseTokenPrice(farm, quoteTokenFarm, bnbPriceBusd);\n    const quoteTokenPrice = getFarmQuoteTokenPrice(farm, quoteTokenFarm, bnbPriceBusd);\n    const token = { ...farm.token,\n      busdPrice: baseTokenPrice.toJSON()\n    };\n    const quoteToken = { ...farm.quoteToken,\n      busdPrice: quoteTokenPrice.toJSON()\n    };\n    return { ...farm,\n      token,\n      quoteToken\n    };\n  });\n  return farmsWithPrices;\n};\nexport const fetchPublicFarmData = async farm => {\n  const {\n    pid,\n    lpAddresses,\n    token,\n    quoteToken\n  } = farm;\n  const lpAddress = getAddress(lpAddresses);\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n  const calls = [// Balance of token in the LP contract\n  {\n    address: getAddress(token.address),\n    name: 'balanceOf',\n    params: [lpAddress]\n  }, // Balance of quote token on LP contract\n  {\n    address: getAddress(quoteToken.address),\n    name: 'balanceOf',\n    params: [lpAddress]\n  }, // Balance of LP tokens in the master chef contract\n  {\n    address: lpAddress,\n    name: 'balanceOf',\n    params: [masterRefinerAddress]\n  }, // Total supply of LP tokens\n  {\n    address: lpAddress,\n    name: 'totalSupply'\n  }, // Token decimals\n  {\n    address: getAddress(token.address),\n    name: 'decimals'\n  }, // Quote token decimals\n  {\n    address: getAddress(quoteToken.address),\n    name: 'decimals'\n  }];\n  const [, erc20Abi] = getContractData('ERC20');\n  const [tokenBalanceLP, quoteTokenBalanceLP, lpTokenBalanceMC, lpTotalSupply, tokenDecimals, quoteTokenDecimals] = await multicall(erc20Abi, calls); // Ratio in % of LP tokens that are staked in the MC, vs the total number in circulation\n\n  const lpTokenRatio = new BigNumber(lpTokenBalanceMC).div(new BigNumber(lpTotalSupply)); // Raw amount of token in the LP, including those not staked\n\n  const tokenAmountTotal = new BigNumber(tokenBalanceLP).div(BIG_TEN.pow(tokenDecimals));\n  const quoteTokenAmountTotal = new BigNumber(quoteTokenBalanceLP).div(BIG_TEN.pow(quoteTokenDecimals)); // Amount of token in the LP that are staked in the MC (i.e amount of token * lp ratio)\n\n  const tokenAmountMc = tokenAmountTotal.times(lpTokenRatio);\n  const quoteTokenAmountMc = quoteTokenAmountTotal.times(lpTokenRatio); // Total staked in LP, in quote token value\n\n  const lpTotalInQuoteToken = quoteTokenAmountMc.times(new BigNumber(2)); // Only make masterchef calls if farm has pid (there can be farms with \"pid: -1\" which must be excluded)\n\n  const [info, totalAllocPoint] = pid >= 0 ? await multicall(masterRefinerAbi, [{\n    address: masterRefinerAddress,\n    name: 'poolInfo',\n    params: [pid]\n  }, {\n    address: masterRefinerAddress,\n    name: 'totalAllocPoint'\n  }]) : [null, null];\n  const [, allocPointRaw] = info || [];\n  const allocPoint = toBigNumber(allocPointRaw);\n  const poolWeight = totalAllocPoint ? allocPoint.div(new BigNumber(totalAllocPoint)) : BIG_ZERO;\n  return {\n    tokenAmountMc: tokenAmountMc.toJSON(),\n    quoteTokenAmountMc: quoteTokenAmountMc.toJSON(),\n    tokenAmountTotal: tokenAmountTotal.toJSON(),\n    quoteTokenAmountTotal: quoteTokenAmountTotal.toJSON(),\n    lpTotalSupply: new BigNumber(lpTotalSupply).toJSON(),\n    lpTotalInQuoteToken: lpTotalInQuoteToken.toJSON(),\n    tokenPriceVsQuote: quoteTokenAmountTotal.div(tokenAmountTotal).toJSON(),\n    poolWeight: poolWeight.toJSON(),\n    multiplier: `${allocPoint.div(100).toString()}X`\n  };\n};\nexport const fetchFarm = async farm => {\n  const farmPublicData = await fetchPublicFarmData(farm);\n  return { ...farm,\n    ...farmPublicData\n  };\n};\nexport const fetchFarms = farmsToFetch => {\n  return Promise.all(farmsToFetch.map(farmConfig => {\n    return fetchFarm(farmConfig);\n  }));\n};\nexport const fetchFarmUserAllowances = async (account, farmsToFetch) => {\n  const masterRefinerAddress = getContractAddress('MASTER_REFINER');\n  const calls = farmsToFetch.map(farm => {\n    const lpContractAddress = getAddress(farm.lpAddresses);\n    return {\n      address: lpContractAddress,\n      name: 'allowance',\n      params: [account, masterRefinerAddress]\n    };\n  });\n  const [, erc20Abi] = getContractData('ERC20');\n  const rawLpAllowances = await multicall(erc20Abi, calls);\n  const parsedLpAllowances = rawLpAllowances.map(lpBalance => {\n    return new BigNumber(lpBalance).toJSON();\n  });\n  return parsedLpAllowances;\n};\nexport const fetchFarmUserTokenBalances = async (account, farmsToFetch) => {\n  const calls = farmsToFetch.map(farm => {\n    const lpContractAddress = getAddress(farm.lpAddresses);\n    return {\n      address: lpContractAddress,\n      name: 'balanceOf',\n      params: [account]\n    };\n  });\n  const [, erc20Abi] = getContractData('ERC20');\n  const rawTokenBalances = await multicall(erc20Abi, calls);\n  const parsedTokenBalances = rawTokenBalances.map(tokenBalance => {\n    return new BigNumber(tokenBalance).toJSON();\n  });\n  return parsedTokenBalances;\n};\nexport const fetchFarmUserStakedBalances = async (account, farmsToFetch) => {\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n  const calls = farmsToFetch.map(farm => {\n    return {\n      address: masterRefinerAddress,\n      name: 'userInfo',\n      params: [farm.pid, account]\n    };\n  });\n  const rawStakedBalances = await multicall(masterRefinerAbi, calls);\n  const parsedStakedBalances = rawStakedBalances.map(stakedBalance => {\n    return new BigNumber(stakedBalance[0]).toJSON();\n  });\n  return parsedStakedBalances;\n};\nexport const fetchFarmUserEarnings = async (account, farmsToFetch) => {\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n  const calls = farmsToFetch.map(farm => {\n    return {\n      address: masterRefinerAddress,\n      name: 'pendingRP1',\n      params: [farm.pid, account]\n    };\n  });\n  const rawEarnings = await multicall(masterRefinerAbi, calls);\n  const parsedEarnings = rawEarnings.map(earnings => {\n    return new BigNumber(earnings).toJSON();\n  });\n  return parsedEarnings;\n};","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/src/store/farms/index.ts"],"names":["BigNumber","getAddress","getContractAddress","getContractData","rootStore","toBigNumber","BIG_ONE","BIG_TEN","BIG_ZERO","multicall","getTokenPricesFromFarms","farms","data","slice","reduce","prices","farm","quoteTokenAddress","quoteToken","address","toLocaleLowerCase","tokenAddress","token","busdPrice","undefined","toNumber","filterFarmsByQuoteToken","preferredQuoteTokens","preferredFarm","find","some","symbol","getFarmFromTokenSymbol","tokenSymbol","farmsWithTokenSymbol","filter","filteredFarm","getFarmBaseTokenPrice","quoteTokenFarm","bnbPriceBusd","tokenPriceVsQuote","times","quoteTokenInBusd","getFarmQuoteTokenPrice","fetchFarmsPrices","bnbBusdFarm","pid","div","farmsWithPrices","map","baseTokenPrice","quoteTokenPrice","toJSON","fetchPublicFarmData","lpAddresses","lpAddress","masterRefinerAddress","masterRefinerAbi","calls","name","params","erc20Abi","tokenBalanceLP","quoteTokenBalanceLP","lpTokenBalanceMC","lpTotalSupply","tokenDecimals","quoteTokenDecimals","lpTokenRatio","tokenAmountTotal","pow","quoteTokenAmountTotal","tokenAmountMc","quoteTokenAmountMc","lpTotalInQuoteToken","info","totalAllocPoint","allocPointRaw","allocPoint","poolWeight","multiplier","toString","fetchFarm","farmPublicData","fetchFarms","farmsToFetch","Promise","all","farmConfig","fetchFarmUserAllowances","account","lpContractAddress","rawLpAllowances","parsedLpAllowances","lpBalance","fetchFarmUserTokenBalances","rawTokenBalances","parsedTokenBalances","tokenBalance","fetchFarmUserStakedBalances","rawStakedBalances","parsedStakedBalances","stakedBalance","fetchFarmUserEarnings","rawEarnings","parsedEarnings","earnings"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js/bignumber';\n\nimport { getAddress, getContractAddress, getContractData } from '@/services/web3/contractHelpers';\nimport rootStore from '@/store';\nimport { Farm, FarmConfig, SerializedBigNumber } from '@/types';\nimport { toBigNumber } from '@/utils';\nimport { BIG_ONE, BIG_TEN, BIG_ZERO } from '@/utils/constants';\nimport { multicall } from '@/utils/multicall';\n\nexport const getTokenPricesFromFarms = (): Record<string, number> => {\n  const farms = rootStore.farms.data.slice() as Farm[];\n  return farms.reduce((prices: Record<string, number>, farm) => {\n    const quoteTokenAddress = getAddress(farm.quoteToken.address).toLocaleLowerCase();\n    const tokenAddress = getAddress(farm.token.address).toLocaleLowerCase();\n    if (farm.quoteToken.busdPrice !== undefined) {\n      if (!prices[quoteTokenAddress]) {\n        prices[quoteTokenAddress] = new BigNumber(farm.quoteToken.busdPrice).toNumber();\n      }\n    }\n\n    if (farm.token.busdPrice !== undefined) {\n      if (!prices[tokenAddress]) {\n        prices[tokenAddress] = new BigNumber(farm.token.busdPrice).toNumber();\n      }\n    }\n    return prices;\n  }, {});\n};\n\n/**\n * Returns the first farm with a quote token that matches from an array of preferred quote tokens\n * @param farms Array of farms\n * @param preferredQuoteTokens Array of preferred quote tokens\n * @returns A preferred farm, if found - or the first element of the farms array\n */\nexport const filterFarmsByQuoteToken = (\n  farms: Farm[],\n  preferredQuoteTokens: string[] = ['BUSD', 'WBNB'],\n): Farm => {\n  const preferredFarm = farms.find((farm) => {\n    return preferredQuoteTokens.some((quoteToken) => {\n      return farm.quoteToken.symbol === quoteToken;\n    });\n  });\n  return preferredFarm || farms[0];\n};\n\nconst getFarmFromTokenSymbol = (\n  farms: Farm[],\n  tokenSymbol: string,\n  preferredQuoteTokens?: string[],\n): Farm => {\n  const farmsWithTokenSymbol = farms.filter((farm) => farm.token.symbol === tokenSymbol);\n  const filteredFarm = filterFarmsByQuoteToken(farmsWithTokenSymbol, preferredQuoteTokens);\n  return filteredFarm;\n};\n\nconst getFarmBaseTokenPrice = (\n  farm: Farm,\n  quoteTokenFarm: Farm,\n  bnbPriceBusd: BigNumber,\n): BigNumber => {\n  if (farm.quoteToken.symbol === 'BUSD') {\n    // hasTokenPriceVsQuote\n    return toBigNumber(farm.tokenPriceVsQuote);\n  }\n\n  if (farm.quoteToken.symbol === 'wBNB') {\n    return farm.tokenPriceVsQuote ? bnbPriceBusd.times(farm.tokenPriceVsQuote) : BIG_ZERO;\n  }\n\n  // We can only calculate profits without a quoteTokenFarm for BUSD/BNB farms\n  if (!quoteTokenFarm) {\n    return BIG_ZERO;\n  }\n\n  // Possible alternative farm quoteTokens:\n  // UST (i.e. MIR-UST), pBTC (i.e. PNT-pBTC), BTCB (i.e. bBADGER-BTCB), ETH (i.e. SUSHI-ETH)\n  // If the farm's quote token isn't BUSD or wBNB, we then use the quote token, of the original farm's quote token\n  // i.e. for farm PNT - pBTC we use the pBTC farm's quote token - BNB, (pBTC - BNB)\n  // from the BNB - pBTC price, we can calculate the PNT - BUSD price\n  if (quoteTokenFarm.quoteToken.symbol === 'WBNB') {\n    const quoteTokenInBusd = bnbPriceBusd.times(quoteTokenFarm?.tokenPriceVsQuote || BIG_ZERO);\n    return farm.tokenPriceVsQuote && quoteTokenInBusd\n      ? new BigNumber(farm.tokenPriceVsQuote).times(quoteTokenInBusd)\n      : BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'BUSD') {\n    const quoteTokenInBusd = quoteTokenFarm.tokenPriceVsQuote;\n    return farm.tokenPriceVsQuote && quoteTokenInBusd\n      ? new BigNumber(farm.tokenPriceVsQuote).times(quoteTokenInBusd)\n      : BIG_ZERO;\n  }\n\n  // Catch in case token does not have immediate or once-removed BUSD/wBNB quoteToken\n  return BIG_ZERO;\n};\n\nconst getFarmQuoteTokenPrice = (\n  farm: Farm,\n  quoteTokenFarm: Farm,\n  bnbPriceBusd: BigNumber,\n): BigNumber => {\n  if (farm.quoteToken.symbol === 'BUSD') {\n    return BIG_ONE;\n  }\n\n  if (farm.quoteToken.symbol === 'WBNB') {\n    return bnbPriceBusd;\n  }\n\n  if (!quoteTokenFarm) {\n    return BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'WBNB') {\n    return quoteTokenFarm.tokenPriceVsQuote\n      ? bnbPriceBusd.times(quoteTokenFarm.tokenPriceVsQuote)\n      : BIG_ZERO;\n  }\n\n  if (quoteTokenFarm.quoteToken.symbol === 'BUSD') {\n    return toBigNumber(quoteTokenFarm.tokenPriceVsQuote);\n  }\n\n  return BIG_ZERO;\n};\n\nexport const fetchFarmsPrices = async (farms: Farm[]): Promise<Farm[]> => {\n  // TODO: probably bug\n  const bnbBusdFarm = farms.find((farm: Farm) => farm.pid === 252);\n  const bnbPriceBusd = bnbBusdFarm?.tokenPriceVsQuote\n    ? BIG_ONE.div(bnbBusdFarm.tokenPriceVsQuote)\n    : BIG_ZERO;\n\n  const farmsWithPrices = farms.map((farm) => {\n    const quoteTokenFarm = getFarmFromTokenSymbol(farms, farm.quoteToken.symbol);\n    const baseTokenPrice = getFarmBaseTokenPrice(farm, quoteTokenFarm, bnbPriceBusd);\n    const quoteTokenPrice = getFarmQuoteTokenPrice(farm, quoteTokenFarm, bnbPriceBusd);\n    const token = { ...farm.token, busdPrice: baseTokenPrice.toJSON() };\n    const quoteToken = { ...farm.quoteToken, busdPrice: quoteTokenPrice.toJSON() };\n    return { ...farm, token, quoteToken };\n  });\n\n  return farmsWithPrices;\n};\n\ntype PublicFarmData = {\n  tokenAmountMc: SerializedBigNumber;\n  quoteTokenAmountMc: SerializedBigNumber;\n  tokenAmountTotal: SerializedBigNumber;\n  quoteTokenAmountTotal: SerializedBigNumber;\n  lpTotalInQuoteToken: SerializedBigNumber;\n  lpTotalSupply: SerializedBigNumber;\n  tokenPriceVsQuote: SerializedBigNumber;\n  poolWeight: SerializedBigNumber;\n  multiplier: string;\n};\n\nexport const fetchPublicFarmData = async (farm: Farm): Promise<PublicFarmData> => {\n  const { pid, lpAddresses, token, quoteToken } = farm;\n  const lpAddress = getAddress(lpAddresses);\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n  const calls = [\n    // Balance of token in the LP contract\n    {\n      address: getAddress(token.address),\n      name: 'balanceOf',\n      params: [lpAddress],\n    },\n    // Balance of quote token on LP contract\n    {\n      address: getAddress(quoteToken.address),\n      name: 'balanceOf',\n      params: [lpAddress],\n    },\n    // Balance of LP tokens in the master chef contract\n    {\n      address: lpAddress,\n      name: 'balanceOf',\n      params: [masterRefinerAddress],\n    },\n    // Total supply of LP tokens\n    {\n      address: lpAddress,\n      name: 'totalSupply',\n    },\n    // Token decimals\n    {\n      address: getAddress(token.address),\n      name: 'decimals',\n    },\n    // Quote token decimals\n    {\n      address: getAddress(quoteToken.address),\n      name: 'decimals',\n    },\n  ];\n\n  const [, erc20Abi] = getContractData('ERC20');\n  const [\n    tokenBalanceLP,\n    quoteTokenBalanceLP,\n    lpTokenBalanceMC,\n    lpTotalSupply,\n    tokenDecimals,\n    quoteTokenDecimals,\n  ] = await multicall(erc20Abi, calls);\n\n  // Ratio in % of LP tokens that are staked in the MC, vs the total number in circulation\n  const lpTokenRatio = new BigNumber(lpTokenBalanceMC).div(new BigNumber(lpTotalSupply));\n\n  // Raw amount of token in the LP, including those not staked\n  const tokenAmountTotal = new BigNumber(tokenBalanceLP).div(BIG_TEN.pow(tokenDecimals));\n  const quoteTokenAmountTotal = new BigNumber(quoteTokenBalanceLP).div(\n    BIG_TEN.pow(quoteTokenDecimals),\n  );\n\n  // Amount of token in the LP that are staked in the MC (i.e amount of token * lp ratio)\n  const tokenAmountMc = tokenAmountTotal.times(lpTokenRatio);\n  const quoteTokenAmountMc = quoteTokenAmountTotal.times(lpTokenRatio);\n\n  // Total staked in LP, in quote token value\n  const lpTotalInQuoteToken = quoteTokenAmountMc.times(new BigNumber(2));\n\n  // Only make masterchef calls if farm has pid (there can be farms with \"pid: -1\" which must be excluded)\n  const [info, totalAllocPoint] =\n    pid >= 0\n      ? await multicall(masterRefinerAbi, [\n          {\n            address: masterRefinerAddress,\n            name: 'poolInfo',\n            params: [pid],\n          },\n          {\n            address: masterRefinerAddress,\n            name: 'totalAllocPoint',\n          },\n        ])\n      : [null, null];\n\n  const [, allocPointRaw] = info || [];\n  const allocPoint = toBigNumber(allocPointRaw);\n  const poolWeight = totalAllocPoint ? allocPoint.div(new BigNumber(totalAllocPoint)) : BIG_ZERO;\n\n  return {\n    tokenAmountMc: tokenAmountMc.toJSON(),\n    quoteTokenAmountMc: quoteTokenAmountMc.toJSON(),\n    tokenAmountTotal: tokenAmountTotal.toJSON(),\n    quoteTokenAmountTotal: quoteTokenAmountTotal.toJSON(),\n    lpTotalSupply: new BigNumber(lpTotalSupply).toJSON(),\n    lpTotalInQuoteToken: lpTotalInQuoteToken.toJSON(),\n    tokenPriceVsQuote: quoteTokenAmountTotal.div(tokenAmountTotal).toJSON(),\n    poolWeight: poolWeight.toJSON(),\n    multiplier: `${allocPoint.div(100).toString()}X`,\n  };\n};\n\nexport const fetchFarm = async (farm: Farm): Promise<Farm> => {\n  const farmPublicData = await fetchPublicFarmData(farm);\n  return { ...farm, ...farmPublicData };\n};\n\nexport const fetchFarms = (farmsToFetch: FarmConfig[]): Promise<Farm[]> => {\n  return Promise.all(\n    farmsToFetch.map((farmConfig) => {\n      return fetchFarm(farmConfig);\n    }),\n  );\n};\n\nexport const fetchFarmUserAllowances = async (account: string, farmsToFetch: FarmConfig[]) => {\n  const masterRefinerAddress = getContractAddress('MASTER_REFINER');\n\n  const calls = farmsToFetch.map((farm) => {\n    const lpContractAddress = getAddress(farm.lpAddresses);\n    return {\n      address: lpContractAddress,\n      name: 'allowance',\n      params: [account, masterRefinerAddress],\n    };\n  });\n\n  const [, erc20Abi] = getContractData('ERC20');\n  const rawLpAllowances = await multicall(erc20Abi, calls);\n  const parsedLpAllowances = rawLpAllowances.map((lpBalance: any) => {\n    return new BigNumber(lpBalance).toJSON();\n  });\n  return parsedLpAllowances;\n};\n\nexport const fetchFarmUserTokenBalances = async (account: string, farmsToFetch: FarmConfig[]) => {\n  const calls = farmsToFetch.map((farm) => {\n    const lpContractAddress = getAddress(farm.lpAddresses);\n    return {\n      address: lpContractAddress,\n      name: 'balanceOf',\n      params: [account],\n    };\n  });\n\n  const [, erc20Abi] = getContractData('ERC20');\n  const rawTokenBalances = await multicall(erc20Abi, calls);\n  const parsedTokenBalances = rawTokenBalances.map((tokenBalance: any) => {\n    return new BigNumber(tokenBalance).toJSON();\n  });\n  return parsedTokenBalances;\n};\n\nexport const fetchFarmUserStakedBalances = async (account: string, farmsToFetch: FarmConfig[]) => {\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n\n  const calls = farmsToFetch.map((farm) => {\n    return {\n      address: masterRefinerAddress,\n      name: 'userInfo',\n      params: [farm.pid, account],\n    };\n  });\n\n  const rawStakedBalances = await multicall(masterRefinerAbi, calls);\n  const parsedStakedBalances = rawStakedBalances.map((stakedBalance: any) => {\n    return new BigNumber(stakedBalance[0]).toJSON();\n  });\n  return parsedStakedBalances;\n};\n\nexport const fetchFarmUserEarnings = async (account: string, farmsToFetch: FarmConfig[]) => {\n  const [masterRefinerAddress, masterRefinerAbi] = getContractData('MASTER_REFINER');\n\n  const calls = farmsToFetch.map((farm) => {\n    return {\n      address: masterRefinerAddress,\n      name: 'pendingRP1',\n      params: [farm.pid, account],\n    };\n  });\n\n  const rawEarnings = await multicall(masterRefinerAbi, calls);\n  const parsedEarnings = rawEarnings.map((earnings: any) => {\n    return new BigNumber(earnings).toJSON();\n  });\n  return parsedEarnings;\n};\n"]},"metadata":{},"sourceType":"module"}
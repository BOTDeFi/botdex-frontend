{"ast":null,"code":"/**\n * @typedef Options Configuration.\n * @property {Test} [ignore] `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Object.<string, Replace>} FindAndReplaceSchema\n * @typedef {Array.<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array.<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array.<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\nimport escape from 'escape-string-regexp';\nimport { visitParents } from 'unist-util-visit-parents';\nimport { convert } from 'unist-util-is';\nconst own = {}.hasOwnProperty;\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\n\nexport const findAndReplace =\n/**\n * @type {(\n *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n * )}\n **/\n\n/**\n * @param {Node} tree\n * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n * @param {Replace|Options} [replace]\n * @param {Options} [options]\n */\nfunction (tree, find, replace, options) {\n  /** @type {Options|undefined} */\n  let settings;\n  /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n\n  let schema;\n\n  if (typeof find === 'string' || find instanceof RegExp) {\n    // @ts-expect-error don’t expect options twice.\n    schema = [[find, replace]];\n    settings = options;\n  } else {\n    schema = find; // @ts-expect-error don’t expect replace twice.\n\n    settings = replace;\n  }\n\n  if (!settings) {\n    settings = {};\n  }\n\n  const ignored = convert(settings.ignore || []);\n  const pairs = toPairs(schema);\n  let pairIndex = -1;\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor);\n  }\n\n  return tree;\n  /** @type {import('unist-util-visit-parents').Visitor<Text>} */\n\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parent|undefined} */\n\n    let grandparent;\n\n    while (++index < parents.length) {\n      const parent =\n      /** @type {Parent} */\n      parents[index];\n\n      if (ignored(parent, // @ts-expect-error mdast vs. unist parent.\n      grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n\n      grandparent = parent;\n    }\n\n    if (grandparent) {\n      return handler(node, grandparent);\n    }\n  }\n  /**\n   * @param {Text} node\n   * @param {Parent} parent\n   * @returns {VisitorResult}\n   */\n\n\n  function handler(node, parent) {\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0; // @ts-expect-error: TS is wrong, some of these children can be text.\n\n    let index = parent.children.indexOf(node);\n    /** @type {Array.<PhrasingContent>} */\n\n    let nodes = [];\n    /** @type {number|undefined} */\n\n    let position;\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n\n    while (match) {\n      position = match.index; // @ts-expect-error this is perfectly fine, typescript.\n\n      let value = replace(...match, {\n        index: match.index,\n        input: match.input\n      });\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      }\n\n      if (value !== false) {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n\n        start = position + match[0].length;\n      }\n\n      if (!find.global) {\n        break;\n      }\n\n      match = find.exec(node.value);\n    }\n\n    if (position === undefined) {\n      nodes = [node];\n      index--;\n    } else {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n\n      parent.children.splice(index, 1, ...nodes);\n    }\n\n    return index + nodes.length + 1;\n  }\n};\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\n\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = [];\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema');\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1;\n\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    /** @type {string} */\n    let key;\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\n\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\n\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace;\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/mdast-util-find-and-replace/index.js"],"names":["escape","visitParents","convert","own","hasOwnProperty","findAndReplace","tree","find","replace","options","settings","schema","RegExp","ignored","ignore","pairs","toPairs","pairIndex","length","visitor","node","parents","index","grandparent","parent","children","indexOf","undefined","handler","start","nodes","position","lastIndex","match","exec","value","input","type","push","slice","Array","isArray","global","splice","result","TypeError","toExpression","toFunction","key","call"],"mappings":"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","sourcesContent":["/**\n * @typedef Options Configuration.\n * @property {Test} [ignore] `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Object.<string, Replace>} FindAndReplaceSchema\n * @typedef {Array.<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array.<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array.<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n   *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n   * )}\n   **/\n  (\n    /**\n     * @param {Node} tree\n     * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n     * @param {Replace|Options} [replace]\n     * @param {Options} [options]\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      return tree\n\n      /** @type {import('unist-util-visit-parents').Visitor<Text>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent|undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = /** @type {Parent} */ (parents[index])\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error mdast vs. unist parent.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, grandparent)\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @param {Parent} parent\n       * @returns {VisitorResult}\n       */\n      function handler(node, parent) {\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        let index = parent.children.indexOf(node)\n        /** @type {Array.<PhrasingContent>} */\n        let nodes = []\n        /** @type {number|undefined} */\n        let position\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          position = match.index\n          // @ts-expect-error this is perfectly fine, typescript.\n          let value = replace(...match, {\n            index: match.index,\n            input: match.input\n          })\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (position === undefined) {\n          nodes = [node]\n          index--\n        } else {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        }\n\n        return index + nodes.length + 1\n      }\n    }\n  )\n\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, asciiDigit, markdownLineEndingOrSpace, markdownLineEnding, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n};\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n};\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n};\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n/** @type {ConstructRecord} */\n\nconst text = {};\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n};\nlet code = 48; // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\n\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, httpAutolink];\ntext[104] = [emailAutolink, httpAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean} */\n\n  let hasDot;\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n  /** @type {State} */\n\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n\n    if (code === 64) {\n      effects.consume(code);\n      return label;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code);\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code);\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true;\n      }\n\n      effects.consume(code);\n      return label;\n    }\n\n    return done(code);\n  }\n  /** @type {State} */\n\n\n  function dotContinuation(code) {\n    effects.consume(code);\n    hasDot = true;\n    hasDigitInLastSegment = undefined;\n    return label;\n  }\n  /** @type {State} */\n\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code);\n    return afterDashOrUnderscore;\n  }\n  /** @type {State} */\n\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code);\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 87 && code !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 72 && code !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkHttp');\n    effects.consume(code);\n    return t1;\n  }\n  /** @type {State} */\n\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return t2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return p;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code);\n      return s;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code);\n      return colon;\n    }\n\n    return colon(code);\n  }\n  /** @type {State} */\n\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code);\n      return slash1;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return slash2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || asciiControl(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, done), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return w2;\n  }\n  /** @type {State} */\n\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return w3;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return dot;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment;\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment;\n  return domain;\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, done, punctuationContinuation)(code);\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code);\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n\n    if (code === null || asciiControl(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return done(code);\n    }\n\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;\n      hasUnderscoreInLastSegment = undefined;\n      effects.consume(code);\n      return domain;\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true;\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0;\n  return inPath;\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, ok, continuedPunctuation)(code);\n    }\n\n    if (code === 40) {\n      balance++;\n    }\n\n    if (code === 41) {\n      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code);\n    }\n\n    if (pathEnd(code)) {\n      return ok(code);\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code);\n    }\n\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function continuedPunctuation(code) {\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function parenAtPathEnd(code) {\n    balance--;\n    return balance < 0 ? ok(code) : continuedPunctuation(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if (code === 59) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return after;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code);\n      return after;\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction trailingPunctuation(code) {\n  return code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 95 || code === 126;\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code);\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n/** @type {Previous} */\n\n\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 126 || markdownLineEndingOrSpace(code);\n}\n/** @type {Previous} */\n\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code);\n}\n/** @type {Previous} */\n\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code);\n}\n/**\n * @param {Event[]} events\n * @returns {boolean}\n */\n\n\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n\n  while (index--) {\n    const token = events[index][1];\n\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/rocknblock/Documents/GitHub/strong-hands-frontend/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"],"names":["asciiAlpha","asciiAlphanumeric","asciiControl","asciiDigit","markdownLineEndingOrSpace","markdownLineEnding","unicodePunctuation","unicodeWhitespace","www","tokenize","tokenizeWww","partial","domain","tokenizeDomain","path","tokenizePath","punctuation","tokenizePunctuation","namedCharacterReference","tokenizeNamedCharacterReference","wwwAutolink","tokenizeWwwAutolink","previous","previousWww","httpAutolink","tokenizeHttpAutolink","previousHttp","emailAutolink","tokenizeEmailAutolink","previousEmail","text","gfmAutolinkLiteral","code","effects","ok","nok","self","hasDot","hasDigitInLastSegment","start","gfmAtext","previousUnbalanced","events","enter","atext","consume","label","check","done","dotContinuation","dashOrUnderscoreContinuation","undefined","afterDashOrUnderscore","exit","attempt","t1","t2","p","s","colon","slash1","slash2","after","w2","w3","dot","hasUnderscoreInLastSegment","hasUnderscoreInLastLastSegment","punctuationContinuation","balance","inPath","continuedPunctuation","parenAtPathEnd","pathEnd","trailingPunctuation","inside","index","length","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  asciiDigit,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n}\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n/** @type {ConstructRecord} */\n\nconst text = {}\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48 // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\n\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean} */\n\n  let hasDot\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true\n      }\n\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    hasDigitInLastSegment = undefined\n    return label\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww') // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 72 && code !== 104) ||\n      !previousHttp(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return w2\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment\n  return domain\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (\n      code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0\n  return inPath\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (code === 40) {\n      balance++\n    }\n\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return (\n    code === 33 ||\n    code === 34 ||\n    code === 39 ||\n    code === 41 ||\n    code === 42 ||\n    code === 44 ||\n    code === 46 ||\n    code === 58 ||\n    code === 59 ||\n    code === 60 ||\n    code === 63 ||\n    code === 95 ||\n    code === 126\n  )\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code)\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code)\n}\n/**\n * @param {Event[]} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Reaction, _allowStateChanges, _allowStateReadsStart, _allowStateReadsEnd, $mobx, createAtom, untracked, isObservableMap, isObservableObject, isObservableArray, observable } from 'mobx';\nimport React__default, { PureComponent, Component, forwardRef, memo, createElement } from 'react';\nimport { isUsingStaticRendering, Observer, observer as observer$1 } from 'mobx-react-lite';\nexport { Observer, enableStaticRendering, isUsingStaticRendering, observerBatching, useAsObservableSource, useLocalObservable, useLocalStore, useObserver, useStaticRendering } from 'mobx-react-lite';\nvar symbolId = 0;\n\nfunction createSymbol(name) {\n  if (typeof Symbol === \"function\") {\n    return Symbol(name);\n  }\n\n  var symbol = \"__$mobx-react \" + name + \" (\" + symbolId + \")\";\n  symbolId++;\n  return symbol;\n}\n\nvar createdSymbols = {};\n\nfunction newSymbol(name) {\n  if (!createdSymbols[name]) {\n    createdSymbols[name] = createSymbol(name);\n  }\n\n  return createdSymbols[name];\n}\n\nfunction shallowEqual(objA, objB) {\n  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\n\n\nvar hoistBlackList = {\n  $$typeof: 1,\n  render: 1,\n  compare: 1,\n  type: 1,\n  childContextTypes: 1,\n  contextType: 1,\n  contextTypes: 1,\n  defaultProps: 1,\n  getDefaultProps: 1,\n  getDerivedStateFromError: 1,\n  getDerivedStateFromProps: 1,\n  mixins: 1,\n  displayName: 1,\n  propTypes: 1\n};\n\nfunction copyStaticProperties(base, target) {\n  var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n  Object.getOwnPropertyNames(base).forEach(function (key) {\n    if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n/**\r\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\r\n * @param target\r\n * @param prop\r\n * @param value\r\n */\n\n\nfunction setHiddenProp(target, prop, value) {\n  if (!Object.hasOwnProperty.call(target, prop)) {\n    Object.defineProperty(target, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    target[prop] = value;\n  }\n}\n/**\r\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\r\n * and the handler provided by mobx-react\r\n */\n\n\nvar mobxMixins = /*#__PURE__*/newSymbol(\"patchMixins\");\nvar mobxPatchedDefinition = /*#__PURE__*/newSymbol(\"patchedDefinition\");\n\nfunction getMixins(target, methodName) {\n  var mixins = target[mobxMixins] = target[mobxMixins] || {};\n  var methodMixins = mixins[methodName] = mixins[methodName] || {};\n  methodMixins.locks = methodMixins.locks || 0;\n  methodMixins.methods = methodMixins.methods || [];\n  return methodMixins;\n}\n\nfunction wrapper(realMethod, mixins) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  } // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n\n\n  mixins.locks++;\n\n  try {\n    var retVal;\n\n    if (realMethod !== undefined && realMethod !== null) {\n      retVal = realMethod.apply(this, args);\n    }\n\n    return retVal;\n  } finally {\n    mixins.locks--;\n\n    if (mixins.locks === 0) {\n      mixins.methods.forEach(function (mx) {\n        mx.apply(_this, args);\n      });\n    }\n  }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n  var fn = function fn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));\n  };\n\n  return fn;\n}\n\nfunction patch(target, methodName, mixinMethod) {\n  var mixins = getMixins(target, methodName);\n\n  if (mixins.methods.indexOf(mixinMethod) < 0) {\n    mixins.methods.push(mixinMethod);\n  }\n\n  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n\n  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n    // already patched definition, do not repatch\n    return;\n  }\n\n  var originalMethod = target[methodName];\n  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n  Object.defineProperty(target, methodName, newDefinition);\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n  var _ref;\n\n  var wrappedFunc = wrapFunction(originalMethod, mixins);\n  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {\n    return wrappedFunc;\n  }, _ref.set = function set(value) {\n    if (this === target) {\n      wrappedFunc = wrapFunction(value, mixins);\n    } else {\n      // when it is an instance of the prototype/a child prototype patch that particular case again separately\n      // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n      // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n      // as the method for the instance\n      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n      Object.defineProperty(this, methodName, newDefinition);\n    }\n  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;\n}\n\nvar mobxAdminProperty = $mobx || \"$mobx\";\nvar mobxObserverProperty = /*#__PURE__*/newSymbol(\"isMobXReactObserver\");\nvar mobxIsUnmounted = /*#__PURE__*/newSymbol(\"isUnmounted\");\nvar skipRenderKey = /*#__PURE__*/newSymbol(\"skipRender\");\nvar isForcingUpdateKey = /*#__PURE__*/newSymbol(\"isForcingUpdate\");\n\nfunction makeClassComponentObserver(componentClass) {\n  var target = componentClass.prototype;\n\n  if (componentClass[mobxObserverProperty]) {\n    var displayName = getDisplayName(target);\n    console.warn(\"The provided component class (\" + displayName + \") \\n                has already been declared as an observer component.\");\n  } else {\n    componentClass[mobxObserverProperty] = true;\n  }\n\n  if (target.componentWillReact) throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n\n  if (componentClass[\"__proto__\"] !== PureComponent) {\n    if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU;else if (target.shouldComponentUpdate !== observerSCU) // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n      throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n  } // this.props and this.state are made observable, just to make sure @computed fields that\n  // are defined inside the component, and which rely on state or props, re-compute if state or props change\n  // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n  // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n\n\n  makeObservableProp(target, \"props\");\n  makeObservableProp(target, \"state\");\n  var baseRender = target.render;\n\n  target.render = function () {\n    return makeComponentReactive.call(this, baseRender);\n  };\n\n  patch(target, \"componentWillUnmount\", function () {\n    var _this$render$mobxAdmi;\n\n    if (isUsingStaticRendering() === true) return;\n    (_this$render$mobxAdmi = this.render[mobxAdminProperty]) == null ? void 0 : _this$render$mobxAdmi.dispose();\n    this[mobxIsUnmounted] = true;\n\n    if (!this.render[mobxAdminProperty]) {\n      // Render may have been hot-swapped and/or overriden by a subclass.\n      var _displayName = getDisplayName(this);\n\n      console.warn(\"The reactive render of an observer class component (\" + _displayName + \") \\n                was overriden after MobX attached. This may result in a memory leak if the \\n                overriden reactive render was not properly disposed.\");\n    }\n  });\n  return componentClass;\n} // Generates a friendly name for debugging\n\n\nfunction getDisplayName(comp) {\n  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || \"<component>\";\n}\n\nfunction makeComponentReactive(render) {\n  var _this = this;\n\n  if (isUsingStaticRendering() === true) return render.call(this);\n  /**\r\n   * If props are shallowly modified, react will render anyway,\r\n   * so atom.reportChanged() should not result in yet another re-render\r\n   */\n\n  setHiddenProp(this, skipRenderKey, false);\n  /**\r\n   * forceUpdate will re-assign this.props. We don't want that to cause a loop,\r\n   * so detect these changes\r\n   */\n\n  setHiddenProp(this, isForcingUpdateKey, false);\n  var initialName = getDisplayName(this);\n  var baseRender = render.bind(this);\n  var isRenderingPending = false;\n  var reaction = new Reaction(initialName + \".render()\", function () {\n    if (!isRenderingPending) {\n      // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n      // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n      // See #85 / Pull #44\n      isRenderingPending = true;\n\n      if (_this[mobxIsUnmounted] !== true) {\n        var hasError = true;\n\n        try {\n          setHiddenProp(_this, isForcingUpdateKey, true);\n          if (!_this[skipRenderKey]) Component.prototype.forceUpdate.call(_this);\n          hasError = false;\n        } finally {\n          setHiddenProp(_this, isForcingUpdateKey, false);\n          if (hasError) reaction.dispose();\n        }\n      }\n    }\n  });\n  reaction[\"reactComponent\"] = this;\n  reactiveRender[mobxAdminProperty] = reaction;\n  this.render = reactiveRender;\n\n  function reactiveRender() {\n    isRenderingPending = false;\n    var exception = undefined;\n    var rendering = undefined;\n    reaction.track(function () {\n      try {\n        rendering = _allowStateChanges(false, baseRender);\n      } catch (e) {\n        exception = e;\n      }\n    });\n\n    if (exception) {\n      throw exception;\n    }\n\n    return rendering;\n  }\n\n  return reactiveRender.call(this);\n}\n\nfunction observerSCU(nextProps, nextState) {\n  if (isUsingStaticRendering()) {\n    console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n  } // update on any state changes (as is the default)\n\n\n  if (this.state !== nextState) {\n    return true;\n  } // update if props are shallowly not equal, inspired by PureRenderMixin\n  // we could return just 'false' here, and avoid the `skipRender` checks etc\n  // however, it is nicer if lifecycle events are triggered like usually,\n  // so we return true here if props are shallowly modified.\n\n\n  return !shallowEqual(this.props, nextProps);\n}\n\nfunction makeObservableProp(target, propName) {\n  var valueHolderKey = newSymbol(\"reactProp_\" + propName + \"_valueHolder\");\n  var atomHolderKey = newSymbol(\"reactProp_\" + propName + \"_atomHolder\");\n\n  function getAtom() {\n    if (!this[atomHolderKey]) {\n      setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName));\n    }\n\n    return this[atomHolderKey];\n  }\n\n  Object.defineProperty(target, propName, {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      var prevReadState = false;\n\n      if (_allowStateReadsStart && _allowStateReadsEnd) {\n        prevReadState = _allowStateReadsStart(true);\n      }\n\n      getAtom.call(this).reportObserved();\n\n      if (_allowStateReadsStart && _allowStateReadsEnd) {\n        _allowStateReadsEnd(prevReadState);\n      }\n\n      return this[valueHolderKey];\n    },\n    set: function set(v) {\n      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n        setHiddenProp(this, valueHolderKey, v);\n        setHiddenProp(this, skipRenderKey, true);\n        getAtom.call(this).reportChanged();\n        setHiddenProp(this, skipRenderKey, false);\n      } else {\n        setHiddenProp(this, valueHolderKey, v);\n      }\n    }\n  });\n}\n\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"]; // Using react-is had some issues (and operates on elements, not on types), see #608 / #609\n\nvar ReactForwardRefSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.forward_ref\") : typeof forwardRef === \"function\" && /*#__PURE__*/forwardRef(function (props) {\n  return null;\n})[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.memo\") : typeof memo === \"function\" && /*#__PURE__*/memo(function (props) {\n  return null;\n})[\"$$typeof\"];\n/**\r\n * Observer function / decorator\r\n */\n\nfunction observer(component) {\n  if (component[\"isMobxInjector\"] === true) {\n    console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n  }\n\n  if (ReactMemoSymbol && component[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\");\n  } // Unwrap forward refs into `<Observer>` component\n  // we need to unwrap the render, because it is the inner render that needs to be tracked,\n  // not the ForwardRef HoC\n\n\n  if (ReactForwardRefSymbol && component[\"$$typeof\"] === ReactForwardRefSymbol) {\n    var baseRender = component[\"render\"];\n    if (typeof baseRender !== \"function\") throw new Error(\"render property of ForwardRef was not a function\");\n    return forwardRef(function ObserverForwardRef() {\n      var args = arguments;\n      return createElement(Observer, null, function () {\n        return baseRender.apply(undefined, args);\n      });\n    });\n  } // Function component\n\n\n  if (typeof component === \"function\" && (!component.prototype || !component.prototype.render) && !component[\"isReactClass\"] && !Object.prototype.isPrototypeOf.call(Component, component)) {\n    return observer$1(component);\n  }\n\n  return makeClassComponentObserver(component);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar MobXProviderContext = /*#__PURE__*/React__default.createContext({});\n\nfunction Provider(props) {\n  var children = props.children,\n      stores = _objectWithoutPropertiesLoose(props, [\"children\"]);\n\n  var parentValue = React__default.useContext(MobXProviderContext);\n  var mutableProviderRef = React__default.useRef(_extends({}, parentValue, stores));\n  var value = mutableProviderRef.current;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var newValue = _extends({}, value, stores); // spread in previous state for the context based stores\n\n\n    if (!shallowEqual(value, newValue)) {\n      throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n    }\n  }\n\n  return React__default.createElement(MobXProviderContext.Provider, {\n    value: value\n  }, children);\n}\n\nProvider.displayName = \"MobXProvider\";\n/**\r\n * Store Injection\r\n */\n\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n  // Support forward refs\n  var Injector = React__default.forwardRef(function (props, ref) {\n    var newProps = _extends({}, props);\n\n    var context = React__default.useContext(MobXProviderContext);\n    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n\n    if (ref) {\n      newProps.ref = ref;\n    }\n\n    return React__default.createElement(component, newProps);\n  });\n  if (makeReactive) Injector = observer(Injector);\n  Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n  // Static fields from component should be visible on the generated Injector\n\n  copyStaticProperties(component, Injector);\n  Injector[\"wrappedComponent\"] = component;\n  Injector.displayName = getInjectName(component, injectNames);\n  return Injector;\n}\n\nfunction getInjectName(component, injectNames) {\n  var displayName;\n  var componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n  if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";else displayName = \"inject(\" + componentName + \")\";\n  return displayName;\n}\n\nfunction grabStoresByName(storeNames) {\n  return function (baseStores, nextProps) {\n    storeNames.forEach(function (storeName) {\n      if (storeName in nextProps // prefer props over stores\n      ) return;\n      if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n      nextProps[storeName] = baseStores[storeName];\n    });\n    return nextProps;\n  };\n}\n/**\r\n * higher order component that injects stores to a child.\r\n * takes either a varargs list of strings, which are stores read from the context,\r\n * or a function that manually maps the available stores from the context to props:\r\n * storesToProps(mobxStores, props, context) => newProps\r\n */\n\n\nfunction inject() {\n  for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    storeNames[_key] = arguments[_key];\n  }\n\n  if (typeof arguments[0] === \"function\") {\n    var grabStoresFn = arguments[0];\n    return function (componentClass) {\n      return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n    };\n  } else {\n    return function (componentClass) {\n      return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n    };\n  }\n}\n\nvar protoStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountProto\");\nvar instStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountInst\");\n\nfunction runDisposersOnWillUnmount() {\n  var _this = this;\n\n  [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {\n    var prop = typeof propKeyOrFunction === \"string\" ? _this[propKeyOrFunction] : propKeyOrFunction;\n\n    if (prop !== undefined && prop !== null) {\n      if (Array.isArray(prop)) prop.map(function (f) {\n        return f();\n      });else prop();\n    }\n  });\n}\n\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n  if (Array.isArray(propertyKeyOrFunction)) {\n    return propertyKeyOrFunction.map(function (fn) {\n      return disposeOnUnmount(target, fn);\n    });\n  }\n\n  var c = Object.getPrototypeOf(target).constructor;\n  var c2 = Object.getPrototypeOf(target.constructor); // Special case for react-hot-loader\n\n  var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));\n\n  if (!(c === React__default.Component || c === React__default.PureComponent || c2 === React__default.Component || c2 === React__default.PureComponent || c3 === React__default.Component || c3 === React__default.PureComponent)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n  }\n\n  if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n  } // decorator's target is the prototype, so it doesn't have any instance properties like props\n\n\n  var isDecorator = typeof propertyKeyOrFunction === \"string\"; // add property key / function we want run (disposed) to the store\n\n  var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n  var store = isDecorator ? // decorators are added to the prototype store\n  target[protoStoreKey] || (target[protoStoreKey] = []) : // functions are added to the instance store\n  target[instStoreKey] || (target[instStoreKey] = []);\n  store.push(propertyKeyOrFunction); // tweak the component class componentWillUnmount if not done already\n\n  if (!componentWasAlreadyModified) {\n    patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n  } // return the disposer as is if invoked as a non decorator\n\n\n  if (typeof propertyKeyOrFunction !== \"string\") {\n    return propertyKeyOrFunction;\n  }\n}\n\nfunction createChainableTypeChecker(validator) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n      rest[_key - 6] = arguments[_key];\n    }\n\n    return untracked(function () {\n      componentName = componentName || \"<<anonymous>>\";\n      propFullName = propFullName || propName;\n\n      if (props[propName] == null) {\n        if (isRequired) {\n          var actual = props[propName] === null ? \"null\" : \"undefined\";\n          return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n        }\n\n        return null;\n      } else {\n        // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n        return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n      }\n    });\n  }\n\n  var chainedCheckType = checkType.bind(null, false); // Add isRequired to satisfy Requirable\n\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n} // Copied from React.PropTypes\n\n\nfunction isSymbol(propType, propValue) {\n  // Native Symbol.\n  if (propType === \"symbol\") {\n    return true;\n  } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n  if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n    return true;\n  } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n  if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n    return true;\n  }\n\n  return false;\n} // Copied from React.PropTypes\n\n\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n\n  if (Array.isArray(propValue)) {\n    return \"array\";\n  }\n\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return \"object\";\n  }\n\n  if (isSymbol(propType, propValue)) {\n    return \"symbol\";\n  }\n\n  return propType;\n} // This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\n\n\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n\n  if (propType === \"object\") {\n    if (propValue instanceof Date) {\n      return \"date\";\n    } else if (propValue instanceof RegExp) {\n      return \"regexp\";\n    }\n  }\n\n  return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    return untracked(function () {\n      if (allowNativeType) {\n        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n      }\n\n      var mobxChecker;\n\n      switch (mobxType) {\n        case \"Array\":\n          mobxChecker = isObservableArray;\n          break;\n\n        case \"Object\":\n          mobxChecker = isObservableObject;\n          break;\n\n        case \"Map\":\n          mobxChecker = isObservableMap;\n          break;\n\n        default:\n          throw new Error(\"Unexpected mobxType: \" + mobxType);\n      }\n\n      var propValue = props[propName];\n\n      if (!mobxChecker(propValue)) {\n        var preciseType = getPreciseType(propValue);\n        var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n        return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n      }\n\n      return null;\n    });\n  });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n      rest[_key2 - 5] = arguments[_key2];\n    }\n\n    return untracked(function () {\n      if (typeof typeChecker !== \"function\") {\n        return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n      } else {\n        var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n        if (error instanceof Error) return error;\n        var propValue = props[propName];\n\n        for (var i = 0; i < propValue.length; i++) {\n          error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n          if (error instanceof Error) return error;\n        }\n\n        return null;\n      }\n    });\n  });\n}\n\nvar observableArray = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Object\");\nvar PropTypes = {\n  observableArray: observableArray,\n  observableArrayOf: observableArrayOf,\n  observableMap: observableMap,\n  observableObject: observableObject,\n  arrayOrObservableArray: arrayOrObservableArray,\n  arrayOrObservableArrayOf: arrayOrObservableArrayOf,\n  objectOrObservableObject: objectOrObservableObject\n};\nif (!Component) throw new Error(\"mobx-react requires React to be available\");\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\");\nexport { MobXProviderContext, PropTypes, Provider, disposeOnUnmount, inject, observer };","map":{"version":3,"sources":["../src/utils/utils.ts","../src/observerClass.ts","../src/observer.tsx","../src/Provider.tsx","../src/inject.ts","../src/disposeOnUnmount.ts","../src/propTypes.ts","../src/index.ts"],"names":["symbolId","Symbol","symbol","createdSymbols","newSymbol","name","createSymbol","shallowEqual","objA","objB","is","keysA","Object","keysB","i","x","y","hoistBlackList","$$typeof","render","compare","type","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","displayName","propTypes","copyStaticProperties","base","target","protoProps","setHiddenProp","prop","value","enumerable","configurable","writable","mobxMixins","mobxPatchedDefinition","methodMixins","args","realMethod","retVal","mx","fn","wrapper","patch","methodName","mixinMethod","getMixins","oldDefinition","originalMethod","newDefinition","createDefinition","wrappedFunc","wrapFunction","mobxAdminProperty","$mobx","mobxObserverProperty","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","makeClassComponentObserver","componentClass","getDisplayName","console","makeObservableProp","baseRender","makeComponentReactive","isUsingStaticRendering","comp","initialName","isRenderingPending","reaction","hasError","Component","reactiveRender","exception","rendering","_allowStateChanges","valueHolderKey","atomHolderKey","createAtom","get","prevReadState","_allowStateReadsStart","getAtom","_allowStateReadsEnd","set","hasSymbol","ReactForwardRefSymbol","ReactMemoSymbol","observer","component","observerLite","MobXProviderContext","React","Provider","props","children","stores","parentValue","mutableProviderRef","newValue","Injector","newProps","context","grabStoresFn","getInjectName","componentName","storeNames","storeName","nextProps","baseStores","inject","arguments","createStoreInjector","grabStoresByName","protoStoreKey","instStoreKey","Array","f","disposeOnUnmount","propertyKeyOrFunction","c","c2","c3","isDecorator","componentWasAlreadyModified","store","rest","untracked","propFullName","actual","validator","chainedCheckType","checkType","propType","propValue","isSymbol","getPropType","createChainableTypeChecker","mobxType","mobxChecker","preciseType","getPreciseType","nativeTypeExpectationMessage","allowNativeType","error","createObservableTypeCheckerCreator","typeChecker","observableArray","observableArrayOf","createObservableArrayOfTypeChecker","observableMap","observableObject","arrayOrObservableArray","arrayOrObservableArrayOf","objectOrObservableObject","PropTypes"],"mappings":"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","sourcesContent":["let symbolId = 0\nfunction createSymbol(name: string): symbol | string {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name: string): symbol | string {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA: any, objB: any): boolean {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x: any, y: any): boolean {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    displayName: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base: object, target: object): void {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\n    Object.getOwnPropertyNames(base).forEach(key => {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nexport function setHiddenProp(target: object, prop: any, value: any): void {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nconst mobxMixins = newSymbol(\"patchMixins\")\nconst mobxPatchedDefinition = newSymbol(\"patchedDefinition\")\n\nexport interface Mixins extends Record<string, any> {\n    locks: number\n    methods: Array<Function>\n}\n\nfunction getMixins(target: object, methodName: string): Mixins {\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\n    methodMixins.locks = methodMixins.locks || 0\n    methodMixins.methods = methodMixins.methods || []\n    return methodMixins\n}\n\nfunction wrapper(realMethod: Function, mixins: Mixins, ...args: Array<any>) {\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++\n\n    try {\n        let retVal\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args)\n        }\n\n        return retVal\n    } finally {\n        mixins.locks--\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(mx => {\n                mx.apply(this, args)\n            })\n        }\n    }\n}\n\nfunction wrapFunction(realMethod: Function, mixins: Mixins): (...args: Array<any>) => any {\n    const fn = function (...args: Array<any>) {\n        wrapper.call(this, realMethod, mixins, ...args)\n    }\n    return fn\n}\n\nexport function patch(target: object, methodName: string, mixinMethod: Function): void {\n    const mixins = getMixins(target, methodName)\n\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod)\n    }\n\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return\n    }\n\n    const originalMethod = target[methodName]\n    const newDefinition = createDefinition(\n        target,\n        methodName,\n        oldDefinition ? oldDefinition.enumerable : undefined,\n        mixins,\n        originalMethod\n    )\n\n    Object.defineProperty(target, methodName, newDefinition)\n}\n\nfunction createDefinition(\n    target: object,\n    methodName: string,\n    enumerable: any,\n    mixins: Mixins,\n    originalMethod: Function\n): PropertyDescriptor {\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\n\n    return {\n        [mobxPatchedDefinition]: true,\n        get: function () {\n            return wrappedFunc\n        },\n        set: function (value) {\n            if (this === target) {\n                wrappedFunc = wrapFunction(value, mixins)\n            } else {\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n                // as the method for the instance\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\n                Object.defineProperty(this, methodName, newDefinition)\n            }\n        },\n        configurable: true,\n        enumerable: enumerable\n    }\n}\n","import { PureComponent, Component } from \"react\"\nimport {\n    createAtom,\n    _allowStateChanges,\n    Reaction,\n    $mobx,\n    _allowStateReadsStart,\n    _allowStateReadsEnd\n} from \"mobx\"\nimport { isUsingStaticRendering } from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual, setHiddenProp, patch } from \"./utils/utils\"\n\nconst mobxAdminProperty = $mobx || \"$mobx\"\nconst mobxObserverProperty = newSymbol(\"isMobXReactObserver\")\nconst mobxIsUnmounted = newSymbol(\"isUnmounted\")\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\nexport function makeClassComponentObserver(\n    componentClass: React.ComponentClass<any, any>\n): React.ComponentClass<any, any> {\n    const target = componentClass.prototype\n\n    if (componentClass[mobxObserverProperty]) {\n        const displayName = getDisplayName(target)\n        console.warn(\n            `The provided component class (${displayName}) \n                has already been declared as an observer component.`\n        )\n    } else {\n        componentClass[mobxObserverProperty] = true\n    }\n\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass[\"__proto__\"] !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n\n    // this.props and this.state are made observable, just to make sure @computed fields that\n    // are defined inside the component, and which rely on state or props, re-compute if state or props change\n    // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n    // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n\n    const baseRender = target.render\n    target.render = function () {\n        return makeComponentReactive.call(this, baseRender)\n    }\n    patch(target, \"componentWillUnmount\", function () {\n        if (isUsingStaticRendering() === true) return\n        this.render[mobxAdminProperty]?.dispose()\n        this[mobxIsUnmounted] = true\n\n        if (!this.render[mobxAdminProperty]) {\n            // Render may have been hot-swapped and/or overriden by a subclass.\n            const displayName = getDisplayName(this)\n            console.warn(\n                `The reactive render of an observer class component (${displayName}) \n                was overriden after MobX attached. This may result in a memory leak if the \n                overriden reactive render was not properly disposed.`\n            )\n        }\n    })\n    return componentClass\n}\n\n// Generates a friendly name for debugging\nfunction getDisplayName(comp: any) {\n    return (\n        comp.displayName ||\n        comp.name ||\n        (comp.constructor && (comp.constructor.displayName || comp.constructor.name)) ||\n        \"<component>\"\n    )\n}\n\nfunction makeComponentReactive(render: any) {\n    if (isUsingStaticRendering() === true) return render.call(this)\n\n    /**\n     * If props are shallowly modified, react will render anyway,\n     * so atom.reportChanged() should not result in yet another re-render\n     */\n    setHiddenProp(this, skipRenderKey, false)\n    /**\n     * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n     * so detect these changes\n     */\n    setHiddenProp(this, isForcingUpdateKey, false)\n\n    const initialName = getDisplayName(this)\n    const baseRender = render.bind(this)\n\n    let isRenderingPending = false\n\n    const reaction = new Reaction(`${initialName}.render()`, () => {\n        if (!isRenderingPending) {\n            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n            // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n            // See #85 / Pull #44\n            isRenderingPending = true\n            if (this[mobxIsUnmounted] !== true) {\n                let hasError = true\n                try {\n                    setHiddenProp(this, isForcingUpdateKey, true)\n                    if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this)\n                    hasError = false\n                } finally {\n                    setHiddenProp(this, isForcingUpdateKey, false)\n                    if (hasError) reaction.dispose()\n                }\n            }\n        }\n    })\n\n    reaction[\"reactComponent\"] = this\n    reactiveRender[mobxAdminProperty] = reaction\n    this.render = reactiveRender\n\n    function reactiveRender() {\n        isRenderingPending = false\n        let exception = undefined\n        let rendering = undefined\n        reaction.track(() => {\n            try {\n                rendering = _allowStateChanges(false, baseRender)\n            } catch (e) {\n                exception = e\n            }\n        })\n        if (exception) {\n            throw exception\n        }\n        return rendering\n    }\n\n    return reactiveRender.call(this)\n}\n\nfunction observerSCU(nextProps: React.Props<any>, nextState: any): boolean {\n    if (isUsingStaticRendering()) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target: any, propName: string): void {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            let prevReadState = false\n\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\n                prevReadState = _allowStateReadsStart(true)\n            }\n            getAtom.call(this).reportObserved()\n\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\n                _allowStateReadsEnd(prevReadState)\n            }\n\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n","import * as React from \"react\"\nimport { observer as observerLite, Observer } from \"mobx-react-lite\"\n\nimport { makeClassComponentObserver } from \"./observerClass\"\nimport { IReactComponent } from \"./types/IReactComponent\"\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof React.forwardRef === \"function\" && React.forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof React.memo === \"function\" && React.memo((props: any) => null)[\"$$typeof\"]\n\n/**\n * Observer function / decorator\n */\nexport function observer<T extends IReactComponent>(component: T): T {\n    if (component[\"isMobxInjector\"] === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    if (ReactMemoSymbol && component[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            \"Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\"\n        )\n    }\n\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && component[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = component[\"render\"]\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return React.forwardRef(function ObserverForwardRef() {\n            const args = arguments\n            return <Observer>{() => baseRender.apply(undefined, args)}</Observer>\n        }) as T\n    }\n\n    // Function component\n    if (\n        typeof component === \"function\" &&\n        (!component.prototype || !component.prototype.render) &&\n        !component[\"isReactClass\"] &&\n        !Object.prototype.isPrototypeOf.call(React.Component, component)\n    ) {\n        return observerLite(component as React.StatelessComponent<any>) as T\n    }\n\n    return makeClassComponentObserver(component as React.ComponentClass<any, any>) as T\n}\n","import React from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\nimport { IValueMap } from \"./types/IValueMap\"\n\nexport const MobXProviderContext = React.createContext<IValueMap>({})\n\nexport interface ProviderProps extends IValueMap {\n    children: React.ReactNode\n}\n\nexport function Provider(props: ProviderProps) {\n    const { children, ...stores } = props\n    const parentValue = React.useContext(MobXProviderContext)\n    const mutableProviderRef = React.useRef({ ...parentValue, ...stores })\n    const value = mutableProviderRef.current\n\n    if (__DEV__) {\n        const newValue = { ...value, ...stores } // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\n            )\n        }\n    }\n\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\n}\n\nProvider.displayName = \"MobXProvider\"\n","import React from \"react\"\nimport { observer } from \"./observer\"\nimport { copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\nimport { IReactComponent } from \"./types/IReactComponent\"\nimport { IValueMap } from \"./types/IValueMap\"\nimport { IWrappedComponent } from \"./types/IWrappedComponent\"\nimport { IStoresToProps } from \"./types/IStoresToProps\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(\n    grabStoresFn: IStoresToProps,\n    component: IReactComponent<any>,\n    injectNames: string,\n    makeReactive: boolean\n): IReactComponent<any> {\n    // Support forward refs\n    let Injector: IReactComponent<any> = React.forwardRef((props, ref) => {\n        const newProps = { ...props }\n        const context = React.useContext(MobXProviderContext)\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {})\n\n        if (ref) {\n            newProps.ref = ref\n        }\n\n        return React.createElement(component, newProps)\n    })\n\n    if (makeReactive) Injector = observer(Injector)\n    Injector[\"isMobxInjector\"] = true // assigned late to suppress observer warning\n\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector)\n    Injector[\"wrappedComponent\"] = component\n    Injector.displayName = getInjectName(component, injectNames)\n    return Injector\n}\n\nfunction getInjectName(component: IReactComponent<any>, injectNames: string): string {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(\n    storeNames: Array<string>\n): (baseStores: IValueMap, nextProps: React.Props<any>) => React.PropsWithRef<any> | undefined {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\nexport function inject(\n    ...stores: Array<string>\n): <T extends IReactComponent<any>>(\n    target: T\n) => T & (T extends IReactComponent<infer P> ? IWrappedComponent<P> : never)\nexport function inject<S, P, I, C>(\n    fn: IStoresToProps<S, P, I, C>\n): <T extends IReactComponent>(target: T) => T & IWrappedComponent<P>\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames: Array<any>) {\n    if (typeof arguments[0] === \"function\") {\n        let grabStoresFn = arguments[0]\n        return (componentClass: React.ComponentClass<any, any>) =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return (componentClass: React.ComponentClass<any, any>) =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import React from \"react\"\nimport { patch, newSymbol } from \"./utils/utils\"\n\ntype Disposer = () => void\n\nconst protoStoreKey = newSymbol(\"disposeOnUnmountProto\")\nconst instStoreKey = newSymbol(\"disposeOnUnmountInst\")\n\nfunction runDisposersOnWillUnmount() {\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop)) prop.map(f => f())\n            else prop()\n        }\n    })\n}\n\nexport function disposeOnUnmount(target: React.Component<any, any>, propertyKey: PropertyKey): void\nexport function disposeOnUnmount<TF extends Disposer | Array<Disposer>>(\n    target: React.Component<any, any>,\n    fn: TF\n): TF\n\nexport function disposeOnUnmount(\n    target: React.Component<any, any>,\n    propertyKeyOrFunction: PropertyKey | Disposer | Array<Disposer>\n): PropertyKey | Disposer | Array<Disposer> | void {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor\n    const c2 = Object.getPrototypeOf(target.constructor)\n    // Special case for react-hot-loader\n    const c3 = Object.getPrototypeOf(Object.getPrototypeOf(target))\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent ||\n            c3 === React.Component ||\n            c3 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (\n        typeof propertyKeyOrFunction !== \"string\" &&\n        typeof propertyKeyOrFunction !== \"function\" &&\n        !Array.isArray(propertyKeyOrFunction)\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\n    const store = isDecorator\n        ? // decorators are added to the prototype store\n          target[protoStoreKey] || (target[protoStoreKey] = [])\n        : // functions are added to the instance store\n          target[instStoreKey] || (target[instStoreKey] = [])\n\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validator: React.Validator<any>): React.Requireable<any> {\n    function checkType(\n        isRequired: boolean,\n        props: any,\n        propName: string,\n        componentName: string,\n        location: string,\n        propFullName: string,\n        ...rest: any[]\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n                return validator(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType: any = checkType.bind(null, false)\n    // Add isRequired to satisfy Requirable\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType: any, propValue: any): boolean {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue: any): string {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue: any): string {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(\n    allowNativeType: any,\n    mobxType: any\n): React.Requireable<any> {\n    return createChainableTypeChecker((props, propName, componentName, location, propFullName) => {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(\n    allowNativeType: boolean,\n    typeChecker: React.Validator<any>\n) {\n    return createChainableTypeChecker(\n        (props, propName, componentName, location, propFullName, ...rest) => {\n            return untracked(() => {\n                if (typeof typeChecker !== \"function\") {\n                    return new Error(\n                        \"Property `\" +\n                            propFullName +\n                            \"` of component `\" +\n                            componentName +\n                            \"` has \" +\n                            \"invalid PropType notation.\"\n                    )\n                } else {\n                    let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                        props,\n                        propName,\n                        componentName,\n                        location,\n                        propFullName\n                    )\n\n                    if (error instanceof Error) return error\n                    const propValue = props[propName]\n                    for (let i = 0; i < propValue.length; i++) {\n                        error = (typeChecker as React.Validator<any>)(\n                            propValue,\n                            i as any,\n                            componentName,\n                            location,\n                            propFullName + \"[\" + i + \"]\",\n                            ...rest\n                        )\n                        if (error instanceof Error) return error\n                    }\n\n                    return null\n                }\n            })\n        }\n    )\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable } from \"mobx\"\nimport { Component } from \"react\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nexport {\n    Observer,\n    useObserver,\n    useAsObservableSource,\n    useLocalStore,\n    isUsingStaticRendering,\n    useStaticRendering,\n    enableStaticRendering,\n    observerBatching,\n    useLocalObservable\n} from \"mobx-react-lite\"\n\nexport { observer } from \"./observer\"\n\nexport { MobXProviderContext, Provider, ProviderProps } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\nexport { IWrappedComponent } from \"./types/IWrappedComponent\"\n"]},"metadata":{},"sourceType":"module"}